<!-- ======================= HTML STRUCTURE ======================= -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Producción de Pan</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { font-family: 'Inter', system-ui, sans-serif; }
      .tab-btn { padding:0.5rem 1rem; font-size:.875rem; font-weight:600; border-radius:.75rem; border:1px solid #d6d3d1; background:#fff; color:#57534e; transition:all .18s; }
      .tab-btn:hover { background:#f5f5f4; color:#111827; }
      .tab-btn-active { background:#2563eb; color:#fff; border-color:#2563eb; box-shadow:0 1px 2px rgba(0,0,0,.08); }
            /* Main tabs larger without affecting sub-tabs */
            .tab-btn.main-tab { padding:0.625rem 1.25rem; font-size:1rem; border-radius:1rem; }
      .metric-badge { display:inline-block; padding:2px 6px; border-radius:6px; font-size:.625rem; font-weight:600; background:#e7e5e4; color:#44403c; }
      .metric-badge.warn { background:#fee2e2; color:#dc2626; }
    .chart-desc { display:none; font-size:.75rem; line-height:1.1rem; color:#475569; font-style:italic; margin-top:-6px; margin-bottom:10px; padding-left:.75rem; border-left:3px solid #2563eb20; }
    .chart-title { cursor:pointer; }
    .chart-title:hover .info-hint { text-decoration:underline; }
    </style>
</head>
<body class="bg-stone-50 text-stone-800 min-h-screen">
    <!-- Auth overlay (clave de acceso) -->
    <div id="auth-overlay" class="fixed inset-0 bg-white/95 backdrop-blur-sm z-[10000] hidden">
        <div class="w-full h-full flex items-center justify-center p-4">
            <div class="bg-white border border-stone-300 rounded-2xl shadow-xl p-6 w-full max-w-md">
                <h2 id="auth-title" class="text-2xl font-extrabold text-stone-900 mb-1">Clave de acceso</h2>
                <p id="auth-sub" class="text-sm text-stone-600 mb-4">Ingresa la clave fija para usar la app.</p>
                <div id="auth-login-fields">
                    <label class="block text-sm font-medium text-stone-700 mb-1">Clave (fija)</label>
                    <input id="auth-pass" type="password" class="w-full border rounded px-3 py-2" placeholder="••••••" />
                    <label class="inline-flex items-center gap-2 text-sm text-stone-700 mt-3">
                        <input id="auth-recordar" type="checkbox" class="border rounded" /> Recordar en este navegador
                    </label>
                </div>
                <div class="mt-5 flex flex-wrap gap-2 justify-end">
                    <div class="flex-1"></div>
                    <button id="auth-cancel" class="px-3 py-2 text-sm rounded border border-stone-300">Cerrar</button>
                    <button id="auth-submit" class="px-4 py-2 text-sm rounded bg-blue-600 text-white font-semibold">Continuar</button>
                </div>
                <div id="auth-msg" class="mt-3 text-sm"></div>
            </div>
        </div>
    </div>
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
    <!-- Main app tabs: Menu | Amasadoras | Fermentadora | Hornos -->
    <div class="flex flex-wrap justify-center gap-4 mb-8">
        <button id="tab-main-menu" class="tab-btn main-tab tab-btn-active">Menú</button>
        <button id="tab-main-amasadoras" class="tab-btn main-tab">Amasadoras</button>
        <button id="tab-main-fermentadora" class="tab-btn main-tab">Fermentadora</button>
        <button id="tab-main-hornos" class="tab-btn main-tab">Hornos</button>
    </div>
    <!-- Menú view (about + ajustes) -->
    <div id="view-main-menu" class="block">
        <div class="mb-10 text-center max-w-4xl mx-auto">
            <h1 class="text-4xl md:text-5xl font-extrabold mb-3 text-stone-900 tracking-tight">Curvas de control para producción de pan</h1>
            <p class="text-stone-700 text-lg leading-relaxed">Aplicación para medir y analizar la producción de pan en el área de Producción de la empresa <strong>Pan de Tata</strong>, creada como parte de un proyecto de <strong>pasantías</strong>.</p>
            <p class="text-stone-700 text-lg mt-3">Desarrollada por <strong>Gerardo Siblesz</strong>, estudiante de <strong>Ingeniería en Producción y Mecánica</strong> de la <strong>Universidad Metropolitana</strong>.</p>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-5xl mx-auto">
            <div class="bg-white border border-stone-200 rounded-xl p-6 shadow-sm">
                <h2 class="text-2xl font-extrabold text-stone-900 mb-3">Cómo funciona</h2>
                <ul class="list-disc ml-6 text-base text-stone-700 space-y-1.5">
                    <li>Registra variables generales y tiempos por máquina.</li>
                    <li>Guarda resultados locales y envíalos a la Base de Datos.</li>
                    <li>Consulta desde cualquier dispositivo usando la misma API y clave.</li>
                    <li>Explora Resultados y Tablas para análisis y exporta en CSV/PDF.</li>
                </ul>
            </div>
            <div id="ajustes-card" class="bg-white border border-stone-200 rounded-xl p-6 shadow-sm hidden">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-2xl font-extrabold text-stone-900">Ajustes</h2>
                    <button id="toggle-ajustes" class="text-sm text-stone-600 underline">Mostrar ajustes</button>
                </div>
                <div id="ajustes-content" class="space-y-4 text-base hidden">
                    <div>
                        <label class="block font-semibold text-stone-700">URL de la API</label>
                        <input id="settings-api-url" class="w-full border rounded px-3 py-2 text-base" placeholder="https://tu-backend" />
                        <button id="settings-save-api" class="mt-2 bg-stone-700 text-white px-4 py-2 rounded">Guardar URL</button>
                    </div>
                    <div>
                        <label class="block font-semibold text-stone-700">Clave de API</label>
                        <div class="relative flex items-center gap-2">
                            <input id="settings-api-key" type="password" class="w-full border rounded px-3 py-2 text-base pr-16" placeholder="••••••" />
                            <button type="button" id="settings-api-toggle" class="absolute right-2 top-1/2 -translate-y-1/2 text-xs px-2 py-1 rounded border border-stone-300 bg-stone-100 hover:bg-stone-200">Mostrar</button>
                        </div>
                        <label class="inline-flex items-center gap-2 mt-2"><input id="settings-remember-key" type="checkbox" class="scale-110" /> Recordar en este dispositivo</label>
                        <button id="settings-save-key" class="ml-2 bg-blue-600 text-white px-4 py-2 rounded">Guardar clave</button>
                        <div id="settings-key-status" class="mt-2 text-sm text-stone-600"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fermentadora (placeholder) - sección de nivel superior -->
    <div id="section-fermentadora" class="hidden">
        <div class="bg-white border border-stone-200 rounded-xl p-8 shadow-sm text-center text-stone-600 max-w-3xl mx-auto">
            Próximamente: módulo de Fermentadora.
        </div>
    </div>

    <!-- Hornos (placeholder) - sección de nivel superior -->
    <div id="section-hornos" class="hidden">
        <div class="bg-white border border-stone-200 rounded-xl p-8 shadow-sm text-center text-stone-600 max-w-3xl mx-auto">
            Próximamente: módulo de Hornos.
        </div>
    </div>
    <!-- Amasadoras section (existing app) -->
    <div id="section-amasadoras" class="hidden">
                <!-- Nueva estructura: layout con sidebar (Amasadoras) -->
                <div class="grid grid-cols-12 gap-4 mb-6">
                    <aside class="col-span-12 md:col-span-2 md:w-44">
                        <div class="hidden md:block mb-2"><button id="amas-sidebar-collapse" class="text-xs text-stone-600 hover:text-stone-900 underline">Ocultar menú</button></div>
                        <nav id="amas-sidebar" class="flex md:flex-col flex-wrap md:space-y-2 gap-2 transition-all">
                            <button data-amas-sub="captura" class="tab-btn w-full tab-btn-active">Amasadoras</button>
                            <button data-amas-sub="resultados" class="tab-btn w-full">Resultados</button>
                            <button data-amas-sub="tablas" class="tab-btn w-full">Tablas</button>
                            <button id="switch-to-mesa" class="mt-2 tab-btn w-full bg-stone-100">→ Mesa</button>
                        </nav>
                    </aside>
                    <div class="col-span-12 md:col-span-10" id="amas-content-wrapper">
                        <div id="amas-sub-captura" class="amas-subview">
                            <!-- Contenido de Medición (captura) reubicado dentro de la subvista captura -->
                            <div id="view-medicion" class="">
                                <div class="mb-8">
                                    <h1 class="text-3xl font-extrabold text-stone-900 tracking-tight mb-2">Cálculo de Amasadoras</h1>
                                    <p class="text-stone-600 text-sm md:text-base">Cómo operar el programa: registra primero las variables generales (fecha, TA, H, personal). Luego en cada tarjeta de amasadora define el tipo de masa y controla los tres procesos secuencialmente. Guarda cada máquina al terminar para formar un conjunto que luego podrás analizar y exportar.</p>
                                </div>
                                <div id="instrucciones-medicion" class="mb-8">
                                    <details open class="bg-white border border-stone-300 rounded-xl p-4 shadow-sm">
                                        <summary class="cursor-pointer select-none font-semibold text-stone-800 text-lg flex items-center gap-2">
                                            <span>Instrucciones (crear conjunto, analizar y exportar)</span>
                                        </summary>
                                        <div class="mt-3 space-y-3 text-sm leading-relaxed text-stone-700">
                                            <p><span class="font-semibold">¿Qué es un conjunto?</span> Es un registro de una <strong>fecha</strong> con una o varias <strong>amasadoras</strong> y sus 3 procesos: <strong>Esponja</strong>, <strong>Masa</strong> y <strong>Mantequilla</strong> (tiempos reales, inicios, fines), más variables: <strong>Lote</strong>, <strong>Tipo de masa</strong>, <strong>Hielo</strong>, <strong>TM/TA/H</strong>, <strong>Personal</strong> y <strong>Observaciones</strong>.</p>
                                            <ol class="list-decimal ml-5 space-y-1">
                                                <li>Completa <strong>Fecha</strong>, <strong>TA</strong>, <strong>H</strong> y <strong>Personal (mín–máx)</strong>.</li>
                                                <li>En cada amasadora define <strong>Tipo de masa</strong>, marca <strong>Hielo</strong> si aplica y al finalizar registra <strong>Temp. de masa</strong> y <strong>Observaciones</strong>.</li>
                                                <li>Ejecuta los procesos en orden (Iniciar / Detener). Sólo puede estar activo uno por máquina; iniciar otro detiene el previo.</li>
                                                <li>Se guardan inicio, fin y duración. El <strong>Total máquina</strong> va desde el inicio del primer proceso al fin del tercero. <strong>TM1 / TM2</strong> son los huecos entre procesos.</li>
                                                <li>Pulsa <strong>Guardar resultados</strong> al terminar los 3 procesos de la máquina. Repite para otras.</li>
                                                <li>Pasa a la pestaña <strong>Resultados</strong> para ver, filtrar y revisar. Desde <strong>Base de datos</strong> puedes: <em>Refrescar</em>, <em>Ver JSON</em> (abre un modal con Copiar), <em>Borrar</em> y ver <em>Detalles</em> por amasadora (TM1/TM2/Total real/Total procesos/Obs y tiempos por proceso).</li>
                                                <li>En <strong>Resultados → Locales</strong> puedes enviar una tarjeta con <em>Enviar a BD</em> o toda la fecha con <em>Enviar todo a la BD</em>. Evitamos clics múltiples para no duplicar.</li>
                                                <li>En <strong>Tablas</strong> elige la <em>Fuente</em>: <strong>Locales</strong> o <strong>Base de datos</strong> (con filtro por <em>Fecha</em>). Las tablas y gráficas se adaptan al origen.</li>
                                                <li><strong>Borrar todo</strong> elimina definitivamente todos los registros guardados.</li>
                                                <li><strong>Exportar PDF</strong>: reporte visual de la vista de resultados (sin botones).</li>
                                                <li><strong>Exportar CSV</strong>: filas compactadas (una por proceso) con factores diarios y de máquina sólo en la primera fila de cada máquina. Incluye TM1, TM2, TM.Total y Total(s).</li>
                                            </ol>
                                            <p><span class="font-semibold">Privacidad:</span> La clave (si la guardas) queda sólo en este navegador (localStorage).</p>
                                        </div>
                                    </details>
                                </div>
                                <!-- Variables generales y tarjetas (contenido original de captura permanece debajo) -->
                            </div>
                            <!-- Fin view-medicion reubicado -->
                <!-- (El contenido dinámico de captura existente continúa abajo sin cambios) -->
            <div class="mb-6 text-center">
                <h2 class="text-3xl font-extrabold mb-2 text-stone-900 tracking-tight">Tablas y Gráficas</h2>
                <p class="text-stone-600 max-w-2xl mx-auto">Promedios, desviaciones y distribución visual por tipo de masa, amasadora y procesos.</p>
            </div>
                <div class="mb-4 flex flex-wrap gap-3 justify-center items-center">
                    <label for="tablas-source" class="text-sm text-stone-700">Fuente:</label>
                    <select id="tablas-source" class="border rounded px-2 py-1 text-sm">
                        <option value="local">Locales</option>
                        <option value="bd">Base de datos</option>
                    </select>
                    <div id="tablas-bd-controls" class="hidden flex flex-wrap items-center gap-2">
                        <label class="text-sm text-stone-700">Desde:</label>
                        <input id="tablas-bd-desde" type="date" class="border rounded px-2 py-1 text-sm" />
                        <label class="text-sm text-stone-700">Hasta:</label>
                        <input id="tablas-bd-hasta" type="date" class="border rounded px-2 py-1 text-sm" />
                        <input id="tablas-bd-lote" placeholder="Lote" class="border rounded px-2 py-1 text-sm w-28" />
                        <input id="tablas-bd-tipo" placeholder="Tipo de masa" class="border rounded px-2 py-1 text-sm w-36" />
                        <button id="tablas-bd-clear" class="text-sm text-stone-600 hover:text-stone-900 underline">Quitar filtros</button>
                    </div>
                    <div id="tablas-export-controls" class="flex flex-wrap items-center gap-2">
                        <span class="mx-2 text-stone-300">|</span>
                        <button id="tablas-export-pdf" class="bg-blue-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-blue-700">Exportar (PDF)</button>
                        <button id="tablas-export-csv" class="bg-emerald-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-emerald-700">Exportar (CSV)</button>
                    </div>
                    <span id="tablas-status" class="text-xs text-stone-600"></span>
                </div>
            <div class="mb-8 max-w-3xl mx-auto">
                <!-- NUEVO: Lista de fechas registradas -->
                <div class="mb-10" id="tablas-fechas-wrapper">
                    <h3 class="text-xl font-bold mb-3 text-stone-800 flex items-center gap-2">Fechas registradas <span id="tablas-fechas-total" class="text-sm font-normal text-stone-500"></span></h3>
                    <div id="tablas-fechas-list" class="flex flex-wrap gap-2"></div>
                    <div id="tablas-fechas-detalle" class="mt-4 hidden"></div>
                </div>
                <details open class="bg-white border border-stone-300 rounded-xl p-4 shadow-sm">
                    <summary class="cursor-pointer select-none font-semibold text-stone-800 text-lg">Mapeo de gráficas y propósito analítico</summary>
                    <div class="mt-3 text-sm space-y-3 text-stone-700">
                        <ul class="list-disc ml-5 space-y-1">
                            <li><span class="font-medium">Punto de partida (1)</span>: Resumen de tiempos (nivel y variabilidad base).</li>
                            <li><span class="font-medium">Benchmark (2, 5)</span>: Diferencias entre tipos de masa y su temperatura final.</li>
                            <li><span class="font-medium">Optimización (3, 4, 9, 13)</span>: Dónde atacar: máquina lenta, etapa dominante, % muerto y eficiencia (OEE).</li>
                            <li><span class="font-medium">Consistencia estadística (5, 6, 8, 14, 15)</span>: Control de dispersión y estabilidad (temperatura, cruce equipo/receta, boxplot, control charts con rebaseline).</li>
                            <li><span class="font-medium">Contexto operativo (7, 11)</span>: Ambiente (TA/H) y dotación (personal rango/midpoint) para correlaciones indirectas.</li>
                            <li><span class="font-medium">Relación causal (10)</span>: Posible dependencia entre temperatura de masa y duración total.</li>
                            <li><span class="font-medium">Tendencia agregada (12)</span>: Evolución semanal resumida (OEE, tiempo promedio, % muerto).</li>
                            <li><span class="font-medium">Señales y priorización (16, 17, 18)</span>: Detección SPC multi-regla, ranking (Top 3), tabla detalle indexada.</li>
                            <li><span class="font-medium">Evolución estructural</span>: Rebaselines para reflejar cambios sostenidos sin falsos positivos.</li>
                        </ul>
                        <p class="text-xs text-stone-500">Los números refieren al orden visual abajo. Un rebaseline redefine límites a partir de un punto estable tras mejora o cambio.</p>
                    </div>
                </details>
            </div>
            <div id="tablas-wrapper" class="space-y-10">
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Resumen de tiempos (s) <span class="info-hint text-blue-600 cursor-help align-middle" title="Indicadores globales: registros, promedio total y variabilidad.">ℹ️</span></h3>
                    <p class="chart-desc">Muestra KPIs globales: número de registros, promedio total y dispersión (desviación y %). Punto de partida para ver si el proceso se estabiliza.</p>
                    <div id="tabla-resumen" class="overflow-x-auto text-sm"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Promedios por tipo de masa <span class="info-hint text-blue-600 cursor-help align-middle" title="Tiempo total promedio por receta.">ℹ️</span></h3>
                    <p class="chart-desc">Compara recetas y ayuda a detectar cuáles requieren más tiempo total. Útil para priorizar mejoras o ajustar programación.</p>
                    <div id="tabla-pan" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-pan" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Promedios por amasadora <span class="info-hint text-blue-600 cursor-help align-middle" title="Comparación entre equipos.">ℹ️</span></h3>
                    <p class="chart-desc">Identifica máquinas más lentas o con tiempos fuera de rango para redistribuir cargas o revisar mantenimiento.</p>
                    <div id="tabla-amasadora" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-amasadora" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Promedios por proceso <span class="info-hint text-blue-600 cursor-help align-middle" title="Duración típica de cada etapa.">ℹ️</span></h3>
                    <p class="chart-desc">Revela cuál de las 3 etapas domina el ciclo y dónde un ajuste reduciría más el tiempo total.</p>
                    <div id="tabla-proceso" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-proceso" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Temperatura de masa <span class="info-hint text-blue-600 cursor-help align-middle" title="Temperatura promedio por tipo de masa.">ℹ️</span></h3>
                    <p class="chart-desc">Controla la consistencia térmica: variaciones grandes pueden afectar fermentación o calidad final.</p>
                    <div id="tabla-temp" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-temp-pan" height="140" class="mb-8"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Temp. masa (Amasadora vs Tipo de masa) <span class="info-hint text-blue-600 cursor-help align-middle" title="Cruce equipo vs receta.">ℹ️</span></h3>
                    <p class="chart-desc">Detecta si ciertas máquinas generan sistemáticamente temperaturas distintas para la misma receta.</p>
                    <div id="tabla-temp-cruzada" class="overflow-x-auto text-sm"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">TA y Humedad por día <span class="info-hint text-blue-600 cursor-help align-middle" title="Promedio diario de temperatura ambiente y humedad.">ℹ️</span></h3>
                    <p class="chart-desc">Para cada fecha, se resume la Temperatura Ambiente (TA) y la Humedad (H) promedio basadas en las máquinas registradas ese día.</p>
                    <div id="tabla-ta-h-dia" class="overflow-x-auto text-sm mb-4"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Distribución tiempos por tipo de masa (Boxplot) <span class="info-hint text-blue-600 cursor-help align-middle" title="Variabilidad por receta.">ℹ️</span></h3>
                    <p class="chart-desc">Mide estabilidad operativa: IQR reducido indica proceso controlado; valores altos sugieren inconsistencia.</p>
                    <canvas id="chart-boxplot-tipo" height="220" class="mb-2"></canvas>
                    <div id="boxplot-explicacion" class="text-xs text-stone-600 leading-snug hidden"></div>
                    <div id="boxplot-stats" class="overflow-x-auto text-xs mt-2"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Tiempos productivos vs muertos por amasadora <span class="info-hint text-blue-600 cursor-help align-middle" title="Proporción de inactividad.">ℹ️</span></h3>
                    <p class="chart-desc">Cuantifica ineficiencia: mayor porcentaje de tiempo muerto = oportunidad directa de optimización.</p>
                    <canvas id="chart-stacked-muertos" height="140"></canvas>
                </section>
                <!-- PATRÓN AUTOMÁTICO SIMPLE -->
                <section id="patron-simple-section">
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Patrón automático (lotes más lentos) <span class="info-hint text-blue-600 cursor-help align-middle" title="Detecta la(s) variable(s) comunes entre los lotes con mayor tiempo real promedio.">ℹ️</span></h3>
                    <p class="chart-desc">Muestra directamente qué valor(es) se repiten con fuerza en los lotes más lentos (basado en tiempo real promedio por lote). Sin controles: se calcula solo.</p>
                    <div id="patron-simple" class="text-xs p-3 border border-stone-300 rounded bg-white text-stone-600">Calculando patrón...</div>
                </section>
                <!-- PANEL COMBINADO: Patrones Globales vs Lotes -->
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Patrones (Globales vs Lotes) <span class="info-hint text-blue-600 cursor-help align-middle" title="Ranking global de factores y comparación de lotes extremos (% muerto).">ℹ️</span></h3>
                    <p class="chart-desc">Izquierda: factores globales que se asocian estadísticamente a menor % muerto y mayor productividad. Derecha: comparación de lotes con % muerto más alto vs más bajo, mostrando factores comunes. Usa ambos para priorizar mejoras y replicar buenas prácticas.</p>
                    <details class="mb-3">
                        <summary class="cursor-pointer text-xs text-stone-600">Cómo se calcula (clic para ver)</summary>
                        <div class="mt-2 text-[11px] leading-relaxed text-stone-600 space-y-1">
                            <p><strong>Global:</strong> Se filtran outliers de % muerto por IQR. Con el conjunto base se calcula una línea base (media) de % muerto y productividad (tiempo procesos / total). Cada factor (categoría o tercil numérico) se evalúa si tiene menor % muerto y mayor productividad con suficientes muestras (Min muestras factor). El score combina: mejora relativa en % muerto y productividad, t-score aproximado y tamaño de muestra (log).</p>
                            <p><strong>Lotes extremos:</strong> Se promedia % muerto por lote. Se escogen los N lotes con mayor y menor % muerto (aplicando mínimo de máquinas) y se listan los factores dominantes (moda) y el rango de temperatura de masa.</p>
                            <p><strong>Interacción:</strong> Cambiar parámetros sólo recalcula esta sección y mantiene tu posición en la página.</p>
                        </div>
                    </details>
                    <div class="flex flex-wrap items-center gap-4 mb-4 text-[11px]">
                        <label class="flex items-center gap-1">Min muestras factor: <input id="patrones-min-grupo" type="number" min="2" max="20" value="3" class="w-14 border rounded px-1 py-0.5" /></label>
                        <label class="flex items-center gap-1">Top factores: <input id="patrones-top-fact" type="number" min="1" max="15" value="5" class="w-14 border rounded px-1 py-0.5" /></label>
                        <span class="mx-2 hidden md:inline text-stone-300">|</span>
                        <label class="flex items-center gap-1">Top N lotes: <input id="patrones-lote-topN" type="number" min="2" max="10" value="3" class="w-14 border rounded px-1 py-0.5" /></label>
                        <label class="flex items-center gap-1">Min máquinas/lote: <input id="patrones-lote-minN" type="number" min="1" max="20" value="1" class="w-16 border rounded px-1 py-0.5" /></label>
                        <button id="patrones-recalc-todo" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-3 py-1.5 rounded">Recalcular</button>
                        <button id="patrones-export-global" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold px-3 py-1.5 rounded">CSV Global</button>
                        <button id="patrones-export-lotes" class="bg-amber-600 hover:bg-amber-700 text-white font-semibold px-3 py-1.5 rounded">CSV Lotes</button>
                        <span id="patrones-lote-status" class="text-stone-500"></span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                        <div class="border border-stone-300 rounded-lg p-3 bg-white">
                            <div class="text-[11px] font-semibold uppercase tracking-wide mb-1 text-stone-700">Factores globales</div>
                            <div id="patrones-panel" class="text-xs"></div>
                        </div>
                        <div class="border border-stone-300 rounded-lg p-3 bg-white">
                            <div class="text-[11px] font-semibold uppercase tracking-wide mb-1 text-stone-700">Lotes extremos</div>
                            <div id="patrones-lote-panel" class="text-xs"></div>
                        </div>
                    </div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Relación temperatura de masa vs tiempo total <span class="info-hint text-blue-600 cursor-help align-middle" title="Correlación tiempo vs calor.">ℹ️</span></h3>
                    <p class="chart-desc">Evalúa si la temperatura final se asocia a mayor o menor duración (r cercano a 0 indica poca relación).</p>
                    <canvas id="chart-scatter-temp-tiempo" height="160"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Personal por día (mín–máx) <span class="info-hint text-blue-600 cursor-help align-middle" title="Resumen diario de dotación (límite inferior y superior).">ℹ️</span></h3>
                    <p class="chart-desc">Para cada fecha se muestra el mínimo y máximo de personal (agregado por día), su midpoint y el rango. Debajo se compara visualmente por día.</p>
                    <div id="tabla-personal-dia" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-personal-dia" height="140"></canvas>
                </section>
                <!-- NUEVOS: Control Charts y OEE -->
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">OEE global (aprox)</h3>
                    <p class="chart-desc">Indicador simplificado: (Tiempo productivo / Tiempo total real). No incluye factor de calidad. Sirve para comparar eficiencia día a día.</p>
                    <div id="oee-indicador" class="text-sm mb-4"></div>
                    <div id="sparkline-semanal-wrapper" class="text-xs text-stone-600">
                        <div class="font-semibold text-stone-700 mb-1">Tendencia semanal</div>
                        <div class="flex flex-wrap gap-6 items-end">
                            <div>
                                <div class="text-[10px] uppercase tracking-wide text-stone-500 mb-0.5">OEE%</div>
                                <div id="spark-oee" class="spark-mini"></div>
                            </div>
                            <div>
                                <div class="text-[10px] uppercase tracking-wide text-stone-500 mb-0.5">Tiempo prom (s)</div>
                                <div id="spark-tiempo" class="spark-mini"></div>
                            </div>
                            <div>
                                <div class="text-[10px] uppercase tracking-wide text-stone-500 mb-0.5">% Muerto</div>
                                <div id="spark-muerto" class="spark-mini"></div>
                            </div>
                        </div>
                    </div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Control de tiempo total (Control Chart) <span class="info-hint text-blue-600 cursor-help align-middle" title="Promedio y límites ±3σ sobre el tiempo total real por máquina (orden cronológico).">ℹ️</span></h3>
                    <p class="chart-desc">Detecta variaciones especiales: puntos fuera de límites o patrones. Líneas: CL (media), UCL/LCL (±3σ). Sólo se dibujan límites si hay al menos 5 puntos. Usa rebaseline cuando el proceso cambió estructuralmente.</p>
                    <canvas id="chart-ctrl-tiempo" height="150" class="mb-2"></canvas>
                    <div class="flex items-center gap-3 mb-1">
                        <div id="chart-ctrl-tiempo-info" class="text-xs text-stone-600 grow"></div>
                        <div class="flex items-center gap-1">
                            <input id="rebase-tiempo-indice" type="number" min="0" class="w-20 text-xs border rounded px-1 py-0.5" placeholder="# índice" />
                            <button id="btn-rebaseline-tiempo" class="bg-blue-600 hover:bg-blue-700 text-white text-[11px] font-semibold px-2 py-1 rounded">Rebaseline</button>
                            <button id="btn-clear-rebaseline-tiempo" class="bg-stone-500 hover:bg-stone-600 text-white text-[11px] font-semibold px-2 py-1 rounded" title="Eliminar rebaseline guardado">Reset</button>
                        </div>
                    </div>
                    <div id="segments-tiempo" class="text-[10px] text-stone-600 mb-2 space-y-0.5"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Control % tiempo muerto <span class="info-hint text-blue-600 cursor-help align-middle" title="Porcentaje de tiempo inactivo respecto al total real por máquina (media y ±3σ).">ℹ️</span></h3>
                    <p class="chart-desc">Mide estabilidad del % de inactividad. Rebaseline si hay nuevo estándar operativo para evitar falsas alarmas.</p>
                    <canvas id="chart-ctrl-muerto" height="150" class="mb-2"></canvas>
                    <div class="flex items-center gap-3 mb-1">
                        <div id="chart-ctrl-muerto-info" class="text-xs text-stone-600 grow"></div>
                        <div class="flex items-center gap-1">
                            <input id="rebase-muerto-indice" type="number" min="0" class="w-20 text-xs border rounded px-1 py-0.5" placeholder="# índice" />
                            <button id="btn-rebaseline-muerto" class="bg-blue-600 hover:bg-blue-700 text-white text-[11px] font-semibold px-2 py-1 rounded">Rebaseline</button>
                            <button id="btn-clear-rebaseline-muerto" class="bg-stone-500 hover:bg-stone-600 text-white text-[11px] font-semibold px-2 py-1 rounded" title="Eliminar rebaseline guardado">Reset</button>
                        </div>
                    </div>
                    <div id="segments-muerto" class="text-[10px] text-stone-600 mb-2 space-y-0.5"></div>
                </section>
                <section>
                    <div class="flex items-start justify-between gap-4">
                        <div>
                            <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Eventos fuera de control / señales</h3>
                            <div class="text-[11px] mb-2 text-stone-600 leading-tight">La línea verde es la media (CL) del segmento activo. <span class="text-emerald-700 font-semibold">Mantener puntos por debajo de la línea en % Muerto es una mejora</span>; las reglas priorizan alertas que indican desviaciones negativas o patrones estadísticos (run, tendencia, etc.). Cuando se observa una mejora sostenida puedes rebaselinar para fijar el nuevo estándar.</div>
                            <p class="chart-desc">Lista de señales detectadas (fuera de límites, run ≥7, 8 mismo lado, tendencia ≥6, 2 de 3 >2σ, 4 de 5 >1σ). Ayuda a priorizar investigación.</p>
                        </div>
                        <div class="shrink-0 mt-1">
                            <button id="btn-export-eventos-spc" class="bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-semibold px-3 py-1.5 rounded shadow-sm">Exportar (CSV)</button>
                        </div>
                    </div>
                    <div id="spc-top3" class="mt-2 hidden"></div>
                    <div id="spc-filtros" class="flex flex-wrap gap-2 mt-2 text-[11px]"></div>
                    <div id="spc-reglas-pesos" class="mt-2 text-[11px]"></div>
                    <div id="tabla-eventos-control" class="overflow-x-auto text-xs mt-1"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Detalle de puntos de control</h3>
                    <p class="chart-desc">Cada punto en los gráficos (orden cronológico) con identificación completa: fecha, amasadora y lote.</p>
                    <div id="tabla-detalle-control" class="overflow-x-auto text-xs"></div>
                </section>
            </div>
        </div>
    <div id="view-medicion" class="hidden">
                <div class="mb-8">
                    <h1 class="text-3xl font-extrabold text-stone-900 tracking-tight mb-2">Cálculo de Amasadoras</h1>
                    <p class="text-stone-600 text-sm md:text-base">Cómo operar el programa: registra primero las variables generales (fecha, TA, H, personal). Luego en cada tarjeta de amasadora define el tipo de masa y controla los tres procesos secuencialmente. Guarda cada máquina al terminar para formar un conjunto que luego podrás analizar y exportar.</p>
                </div>
                <!-- Instrucciones (migradas desde Resultados) -->
                <div id="instrucciones-medicion" class="mb-8">
                    <details open class="bg-white border border-stone-300 rounded-xl p-4 shadow-sm">
                        <summary class="cursor-pointer select-none font-semibold text-stone-800 text-lg flex items-center gap-2">
                            <span>Instrucciones (crear conjunto, analizar y exportar)</span>
                        </summary>
                        <div class="mt-3 space-y-3 text-sm leading-relaxed text-stone-700">
                            <p><span class="font-semibold">¿Qué es un conjunto?</span> Es un registro de una <strong>fecha</strong> con una o varias <strong>amasadoras</strong> y sus 3 procesos: <strong>Esponja</strong>, <strong>Masa</strong> y <strong>Mantequilla</strong> (tiempos reales, inicios, fines), más variables: <strong>Lote</strong>, <strong>Tipo de masa</strong>, <strong>Hielo</strong>, <strong>TM/TA/H</strong>, <strong>Personal</strong> y <strong>Observaciones</strong>.</p>
                            <ol class="list-decimal ml-5 space-y-1">
                                <li>Completa <strong>Fecha</strong>, <strong>TA</strong>, <strong>H</strong> y <strong>Personal (mín–máx)</strong>.</li>
                                <li>En cada amasadora define <strong>Tipo de masa</strong>, marca <strong>Hielo</strong> si aplica y al finalizar registra <strong>Temp. de masa</strong> y <strong>Observaciones</strong>.</li>
                                <li>Ejecuta los procesos en orden (Iniciar / Detener). Sólo puede estar activo uno por máquina; iniciar otro detiene el previo.</li>
                                <li>Se guardan inicio, fin y duración. El <strong>Total máquina</strong> va desde el inicio del primer proceso al fin del tercero. <strong>TM1 / TM2</strong> son los huecos entre procesos.</li>
                                <li>Pulsa <strong>Guardar resultados</strong> al terminar los 3 procesos de la máquina. Repite para otras.</li>
                                <li>Pasa a la pestaña <strong>Resultados</strong> para ver, filtrar y revisar. Desde <strong>Base de datos</strong> puedes: <em>Refrescar</em>, <em>Ver JSON</em> (abre un modal con Copiar), <em>Borrar</em> y ver <em>Detalles</em> por amasadora (TM1/TM2/Total real/Total procesos/Obs y tiempos por proceso).</li>
                                <li>En <strong>Resultados → Locales</strong> puedes enviar una tarjeta con <em>Enviar a BD</em> o toda la fecha con <em>Enviar todo a la BD</em>. Evitamos clics múltiples para no duplicar.</li>
                                <li>En <strong>Tablas</strong> elige la <em>Fuente</em>: <strong>Locales</strong> o <strong>Base de datos</strong> (con filtro por <em>Fecha</em>). Las tablas y gráficas se adaptan al origen.</li>
                                <li><strong>Borrar todo</strong> elimina definitivamente todos los registros guardados.</li>
                                <li><strong>Exportar PDF</strong>: reporte visual de la vista de resultados (sin botones).</li>
                                <li><strong>Exportar CSV</strong>: filas compactadas (una por proceso) con factores diarios y de máquina sólo en la primera fila de cada máquina. Incluye TM1, TM2, TM.Total y Total(s).</li>
                                <li>Si el total supera 45 min (>2700 s) aparece un ícono de advertencia.</li>
                            </ol>
                            <p class="text-stone-600">Consejo: Usa CSV para análisis (Excel / Power BI) y PDF para difusión rápida.</p>
                            <div class="pt-3 border-t border-stone-200"></div>
                            <h4 class="font-semibold text-stone-800">Mapeo de gráficas y propósito analítico</h4>
                            <ul class="list-disc ml-5 space-y-1">
                                <li><span class="font-medium">Punto de partida (1)</span>: Resumen de tiempos.</li>
                                <li><span class="font-medium">Benchmark entre recetas (2 y 5)</span>: Promedios por tipo de masa (tiempos) y Temperatura de masa por tipo.</li>
                                <li><span class="font-medium">Detecta dónde optimizar (3, 4 y 9)</span>: Promedios por amasadora, Promedios por proceso, Tiempos productivos vs muertos.</li>
                                <li><span class="font-medium">Control de consistencia (5, 6 y 8)</span>: Temperatura de masa (general), Temp. masa (Amasadora vs Tipo), Distribución por tipo (boxplot).</li>
                                <li><span class="font-medium">Contexto y factores (7 y 11)</span>: TA y Humedad por día, Personal por día (mín–máx).</li>
                                <li><span class="font-medium">Hipótesis de proceso (10)</span>: Relación temperatura de masa vs tiempo total (scatter).</li>
                            </ul>
                            <p class="text-xs text-stone-500">Tip: Usa BD como fuente para analizar históricos y evita perder datos al cambiar de dispositivo.</p>
                        </div>
                    </details>
                </div>
            <div class="mb-6 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-5">
                <div>
                    <label for="fecha" class="block mb-1 text-sm font-semibold text-stone-700">Fecha</label>
                    <input type="date" id="fecha" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" />
                </div>
                <div>
                    <label for="ta" class="block mb-1 text-sm font-semibold text-stone-700">Temp. ambiente (°C)</label>
                    <input type="number" id="ta" step="0.1" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="TA" />
                </div>
                <div>
                    <label for="h" class="block mb-1 text-sm font-semibold text-stone-700">Humedad (%)</label>
                    <input type="number" id="h" step="0.1" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="H" />
                </div>
                <div>
                    <label for="personal-min" class="block mb-1 text-sm font-semibold text-stone-700">Personal (mín)</label>
                    <input type="number" min="0" id="personal-min" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="Mínimo" />
                </div>
                <div>
                    <label for="personal-max" class="block mb-1 text-sm font-semibold text-stone-700">Personal (máx)</label>
                    <input type="number" min="0" id="personal-max" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="Máximo" />
                </div>
                
            </div>
            <main id="machine-cards" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-7 mb-10"></main>
            <div id="msg-guardar" class="mt-2 text-center text-sm"></div>
        </div>
                <!-- Cierre subview captura amasadoras -->
                        </div> <!-- end amas-sub-captura -->
                        <div id="amas-sub-resultados" class="amas-subview hidden">
                                <!-- Re-uso de vista resultados existente -->
                                <div id="amas-sub-resultados-wrapper"></div>
                        </div>
                        <div id="amas-sub-tablas" class="amas-subview hidden">
                                <div id="amas-sub-tablas-wrapper"></div>
                        </div>
                    </div>
                </div>
                <!-- Vista Mesa (nuevo proceso posterior a amasado) ahora con sidebar propio -->
                <div id="view-mesa" class="hidden">
                        <div class="grid grid-cols-12 gap-6 mb-6">
                            <aside class="col-span-12 md:col-span-2">
                                <nav id="mesa-sidebar" class="flex md:flex-col flex-wrap md:space-y-2 gap-2">
                                    <button data-mesa-sub="captura" class="tab-btn w-full tab-btn-active">Mesa</button>
                                    <button data-mesa-sub="resultados" class="tab-btn w-full">Resultados</button>
                                    <button data-mesa-sub="tablas" class="tab-btn w-full">Tablas</button>
                                    <button id="switch-to-amas" class="mt-2 tab-btn w-full bg-stone-100">← Amasadoras</button>
                                </nav>
                            </aside>
                            <div class="col-span-12 md:col-span-10" id="mesa-content-wrapper">
                                <div id="mesa-sub-captura" class="mesa-subview">
            <div class="mb-8">
                <h1 class="text-3xl font-extrabold text-stone-900 tracking-tight mb-2">Proceso en Mesa (Lote)</h1>
                <p class="text-stone-600 text-sm md:text-base">Cronometra el tiempo desde que la masa sale de las amasadoras, se pesa / porciona, pasa por la sobadora (si aplica) y se coloca en bandejas hasta montarse en el carrito (fin del lote antes de fermentación).</p>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-5 mb-6">
                <div>
                    <label class="block mb-1 text-sm font-semibold text-stone-700">Fecha</label>
                    <input type="date" id="mesa-fecha" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" />
                </div>
                <div>
                    <label class="block mb-1 text-sm font-semibold text-stone-700">Lote</label>
                    <input type="text" id="mesa-lote" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="Ej: 12" />
                </div>
                <div>
                    <label class="block mb-1 text-sm font-semibold text-stone-700">Tipo de masa</label>
                    <select id="mesa-tipo-masa" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                        <option value="">--</option>
                        <option value="Tradicional">Tradicional</option>
                        <option value="Brioche">Brioche</option>
                        <option value="Mant.">Mant.</option>
                        <option value="__OTRO__">Otro...</option>
                    </select>
                </div>
                <div>
                    <label class="block mb-1 text-sm font-semibold text-stone-700">Tipo de pan (Libre)</label>
                    <input list="lista-tipo-pan" type="text" id="mesa-tipo-pan" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="Ej: PDJ" disabled />
                </div>
                <div>
                    <label class="block mb-1 text-sm font-semibold text-stone-700">Personal (mín)</label>
                    <input type="number" min="0" id="mesa-per-min" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" />
                </div>
                <div>
                    <label class="block mb-1 text-sm font-semibold text-stone-700">Personal (máx)</label>
                    <input type="number" min="0" id="mesa-per-max" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" />
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div class="p-5 rounded-2xl bg-white border border-stone-200 shadow-sm">
                    <h3 class="font-semibold text-stone-800 mb-2">Cronómetro del lote</h3>
                    <div class="text-4xl font-mono font-bold text-stone-900 mb-4" id="mesa-tiempo-display">00:00:00</div>
                    <div class="flex flex-wrap gap-3 mb-4">
                        <button id="mesa-start" class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded font-semibold">Iniciar</button>
                        <button id="mesa-stop" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-semibold" disabled>Detener</button>
                        <button id="mesa-reset" class="bg-stone-500 hover:bg-stone-600 text-white px-4 py-2 rounded font-semibold" disabled>Reset</button>
                    </div>
                    <p class="text-xs text-stone-600 leading-snug">Inicia cuando la masa sale de la amasadora. Detén al terminar de bandejear y montar el carrito para fermentación.</p>
                </div>
                <div class="md:col-span-2 p-5 rounded-2xl bg-white border border-stone-200 shadow-sm flex flex-col">
                    <label class="font-semibold text-stone-800 mb-2">Observaciones</label>
                    <textarea id="mesa-obs" rows="5" class="w-full flex-1 px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y" placeholder="Variaciones, retrasos, ajustes..."></textarea>
                    <div class="mt-4 flex gap-3">
                        <button id="mesa-guardar" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded font-semibold grow">Guardar lote</button>
                        <button id="mesa-limpiar" class="bg-stone-400 hover:bg-stone-500 text-white px-5 py-2 rounded font-semibold">Limpiar</button>
                    </div>
                    <div id="mesa-msg" class="mt-2 text-sm"></div>
                </div>
            </div>
            <div class="mb-4 flex flex-wrap gap-3 justify-end">
                <button id="mesa-export" class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded font-semibold text-sm">Exportar (CSV)</button>
                <button id="mesa-borrar-todo" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-semibold text-sm">Borrar todo</button>
            </div>
            <div id="mesa-lista" class="space-y-3"></div>
                </div> <!-- end mesa-sub-captura -->
                <div id="mesa-sub-resultados" class="mesa-subview hidden">
                    <div id="mesa-resultados-wrapper" class="space-y-6">
                        <div class="mb-2 flex flex-wrap justify-center gap-3">
                            <button id="mesa-res-sub-local" class="tab-btn tab-btn-active">Locales</button>
                            <button id="mesa-res-sub-bd" class="tab-btn">Base de datos</button>
                        </div>
                        <div id="mesa-local-controls" class="flex flex-wrap gap-3 justify-center items-end text-xs md:text-sm">
                            <input id="mesa-filtro-fecha" type="date" class="border rounded px-2 py-1" />
                            <input id="mesa-filtro-tipo" placeholder="Tipo masa" class="border rounded px-2 py-1 w-32" />
                            <input id="mesa-filtro-pan" placeholder="Tipo pan" class="border rounded px-2 py-1 w-32" />
                            <button id="mesa-enviar-todo-bd" class="bg-amber-600 hover:bg-amber-700 text-white font-semibold px-3 py-1.5 rounded">Enviar fecha a BD</button>
                            <button id="mesa-borrar-locales" class="bg-red-600 hover:bg-red-700 text-white font-semibold px-3 py-1.5 rounded">Borrar locales</button>
                            <button id="mesa-export-local-csv" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold px-3 py-1.5 rounded">Exportar CSV</button>
                        </div>
                        <div id="mesa-bd-controls" class="hidden flex flex-wrap gap-3 justify-center items-end text-xs md:text-sm">
                            <input id="mesa-bd-desde" type="date" class="border rounded px-2 py-1" />
                            <input id="mesa-bd-hasta" type="date" class="border rounded px-2 py-1" />
                            <input id="mesa-bd-fecha" type="date" class="border rounded px-2 py-1" />
                            <input id="mesa-bd-tipo" placeholder="Tipo masa" class="border rounded px-2 py-1 w-32" />
                            <input id="mesa-bd-pan" placeholder="Tipo pan" class="border rounded px-2 py-1 w-32" />
                            <button id="mesa-bd-refresh" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-3 py-1.5 rounded">Refrescar</button>
                            <button id="mesa-bd-clear-filtros" class="text-stone-600 underline">Limpiar filtros</button>
                            <button id="mesa-bd-export-csv" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold px-3 py-1.5 rounded">Exportar CSV</button>
                        </div>
                        <div id="mesa-status" class="text-center text-xs text-stone-600"></div>
                        <div id="mesa-promedios" class="text-center text-sm text-stone-700"></div>
                        <div id="mesa-resultados-lista" class="space-y-4"></div>
                    </div>
                </div>
                <div id="mesa-sub-tablas" class="mesa-subview hidden">
                    <div id="mesa-tablas-wrapper" class="space-y-10 pb-10">
                        <div class="flex flex-wrap gap-3 justify-center mb-4 text-xs md:text-sm">
                            <label class="flex items-center gap-1">Fuente:
                                <select id="mesa-tablas-fuente" class="border rounded px-2 py-1 text-xs">
                                    <option value="local">Locales</option>
                                    <option value="bd">Base de datos</option>
                                </select>
                            </label>
                            <div id="mesa-tablas-filtros-bd" class="hidden flex flex-wrap gap-2 items-center">
                                <label class="text-xs">Desde:<input id="mesa-tablas-desde" type="date" class="border rounded px-1 py-0.5 ml-1" /></label>
                                <label class="text-xs">Hasta:<input id="mesa-tablas-hasta" type="date" class="border rounded px-1 py-0.5 ml-1" /></label>
                                <input id="mesa-tablas-tipo" placeholder="Tipo masa" class="border rounded px-2 py-0.5 text-xs w-28" />
                                <input id="mesa-tablas-pan" placeholder="Tipo pan" class="border rounded px-2 py-0.5 text-xs w-28" />
                                <button id="mesa-tablas-refresh" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-3 py-1 rounded text-xs">Refrescar</button>
                                <button id="mesa-tablas-clear" class="text-xs text-stone-600 underline">Limpiar</button>
                            </div>
                            <span class="mx-1 text-stone-300">|</span>
                            <button id="mesa-tablas-export-csv" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold px-3 py-1 rounded text-xs">Exportar CSV</button>
                        </div>
                        <div id="mesa-tablas-status" class="text-center text-xs text-stone-600"></div>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Resumen</h3>
                            <div id="mesa-tabla-resumen" class="overflow-x-auto text-xs"></div>
                        </section>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Promedios por tipo de masa</h3>
                            <div id="mesa-tabla-tipo-masa" class="overflow-x-auto text-xs"></div>
                            <canvas id="mesa-chart-tipo-masa" height="130"></canvas>
                        </section>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Promedios por tipo de pan (Tradicional)</h3>
                            <div id="mesa-tabla-tipo-pan" class="overflow-x-auto text-xs"></div>
                            <canvas id="mesa-chart-tipo-pan" height="130"></canvas>
                        </section>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Boxplot por tipo de masa</h3>
                            <canvas id="mesa-chart-boxplot" height="220"></canvas>
                            <div id="mesa-boxplot-stats" class="overflow-x-auto text-xs mt-2"></div>
                        </section>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Histograma de duración (s)</h3>
                            <canvas id="mesa-chart-hist" height="160"></canvas>
                        </section>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Tendencia semanal (promedio duración)</h3>
                            <canvas id="mesa-chart-semanal" height="140"></canvas>
                        </section>
                        <section>
                            <h3 class="text-lg font-bold text-stone-800 mb-1">Personal midpoint vs duración</h3>
                            <canvas id="mesa-chart-scatter-personal" height="160"></canvas>
                        </section>
                    </div>
                </div>
              </div>
            </div>
        </div>

        <!-- Vista de resultados (única) -->
        <div id="view-resultados" class="hidden">
                <div class="mb-4 flex flex-wrap gap-3 justify-end">
                    <button id="btn-export-resultados-pdf" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow hover:bg-blue-700 transition-colors">Exportar Resultados de Amasadoras (PDF)</button>
                    <button id="btn-export-resultados-csv" class="bg-emerald-600 text-white px-4 py-2 rounded-lg font-semibold shadow hover:bg-emerald-700 transition-colors">Exportar Resultados de Amasadoras (CSV)</button>
                </div>
                <!-- Subpestañas: Locales | Base de datos -->
                <div class="flex justify-center gap-2 mb-4">
                    <button id="subtab-local" class="tab-btn tab-btn-active">Locales</button>
                    <button id="subtab-bd" class="tab-btn">Base de datos</button>
                </div>
                <!-- Subvista: Resultados locales -->
                <div id="resultados-local-wrapper">
                    <!-- Filtros para resultados locales -->
                    <div class="flex flex-wrap gap-4 justify-center mb-3">
                        <input id="filtro-fecha" type="date" class="border rounded px-3 py-1" placeholder="Filtrar por fecha" />
                        <input id="filtro-tipo" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por tipo de masa" />
                        <input id="filtro-maquina" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por amasadora" />
                        <button id="btn-enviar-todo-bd" class="bg-amber-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-amber-700" title="Enviar todos los resultados locales a la BD">Enviar todo a la BD</button>
                        <button id="btn-clear-resultados" class="bg-red-500 text-white px-3 py-1 rounded">Borrar todo</button>
                    </div>
                    <div id="local-bd-status" class="text-xs text-stone-600 mt-1 text-center"></div>
                    <div id="promedios" class="text-sm text-stone-600 text-center mb-4"></div>
                    <div id="resultados-lista"></div>
                </div>
                <!-- Subvista: Base de datos remota -->
                <div id="bd-wrapper" class="hidden">
        <div class="flex flex-wrap gap-2 justify-center items-center mb-2">
            <input id="bd-filtro-fecha" type="date" class="border rounded px-3 py-1" placeholder="Filtrar por fecha" />
            <input id="bd-filtro-tipo" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por tipo de masa" />
            <input id="bd-filtro-maquina" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por amasadora" />
            <button id="bd-refresh" class="bg-indigo-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-indigo-700">Refrescar</button>
            <button id="bd-delete-all" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-red-700" title="Borrar todos los registros en la BD (si la API lo permite)">Borrar todo BD</button>
                    <button id="bd-select-mode" class="bg-stone-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-stone-700" title="Seleccionar múltiples para borrar">Seleccionar</button>
                    <button id="bd-delete-selected" class="hidden bg-red-700 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-red-800" title="Eliminar seleccionados">Eliminar seleccionados (<span id="bd-selected-count">0</span>)</button>
        </div>
                    <div id="sync-status" class="text-xs text-stone-600 mt-1 text-center"></div>
                    <div id="bd-lista" class="max-w-4xl mx-auto mt-3"></div>
                </div>
            </div>
        </div>
    </div>
</body>
<!-- JSON Modal for viewing record details -->
<div id="json-modal" class="hidden fixed inset-0 bg-black/40 items-center justify-center p-4 z-50">
    <div class="bg-white rounded-xl shadow-xl w-full max-w-3xl max-h-[80vh] flex flex-col">
        <div class="px-4 py-2 border-b border-stone-200 flex items-center justify-between">
            <h3 class="font-semibold text-stone-800">Vista JSON del registro</h3>
            <div class="flex gap-2">
                <button id="json-modal-copy" class="bg-stone-700 text-white text-xs px-2 py-1 rounded">Copiar JSON</button>
                <button id="json-modal-close" class="bg-stone-500 text-white text-xs px-2 py-1 rounded">Cerrar</button>
            </div>
        </div>
        <pre id="json-modal-content" class="flex-1 overflow-auto text-xs p-4 bg-stone-50 text-stone-800"></pre>
    </div>
  
</div>
<script>
// Cargar libs si faltan
window.html2canvas || document.write('<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"><\/script>');
window.jspdf || document.write('<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"><\/script>');
// CDN Chart.js
window.Chart || document.write('<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"><\/script>');
// Ocultar/mostrar tarjeta de Ajustes (persistente)
document.addEventListener('DOMContentLoaded', () => {
    const toggleBtn = document.getElementById('toggle-ajustes');
    const ajustesContent = document.getElementById('ajustes-content');
    if (!toggleBtn || !ajustesContent) return;
    // Leer preferencia
    const saved = localStorage.getItem('ajustesVisible');
    let visible = saved === '1';
    if (saved === null) visible = false; // por defecto oculto
    ajustesContent.classList.toggle('hidden', !visible);
    toggleBtn.textContent = visible ? 'Ocultar ajustes' : 'Mostrar ajustes';
    toggleBtn.addEventListener('click', () => {
        visible = !visible;
        ajustesContent.classList.toggle('hidden', !visible);
        toggleBtn.textContent = visible ? 'Ocultar ajustes' : 'Mostrar ajustes';
        localStorage.setItem('ajustesVisible', visible ? '1' : '0');
    });
});
// ======================= GLOBAL VARIABLES AND DATA =======================
    // Datos de amasadoras
    const machineData = [
        {
            id: '3',
            name: 'Amasadora 3',
            processes: [
                { id: '1', name: 'Esponja' },
                { id: '2', name: 'Masa' },
                { id: '3', name: 'Mantequilla' }
            ]
        },
        {
            id: '1',
            name: 'Amasadora 1',
            processes: [
                { id: '1', name: 'Esponja' },
                { id: '2', name: 'Masa' },
                { id: '3', name: 'Mantequilla' }
            ]
        },
        {
            id: '2',
            name: 'Amasadora 2',
            processes: [
                { id: '1', name: 'Esponja' },
                { id: '2', name: 'Masa' },
                { id: '3', name: 'Mantequilla' }
            ]
        }
    ];

    // Migración puntual: renombrar tipoMasa 'Bs.' a 'Mant.' en datos previos almacenados
    (function setupTipoMasaMigration(){
        function normalizeTipoMasaRegistro(reg){
            if(!reg) return;
            if(reg.tipoMasa === 'Bs.') reg.tipoMasa = 'Mant.';
        }
        function normalizeConjunto(conj){
            if(conj && Array.isArray(conj.maquinas)) conj.maquinas.forEach(normalizeTipoMasaRegistro);
        }
        // LocalStorage: resultadosMezclado
        try {
            let changed=false;
            const raw = localStorage.getItem('resultadosMezclado');
            if(raw){
                const arr = JSON.parse(raw);
                if(Array.isArray(arr)){
                    arr.forEach(c=>{const prev=JSON.stringify(c.maquinas); normalizeConjunto(c); if(JSON.stringify(c.maquinas)!==prev) changed=true;});
                    if(changed) localStorage.setItem('resultadosMezclado', JSON.stringify(arr));
                }
            }
        } catch(_){ }
        // LocalStorage: tempAmasadoras
        try {
            let changed=false;
            const rawTemp = localStorage.getItem('tempAmasadoras');
            if(rawTemp){
                const obj = JSON.parse(rawTemp);
                if(obj && typeof obj==='object'){
                    Object.keys(obj).forEach(k=>{const r=obj[k]; const before=r&&r.tipoMasa; normalizeTipoMasaRegistro(r); if(before!==r.tipoMasa) changed=true;});
                    if(changed) localStorage.setItem('tempAmasadoras', JSON.stringify(obj));
                }
            }
        } catch(_){ }
        // Exponer para reutilizar en datos remotos
        window.__normalizeTipoMasaMant = function(dataset){
            if(Array.isArray(dataset)) dataset.forEach(normalizeConjunto);
            return dataset;
        };
    })();

    let machineCardsContainer = document.getElementById('machine-cards');
    function initMachineCardsIfNeeded(){
        if(!machineCardsContainer){ machineCardsContainer = document.getElementById('machine-cards'); }
        if(machineCardsContainer && !machineCardsContainer.getAttribute('data-rendered')){
            try { createMachineCards(); machineCardsContainer.setAttribute('data-rendered','1'); } catch(_){ }
        }
    }
    let timers = {};
    let machineTotals = {};
    let completedProcessTimes = {};

    function formatTime(seconds) {
        if (isNaN(seconds) || seconds === null) return '00:00:00';
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function createMachineCards() {
    // Restaurar datos temporales si existen
    let tempData = {};
    try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
    machineCardsContainer.innerHTML = '';
    // Ensure datalist for tipoPan suggestions exists
    if(!document.getElementById('lista-tipo-pan')){
        const dl=document.createElement('datalist'); dl.id='lista-tipo-pan'; document.body.appendChild(dl);
    }
        let sortedMachines = [...machineData];
        const ordenIds = ['3', '1', '2'];
        sortedMachines.sort((a, b) => ordenIds.indexOf(a.id) - ordenIds.indexOf(b.id));
        sortedMachines.forEach(machine => {
            const temp = tempData[machine.id] || {};
            // Calcular el total restando el inicio del primer proceso y el fin del último proceso
            let primerStart = completedProcessTimes[`m${machine.id}-p1`]?.startTime || null;
            let ultimoEnd = completedProcessTimes[`m${machine.id}-p3`]?.endTime || null;
            let totalTime = null;
            if (primerStart && ultimoEnd) {
                totalTime = Math.max(0, Math.floor((ultimoEnd - primerStart)/1000));
            }
            // Calcular tiempos muertos
            let t1End = completedProcessTimes[`m${machine.id}-p1`]?.endTime || null;
            let t2Start = completedProcessTimes[`m${machine.id}-p2`]?.startTime || null;
            let t2End = completedProcessTimes[`m${machine.id}-p2`]?.endTime || null;
            let t3Start = completedProcessTimes[`m${machine.id}-p3`]?.startTime || null;
            let tiempoMuerto1 = (t1End && t2Start) ? Math.max(0, Math.floor((t2Start - t1End)/1000)) : null;
            let tiempoMuerto2 = (t2End && t3Start) ? Math.max(0, Math.floor((t3Start - t2End)/1000)) : null;
            let sumaMuertos = (tiempoMuerto1 || 0) + (tiempoMuerto2 || 0);
            const isOverThreshold = totalTime !== null && totalTime > 2700;
            const totalColorClass = isOverThreshold ? 'text-red-600' : 'text-stone-800';
            let processesHtml = '';
            machine.processes.forEach(process => {
                const timerId = `m${machine.id}-p${process.id}`;
                const processTime = completedProcessTimes[timerId] || { time: 0, startTime: null, endTime: null };
                const isRunning = timers[timerId] !== undefined;
                processesHtml += `
                    <div class="p-4 bg-stone-50 rounded-lg border border-stone-200">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold text-stone-800">${process.name}</h4>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-sm mb-4">
                            <div class="text-stone-600">Inicio: <span id="start-${timerId}" class="font-mono font-medium text-stone-800">${processTime.startTime ? new Date(processTime.startTime).toLocaleTimeString() : '--:--:--'}</span></div>
                            <div class="text-stone-600">Fin: <span id="end-${timerId}" class="font-mono font-medium text-stone-800">${processTime.endTime ? new Date(processTime.endTime).toLocaleTimeString() : '--:--:--'}</span></div>
                            <div class="text-stone-600 col-span-2">T. Real: <span id="real-${timerId}" class="font-mono font-medium text-stone-800">${formatTime(processTime.time)}</span></div>
                        </div>
                        <div class="grid grid-cols-3 gap-2">
                            <button data-action="start" data-timer-id="${timerId}" class="col-span-1 text-sm bg-emerald-500 text-white py-2 px-3 rounded-md hover:bg-emerald-600 transition-colors ${isRunning ? 'disabled:bg-stone-300' : ''}" ${isRunning ? 'disabled' : ''}>Iniciar</button>
                            <button data-action="stop" data-timer-id="${timerId}" class="col-span-1 text-sm bg-red-500 text-white py-2 px-3 rounded-md hover:bg-red-600 transition-colors ${!isRunning ? 'disabled:bg-stone-300' : ''}" ${!isRunning ? 'disabled' : ''}>Detener</button>
                            <button data-action="reset" data-timer-id="${timerId}" class="col-span-1 text-sm bg-stone-500 text-white py-2 px-3 rounded-md hover:bg-stone-600 transition-colors">Reset</button>
                        </div>
                    </div>
                `;
            });
            const cardHtml = `
                <div class="relative bg-white p-6 rounded-2xl shadow-sm border border-stone-200 flex flex-col hover:shadow-md transition-shadow">
                    <h3 class="text-xl font-bold mb-4 text-stone-900 tracking-tight">${machine.name}</h3>
                    <div class="mb-4 flex flex-col items-center">
                        <label for="lote-${machine.id}" class="block mb-2 text-base font-semibold text-stone-800">Lote:</label>
                        <input type="text" id="lote-${machine.id}" class="mb-4 px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48" placeholder="Ingrese el número de lote" value="${temp.lote||''}" />
                        <label for="tipoMasa-${machine.id}" class="block mb-2 text-base font-semibold text-stone-800">Tipo de masa:</label>
                        <select id="tipoMasa-${machine.id}" data-machine="${machine.id}" class="px-4 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48 tipo-masa-select">
                            <option value="">-- Seleccionar --</option>
                            <option value="Tradicional" ${temp.tipoMasa==='Tradicional'?'selected':''}>Tradicional</option>
                            <option value="Brioche" ${temp.tipoMasa==='Brioche'?'selected':''}>Brioche</option>
                            <option value="Mant." ${temp.tipoMasa==='Mant.'?'selected':''}>Mant.</option>
                            <option value="__OTRO__" ${temp.tipoMasa==='__OTRO__'?'selected':''}>Otro...</option>
                        </select>
                        <input type="text" id="tipoMasaOtro-${machine.id}" placeholder="Especificar otro" class="mt-2 px-3 py-2 rounded-lg border border-dashed border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48 tipo-masa-otro${temp.tipoMasa==='__OTRO__'?'':' hidden'}" value="${temp.tipoMasaOtro||''}" />
                        <label for="tipoPan-${machine.id}" class="block mb-2 mt-6 text-base font-semibold text-stone-800">Tipo de pan (Libre):</label>
                        <input list="lista-tipo-pan" type="text" id="tipoPan-${machine.id}" placeholder="Ej: Hamburguesa" class="mt-0 px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48 ${temp.tipoMasa==='Tradicional'?'':'opacity-60'} tipo-pan-input" ${temp.tipoMasa==='Tradicional'?'':'disabled'} value="${temp.tipoPan||''}" data-machine="${machine.id}" />
                        <div class="flex items-center gap-4 mt-4 mb-2">
                            <span class="text-base font-semibold text-stone-800">Hielo:</span>
                            <label class="inline-flex items-center">
                                <input type="radio" name="hielo-${machine.id}" id="hielo-si-${machine.id}" value="Si" class="form-radio text-blue-600" ${temp.hielo==='Si'?'checked':''} />
                                <span class="ml-2">Si</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="hielo-${machine.id}" id="hielo-no-${machine.id}" value="No" class="form-radio text-blue-600" ${temp.hielo==='No'?'checked':''} />
                                <span class="ml-2">No</span>
                            </label>
                        </div>
                        <div class="flex flex-col items-center mt-2 w-48">
                            <!-- Campo de personal eliminado, ahora está arriba -->
                        </div>
                    </div>
                    <div class="space-y-4 mb-4">
                        ${processesHtml}
                    </div>
                    <div class="mb-4 p-3 rounded-xl bg-gradient-to-br from-blue-50 to-stone-50 border border-blue-200/70 text-blue-900 text-xs flex flex-col gap-1 shadow-inner">
                        <div class="flex justify-between"><span class="font-semibold">T. Muerto 1</span><span id="tm1-${machine.id}" class="font-mono">${tiempoMuerto1 !== null ? formatTime(tiempoMuerto1) : '--:--:--'}</span></div>
                        <div class="flex justify-between"><span class="font-semibold">T. Muerto 2</span><span id="tm2-${machine.id}" class="font-mono">${tiempoMuerto2 !== null ? formatTime(tiempoMuerto2) : '--:--:--'}</span></div>
                        <div class="flex justify-between"><span class="font-semibold">Muertos Total</span><span id="tmT-${machine.id}" class="font-mono">${(tiempoMuerto1 !== null || tiempoMuerto2 !== null) ? formatTime(sumaMuertos) : '--:--:--'}</span></div>
                        <div class="flex justify-between text-blue-700 font-bold"><span>Total máquina</span><span id="ttot-${machine.id}" class="font-mono">${totalTime !== null ? formatTime(totalTime) : '--:--:--'}</span></div>
                    </div>
                    <div class="flex flex-col gap-2 mb-4 w-48 mx-auto">
                        <label class="text-base font-semibold text-stone-800">Temperatura de la masa (C):</label>
                        <input type="number" step="0.1" id="tempMasa-${machine.id}" class="px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500" value="${temp.tempMasa||''}" />
                    </div>
                    <div class="mb-4">
                        <label for="obs-${machine.id}" class="block mb-2 text-base font-semibold text-stone-800">Observaciones:</label>
                        <textarea id="obs-${machine.id}" rows="2" class="w-full px-3 py-2 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y">${temp.observaciones||''}</textarea>
                    </div>
                                        <div class="text-center mt-auto pt-4 border-t border-stone-200">
                                                <p class="text-base font-bold text-stone-900">Total amasadora: <span id="total-m${machine.id}" class="${totalColorClass} font-mono text-lg">${totalTime !== null ? formatTime(totalTime) : '--:--:--'}</span></p>
                                                <div class="flex flex-col gap-2 mt-3">
                                                    <button class="guardar-maquina bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors font-semibold shadow-sm" data-machine-id="${machine.id}">Guardar resultados</button>
                                                    <button class="clear-maquina bg-stone-400 text-white px-4 py-2 rounded-lg hover:bg-stone-500 transition-colors font-semibold" data-machine-id="${machine.id}">Limpiar</button>
                                                </div>
                        <div id="msg-guardar-${machine.id}" class="mt-2 text-center"></div>
                            </div>
                        </div>
            `;
            machineCardsContainer.innerHTML += cardHtml;
    });
    }
    // Actualizar dinámicamente los tiempos muertos y total al detener procesos
    function updateMuertosYTotal(machineId) {
        let t1End = completedProcessTimes[`m${machineId}-p1`]?.endTime || null;
        let t2Start = completedProcessTimes[`m${machineId}-p2`]?.startTime || null;
        let t2End = completedProcessTimes[`m${machineId}-p2`]?.endTime || null;
        let t3Start = completedProcessTimes[`m${machineId}-p3`]?.startTime || null;
        let primerStart = completedProcessTimes[`m${machineId}-p1`]?.startTime || null;
        let ultimoEnd = completedProcessTimes[`m${machineId}-p3`]?.endTime || null;
        let tiempoMuerto1 = (t1End && t2Start) ? Math.max(0, Math.floor((t2Start - t1End)/1000)) : null;
        let tiempoMuerto2 = (t2End && t3Start) ? Math.max(0, Math.floor((t3Start - t2End)/1000)) : null;
        let sumaMuertos = (tiempoMuerto1 || 0) + (tiempoMuerto2 || 0);
        let totalTime = (primerStart && ultimoEnd) ? Math.max(0, Math.floor((ultimoEnd - primerStart)/1000)) : null;
        if(document.getElementById(`tm1-${machineId}`)) document.getElementById(`tm1-${machineId}`).textContent = tiempoMuerto1 !== null ? formatTime(tiempoMuerto1) : '--:--:--';
        if(document.getElementById(`tm2-${machineId}`)) document.getElementById(`tm2-${machineId}`).textContent = tiempoMuerto2 !== null ? formatTime(tiempoMuerto2) : '--:--:--';
        if(document.getElementById(`tmT-${machineId}`)) document.getElementById(`tmT-${machineId}`).textContent = (tiempoMuerto1 !== null || tiempoMuerto2 !== null) ? formatTime(sumaMuertos) : '--:--:--';
        if(document.getElementById(`ttot-${machineId}`)) document.getElementById(`ttot-${machineId}`).textContent = totalTime !== null ? formatTime(totalTime) : '--:--:--';
    }

    // Evento para botón Clear de cada amasadora
    if(machineCardsContainer) machineCardsContainer.addEventListener('click', function(e) {
        const btn = e.target.closest('.clear-maquina');
        if (!btn) return;
        const machineId = btn.getAttribute('data-machine-id');
        if (!machineId) return;
        // Limpiar campos de la tarjeta
    const tipoMasaSelect = document.getElementById(`tipoMasa-${machineId}`); if(tipoMasaSelect) tipoMasaSelect.value = '';
    const tipoMasaOtro = document.getElementById(`tipoMasaOtro-${machineId}`); if(tipoMasaOtro){ tipoMasaOtro.value=''; tipoMasaOtro.classList.add('hidden'); }
        document.getElementById(`tempMasa-${machineId}`).value = '';
        document.getElementById(`obs-${machineId}`).value = '';
        if (document.getElementById(`hielo-si-${machineId}`)) document.getElementById(`hielo-si-${machineId}`).checked = false;
        if (document.getElementById(`hielo-no-${machineId}`)) document.getElementById(`hielo-no-${machineId}`).checked = false;
        // Limpiar tiempos de procesos
        for (let i = 1; i <= 3; i++) {
            const timerId = `m${machineId}-p${i}`;
            if (timers[timerId] && timers[timerId].interval) {
                clearInterval(timers[timerId].interval);
                delete timers[timerId];
            }
            delete completedProcessTimes[timerId];
            document.getElementById(`start-${timerId}`).textContent = '--:--:--';
            document.getElementById(`end-${timerId}`).textContent = '--:--:--';
            document.getElementById(`real-${timerId}`).textContent = '00:00:00';
            document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = false;
            document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = true;
    }
        // Resetear total
        const totalSpan = document.getElementById(`total-m${machineId}`);
        if (totalSpan) {
            totalSpan.textContent = '00:00:00';
            totalSpan.classList.remove('text-red-600');
            totalSpan.classList.add('text-stone-800');
        }
    });

    function updateTimerDisplay(timerId) {
        const realTimeEl = document.getElementById(`real-${timerId}`);
        if (timers[timerId] && timers[timerId].interval) {
            const elapsedCurrent = Math.floor((Date.now() - timers[timerId].startTime) / 1000);
            const baseElapsed = timers[timerId].baseElapsed || 0;
            realTimeEl.textContent = formatTime(baseElapsed + elapsedCurrent);
        }
    }

    function stopProcess(timerId, skipTotalUpdate = false) {
        if (!timers[timerId] || !timers[timerId].interval) return;

        clearInterval(timers[timerId].interval);

    const endTime = Date.now();
    const startTimeRun = timers[timerId].startTime;
    const runSeconds = Math.floor((endTime - startTimeRun) / 1000);
    const baseElapsed = timers[timerId].baseElapsed || 0;
    const realTimeSeconds = baseElapsed + runSeconds;

        const startEl = document.getElementById(`start-${timerId}`);
        const endEl = document.getElementById(`end-${timerId}`);
        const realEl = document.getElementById(`real-${timerId}`);

        endEl.textContent = new Date(endTime).toLocaleTimeString();
    realEl.textContent = formatTime(realTimeSeconds);

        const [machineId, processId] = timerId.replace('m', '').replace('p', '').split('-');

        if (!skipTotalUpdate) {
            const prevTime = (completedProcessTimes[timerId] && typeof completedProcessTimes[timerId].time === 'number' ? completedProcessTimes[timerId].time : 0);
            if (!machineTotals[machineId]) {
                machineTotals[machineId] = 0;
            }
            machineTotals[machineId] = machineTotals[machineId] - prevTime + realTimeSeconds;
            const firstStart = completedProcessTimes[timerId]?.firstStartTime || startTimeRun;
            completedProcessTimes[timerId] = { time: realTimeSeconds, startTime: firstStart, firstStartTime: firstStart, endTime: endTime };
            // Actualizar solo el total de la máquina en el DOM (solo suma los tiempos detenidos)
            let totalTime = 0;
            for (let i = 1; i <= 3; i++) {
                const tId = `m${machineId}-p${i}`;
                const t = completedProcessTimes[tId];
                if (t && typeof t.time === 'number' && !isNaN(t.time)) {
                    totalTime += t.time;
                }
            }
            // Actualizar el span del total de la máquina usando el id único
            const totalSpan = document.getElementById(`total-m${machineId}`);
            if (totalSpan) {
                totalSpan.textContent = formatTime(totalTime);
                if (totalTime > 2700) {
                    totalSpan.classList.add('text-red-600');
                    totalSpan.classList.remove('text-stone-800');
                } else {
                    totalSpan.classList.remove('text-red-600');
                    totalSpan.classList.add('text-stone-800');
                }
            }
            // Actualizar tiempos muertos y total dinámicamente
            updateMuertosYTotal(machineId);
        }

        delete timers[timerId];
        document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = false;
        document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = true;
    }

    function handleButtonClick(e) {
        const target = e.target.closest('button');
        if (!target) return;

        const { action, timerId } = target.dataset;
        if (!action || !timerId) return;

        const [machineId, processId] = timerId.replace('m', '').replace('p', '').split('-');

        if (action === 'start') {
            // Detener y guardar cualquier proceso corriendo en la misma máquina
            machineData.find(m => m.id === machineId).processes.forEach(process => {
                const existingTimerId = `m${machineId}-p${process.id}`;
                if (existingTimerId !== timerId && timers[existingTimerId]) {
                    stopProcess(existingTimerId, false); // Guardar el tiempo
                }
            });

            if (timers[timerId] && timers[timerId].interval) return;
            const prev = completedProcessTimes[timerId];
            const now = Date.now();
            const baseElapsed = prev && typeof prev.time === 'number' ? prev.time : 0;
            timers[timerId] = {
                startTime: now,
                baseElapsed,
                interval: setInterval(() => updateTimerDisplay(timerId), 1000)
            };
            if(!prev || !prev.firstStartTime){
                completedProcessTimes[timerId] = { ...(prev||{}), firstStartTime: now, startTime: now, endTime: null, time: baseElapsed };
            }
            const startEl = document.getElementById(`start-${timerId}`);
            if(startEl){
                if(prev && prev.firstStartTime){
                    startEl.textContent = new Date(prev.firstStartTime).toLocaleTimeString();
                } else {
                    startEl.textContent = new Date(now).toLocaleTimeString();
                }
            }
            document.getElementById(`end-${timerId}`).textContent = '--:--:--';
            const realEl = document.getElementById(`real-${timerId}`);
            if(realEl) realEl.textContent = formatTime(baseElapsed);
            document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = true;
            document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = false;
        } else if (action === 'stop') {
            stopProcess(timerId);
        } else if (action === 'reset') {
            if (timers[timerId] && timers[timerId].interval) {
                clearInterval(timers[timerId].interval);
                delete timers[timerId];
            }
            completedProcessTimes[timerId] = { time: 0, startTime: null, firstStartTime: null, endTime: null };
            document.getElementById(`start-${timerId}`).textContent = '--:--:--';
            document.getElementById(`end-${timerId}`).textContent = '--:--:--';
            document.getElementById(`real-${timerId}`).textContent = '00:00:00';
            document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = false;
            document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = true;
        }
    }

    // Delegación global de botones de procesos
    document.addEventListener('click', function(e){
        if (e.target.closest('button[data-action]')) {
            handleButtonClick(e);
        }
    });

    // Cambio de tipo de masa / pan para mostrar campo "Otro"
    document.addEventListener('change', function(e){
        const masaSel = e.target.closest('select.tipo-masa-select');
        if(masaSel){
            const machineId = masaSel.getAttribute('data-machine');
            if(machineId){
                const otroInput = document.getElementById(`tipoMasaOtro-${machineId}`);
                if(otroInput){
                    if(masaSel.value === '__OTRO__') { otroInput.classList.remove('hidden'); otroInput.focus(); }
                    else { otroInput.classList.add('hidden'); otroInput.value=''; }
                }
                // Control tipoPan según tipoMasa
                const panInput = document.getElementById(`tipoPan-${machineId}`);
                if(panInput){
                    if(masaSel.value === 'Tradicional'){
                        panInput.disabled=false; panInput.classList.remove('opacity-60');
                    } else {
                        panInput.value=''; panInput.disabled=true; panInput.classList.add('opacity-60');
                    }
                }
            }
        }
        // Ya no hay select de tipoPan (campo libre); se controla al cambiar tipoMasa
    });

    // --- Autocompletado y normalización de Tipo de pan ---
    function collectTipoPanValores(){
        const valores=new Set();
        // Desde registros guardados
        try{
            const data=JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            data.forEach(r=> (r.maquinas||[]).forEach(m=>{
                if(m.tipoPan && typeof m.tipoPan==='string' && m.tipoPan.trim()) valores.add(m.tipoPan.trim());
            }));
        }catch(_){ }
        // Desde inputs actuales
        document.querySelectorAll('input.tipo-pan-input').forEach(inp=>{ if(inp.value.trim()) valores.add(inp.value.trim()); });
        return Array.from(valores).sort();
    }
    function refreshTipoPanDatalist(){
        const dl=document.getElementById('lista-tipo-pan'); if(!dl) return;
        const vals=collectTipoPanValores();
        const frag=document.createDocumentFragment();
        vals.slice(0,60).forEach(v=>{ const opt=document.createElement('option'); opt.value=v; frag.appendChild(opt); });
        dl.innerHTML=''; dl.appendChild(frag);
    }
    // Normalizar: capitalizar primera letra, trim y colapsar espacios
    function normalizePan(str){
        if(!str) return '';
        str=str.replace(/\s+/g,' ').trim();
        return str.charAt(0).toUpperCase()+str.slice(1);
    }
    // Validación simple: longitud <= 40 y solo letras/números/espacios/acentos
    function validarPan(str){
        if(!str) return true; // vacío permitido si no Tradicional
        if(str.length>40) return false;
        return /^[\p{L}0-9 ][\p{L}0-9 .-]*$/u.test(str);
    }
    // Escuchar blur e input para normalizar y refrescar
    document.addEventListener('blur', function(e){
        if(e.target.matches('input.tipo-pan-input')){
            const inp=e.target; if(inp.disabled) return;
            const norm=normalizePan(inp.value);
            if(!validarPan(norm)){
                inp.classList.add('border-red-500','ring-red-400');
            }else{
                inp.classList.remove('border-red-500','ring-red-400');
                inp.value=norm;
                refreshTipoPanDatalist();
            }
        }
    }, true);
    document.addEventListener('input', function(e){
        if(e.target.matches('input.tipo-pan-input')){
            const inp=e.target; if(inp.disabled) return;
            if(validarPan(inp.value)) inp.classList.remove('border-red-500','ring-red-400');
            else inp.classList.add('border-red-500','ring-red-400');
        }
    });
    // Inicial
    refreshTipoPanDatalist();

    // Bloque eliminado: código huérfano de guardado general (sustituido por guardarResultadosPorMaquina)

    // Guardar resultados por máquina
    // Guardar campos temporales al cambiar cualquier input relevante
    if(machineCardsContainer) machineCardsContainer.addEventListener('input', function(e) {
        const target = e.target;
    const idMatch = target.id && target.id.match(/^(lote|tipoMasa|tipoMasaOtro|tipoPan|tempMasa|obs)-(\d)$/);
        if (idMatch) {
            const field = idMatch[1];
            const machineId = idMatch[2];
            let tempData = {};
            try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
            tempData[machineId] = tempData[machineId] || {};
            if(field==='obs') tempData[machineId].observaciones = target.value;
            else if(field==='tipoMasaOtro') tempData[machineId].tipoMasaOtro = target.value;
            else tempData[machineId][field] = target.value;
            localStorage.setItem('tempAmasadoras', JSON.stringify(tempData));
        }
        // Radios de hielo
        if(target.name && target.name.startsWith('hielo-')){
            const machineId = target.name.split('-')[1];
            let tempData = {};
            try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
            tempData[machineId] = tempData[machineId] || {};
            tempData[machineId].hielo = target.value;
            localStorage.setItem('tempAmasadoras', JSON.stringify(tempData));
        }
    });
    // Limpiar datos temporales al guardar resultados
    if(machineCardsContainer) machineCardsContainer.addEventListener('click', function(e) {
        const btn = e.target.closest('.guardar-maquina');
        if (!btn) return;
        const machineId = btn.getAttribute('data-machine-id');
        if (!machineId) return;
        // Limpiar datos temporales de esa máquina
        let tempData = {};
        try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
        delete tempData[machineId];
        localStorage.setItem('tempAmasadoras', JSON.stringify(tempData));
        guardarResultadosPorMaquina(machineId, btn);
    });

    function guardarResultadosPorMaquina(machineId, btn){
        const fecha = document.getElementById('fecha')?.value || '';
        if(!fecha){ mostrarMsgMaquina(machineId,'Selecciona una fecha para guardar.',false); return; }
        const machine = machineData.find(m=> m.id===machineId); if(!machine){ mostrarMsgMaquina(machineId,'Máquina no encontrada.', false); return; }
        const procesos = {};
        machine.processes.forEach(p=>{
            const timerId = `m${machine.id}-p${p.id}`;
            const run = timers[timerId];
            let tiempo=0, startTime=null, endTime=null;
            if(run && run.startTime){
                startTime = completedProcessTimes[timerId]?.firstStartTime || run.startTime;
                const base = run.baseElapsed||0;
                const current = Math.max(0, Math.floor((Date.now()-run.startTime)/1000));
                tiempo = base + current;
            } else {
                const comp = completedProcessTimes[timerId] || { time:0, startTime:null, endTime:null };
                tiempo = comp.time||0; startTime = comp.firstStartTime||comp.startTime||null; endTime = comp.endTime||null;
            }
            const minutos = Math.floor(tiempo/60), segundos = tiempo%60;
            procesos['proceso'+p.id] = { minutos, segundos, startTime, endTime };
        });
        // Variables adicionales
        let tipoMasa = document.getElementById(`tipoMasa-${machine.id}`)?.value || '';
        if(tipoMasa==='__OTRO__'){
            const otro = document.getElementById(`tipoMasaOtro-${machine.id}`)?.value.trim(); if(otro) tipoMasa = otro;
        }
        const tipoPan = document.getElementById(`tipoPan-${machine.id}`)?.value || '';
        const hielo = document.querySelector(`input[name="hielo-${machine.id}"]:checked`)?.value || 'No';
        const personalMin = document.getElementById('personal-min')?.value || '';
        const personalMax = document.getElementById('personal-max')?.value || '';
        const observaciones = document.getElementById(`obs-${machine.id}`)?.value || '';
        const tempAmbiente = document.getElementById('ta')?.value || '';
        const humedad = document.getElementById('h')?.value || '';
        const tempMasa = document.getElementById(`tempMasa-${machine.id}`)?.value || '';
        const lote = document.getElementById(`lote-${machine.id}`)?.value || '';
        const maquinaObj = { id:machine.id, nombre:machine.name, numeroAmasadora:machine.id, lote, tipoMasa, tipoPan, hielo, personalMin, personalMax, tempAmbiente, humedad, tempMasa, observaciones, ...procesos };
        // Validación procesos completos
        const incompletos = machine.processes.filter(p=>{ const o=maquinaObj['proceso'+p.id]; const totalSeg=((o?.minutos||0)*60)+(o?.segundos||0); return !(o && totalSeg>0 && o.startTime && o.endTime); }).map(p=>p.name);
        if(incompletos.length){ mostrarMsgMaquina(machineId,'Completa procesos: '+incompletos.join(', '), false); return; }
        const arr = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        arr.push({ fecha, maquinas:[maquinaObj] });
        localStorage.setItem('resultadosMezclado', JSON.stringify(arr));
        mostrarMsgMaquina(machineId,'¡Resultados guardados correctamente!', true);
    }

    // Fallback: cuando el DOM termine de cargar, intentar render si no se hizo
    document.addEventListener('DOMContentLoaded', ()=>{ initMachineCardsIfNeeded(); });
    // Analítica de patrones (versión activa – se eliminan stubs duplicados)
    function analizarPatrones(){
        let data = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        const puntos=[]; // { pctMuerto, ratioProd, tipoMasa, hielo, tempMasa, tempAmbiente, humedad, personal }
    data.forEach(r=> (r.maquinas||[]).forEach(m=>{
            const p1=m.proceso1, p3=m.proceso3; if(!(p1&&p1.startTime&&p3&&p3.endTime)) return;
            const total = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
            if(total<=0) return;
            let sumaProc=0; for(let i=1;i<=3;i++){ const p=m['proceso'+i]; if(p){ sumaProc += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0); } }
            if(sumaProc<=0) return;
            const pctMuerto = Math.max(0,total - sumaProc)*100/total;
            const ratioProd = sumaProc/total;
            // Calcular punto medio de personal si hay rango
            let pMin = parseInt(m.personalMin||r.personalMin);
            let pMax = parseInt(m.personalMax||r.personalMax);
            if(Number.isNaN(pMin) && !Number.isNaN(pMax)) pMin=pMax;
            if(Number.isNaN(pMax) && !Number.isNaN(pMin)) pMax=pMin;
            const pMid = (!Number.isNaN(pMin) && !Number.isNaN(pMax))? (pMin+pMax)/2 : parseInt(m.personal||r.personal)||NaN;
            puntos.push({ pctMuerto, ratioProd, tipoMasa:m.tipoMasa||'', tipoPan:m.tipoPan||'', hielo:m.hielo||'No', tempMasa:parseFloat(m.tempMasa)||NaN, tempAmbiente:parseFloat(r.ta)||NaN, humedad:parseFloat(r.h)||NaN, personal:pMid });
    }));
        const baseSet = puntos.slice();
        const basePct = baseSet.reduce((s,p)=>s+p.pctMuerto,0)/baseSet.length;
        const baseRatio = baseSet.reduce((s,p)=>s+p.ratioProd,0)/baseSet.length;
        const minGrupo=3;
        function scoreCategorico(campo){
            const grupos={}; baseSet.forEach(p=>{ const v=p[campo]||'__'; (grupos[v]=grupos[v]||[]).push(p); });
            const res=[]; Object.entries(grupos).forEach(([k,arr])=>{ if(arr.length<minGrupo) return; const pctAvg=arr.reduce((s,x)=>s+x.pctMuerto,0)/arr.length; const ratioAvg=arr.reduce((s,x)=>s+x.ratioProd,0)/arr.length; const mejoraMuerto=(basePct-pctAvg)/basePct; const mejoraProd=(ratioAvg-baseRatio)/baseRatio; const score= (mejoraProd - mejoraMuerto); res.push({valor:k,n:arr.length,pctAvg,ratioAvg,mejoraMuerto,mejoraProd,score}); }); res.sort((a,b)=>b.score-a.score); if(!res.length) return null; return {campo, grupos:res, top:res[0]}; }
        function scoreNumerico(campo){ const vals=baseSet.map(p=>p[campo]).filter(v=>Number.isFinite(v)); if(vals.length<minGrupo*2) return null; const s=vals.slice().sort((a,b)=>a-b); const q1=s[Math.floor(s.length/3)], q2=s[Math.floor(2*s.length/3)]; const bucket=v=> v<=q1?'Bajo': (v<=q2?'Medio':'Alto'); baseSet.forEach(p=>{ if(Number.isFinite(p[campo])) p['__b_'+campo]=bucket(p[campo]); }); return scoreCategorico('__b_'+campo); }
        const catCampos=['tipoMasa','tipoPan','hielo']; const numCampos=['tempMasa','tempAmbiente','humedad','personal']; const resultados=[]; catCampos.forEach(c=>{ const r=scoreCategorico(c); if(r?.top) resultados.push(r); }); numCampos.forEach(c=>{ const r=scoreNumerico(c); if(r?.top) resultados.push({...r,campo:c}); }); resultados.sort((a,b)=>(b.top?.score||0)-(a.top?.score||0)); const topLimit=parseInt(document.getElementById('patrones-top-fact')?.value||'5')||5; return { resumen:`Muestras: ${puntos.length} · Base %Muerto=${basePct.toFixed(1)} · Base Prod=${(baseRatio*100).toFixed(1)}%`, factores: resultados.slice(0,topLimit) };
    }

    // Render sencillo en un panel si existe contenedor #patrones-panel
    function renderPatrones(){
        const panel = document.getElementById('patrones-panel'); if(!panel) return;
        const r = analizarPatrones();
        if(!r || !r.factores.length){ panel.innerHTML = `<div class='text-stone-500 text-sm'>${r?.resumen||'Sin datos'}</div>`; return; }
        panel.innerHTML = `<div class='text-[12px] text-stone-600 mb-1 font-mono'>${r.resumen}</div>` +
            r.factores.slice(0,5).map(f=>{
                const top=f.top;
                const etiqueta = f.campo.startsWith('__b_')? f.campo.replace('__b_','')+' (terciles)': f.campo;
                return `<div class='mb-1 p-2 border border-stone-300 rounded bg-white'>
                    <div class='text-[11px] font-semibold text-stone-700 uppercase'>${etiqueta}</div>
                    <div class='text-[11px] text-stone-600'>Mejor grupo: <strong>${top.valor}</strong> (n=${top.n}) · %Muerto=${top.pctAvg.toFixed(1)}% · Prod=${(top.ratioAvg*100).toFixed(1)}%</div>
                    <div class='text-[10px] text-emerald-700'>Score ${(top.score).toFixed(2)} · Δ%Muerto ${(top.mejoraMuerto*100).toFixed(1)}% · ΔProd ${(top.mejoraProd*100).toFixed(1)}%</div>
                </div>`;
            }).join('');
    }

    // Intentar render al cargar vistas de tablas
    try { renderPatrones(); } catch(_){ }

    // mostrarMsgMaquina ya definido más abajo

    function cargarResultados() {
    // Botón Clear para borrar todos los resultados
    document.getElementById('btn-clear-resultados')?.addEventListener('click', function() {
        if (confirm('¿Seguro que deseas borrar TODOS los resultados de mezclado?')) {
            localStorage.removeItem('resultadosMezclado');
            cargarResultados();
            document.getElementById('promedios').innerHTML = '';
        }
    });
    // Obtener el contenedor de la lista de resultados
    const resultadosLista = document.getElementById('resultados-lista');
    if (!resultadosLista) return;
    resultadosLista.innerHTML = '<div class="text-stone-500 text-center">Cargando...</div>';
    let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
    if (!resultados.length) {
        resultadosLista.innerHTML = '<div class="text-stone-500 text-center">No hay resultados registrados.</div>';
        return;
    }
    resultadosLista.innerHTML = '';
    // Filtros
    const filtroFecha = document.getElementById('filtro-fecha')?.value;
    const filtroTipo = document.getElementById('filtro-tipo')?.value?.toLowerCase() || '';
    const filtroMaquina = document.getElementById('filtro-maquina')?.value?.toLowerCase() || '';
    let sumaTotales = 0, cuentaTotales = 0, sumaProc = [0,0,0], cuentaProc = [0,0,0];
    let totalesArr = [], procArr = [[],[],[]];
        resultados.forEach((res, idx) => {
            const fecha = res.fecha || '--';
            if (filtroFecha && fecha !== filtroFecha) return;
            // Mostrar rango de Personal general si existe (mín–máx)
            let personalGeneralMin = '';
            let personalGeneralMax = '';
            if (res.maquinas && res.maquinas.length > 0) {
                personalGeneralMin = res.maquinas[0].personalMin || '';
                personalGeneralMax = res.maquinas[0].personalMax || '';
            }
            const maquinas = res.maquinas || [];
            maquinas.forEach((maq, maqIdx) => {
                const tipoPan = maq.tipoMasa || maq.tipoPan || '--';
                const nombre = maq.nombre || maq.id || '--';
                const lote = maq.lote || '--';
                if (filtroTipo && !tipoPan.toLowerCase().includes(filtroTipo)) return;
                if (filtroMaquina && !nombre.toLowerCase().includes(filtroMaquina)) return;
                let procesosHtml = '';
                let tiempoMuerto1 = 0, tiempoMuerto2 = 0;
                // Calcular tiempos muertos
                if (maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime) {
                    tiempoMuerto1 = Math.max(0, Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000));
                }
                if (maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime) {
                    tiempoMuerto2 = Math.max(0, Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000));
                }
                let primerStart = maq.proceso1 && maq.proceso1.startTime ? maq.proceso1.startTime : null;
                let ultimoEnd = maq.proceso3 && maq.proceso3.endTime ? maq.proceso3.endTime : null;
                let totalSeg = null;
                if (primerStart && ultimoEnd) {
                    totalSeg = Math.max(0, Math.floor((ultimoEnd - primerStart)/1000));
                }
                // Sumar a promedios solo si hay total válido
                if (totalSeg !== null) {
                    sumaTotales += totalSeg;
                    cuentaTotales++;
                    totalesArr.push(totalSeg);
                }
                // Procesos individuales y promedios
                for (let i = 1; i <= 3; i++) {
                    const proc = maq[`proceso${i}`] || {};
                    const t = (parseInt(proc.minutos) || 0) * 60 + (parseInt(proc.segundos) || 0);
                    sumaProc[i-1] += t;
                    cuentaProc[i-1]++;
                    procArr[i-1].push(t);
                    let inicio = proc.startTime ? new Date(proc.startTime).toLocaleTimeString() : '--:--:--';
                    let fin = proc.endTime ? new Date(proc.endTime).toLocaleTimeString() : '--:--:--';
                    procesosHtml += `
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700 tooltip'>${['Esponja','Masa','Mantequilla'][i-1]}:
                                    <span class="tooltiptext">Tiempo de proceso ${['Esponja','Masa','Mantequilla'][i-1]}</span>
                                </span>
                                <span class='font-mono text-lg text-stone-900'>${(proc.minutos+'').padStart(2,'0')}:${(proc.segundos+'').padStart(2,'0')}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${inicio}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin}</span></div>
                        </div>
                        `;
                }
                // Calcular total de tiempos muertos
                let totalMuertos = tiempoMuerto1 + tiempoMuerto2;
                // Día de la semana
                let diaSemana = '--';
                if (fecha && fecha.length === 10) {
                    const dias = ['Domingo','Lunes','Martes','Miercoles','Jueves','Viernes','Sábado'];
                    // Ajustar para zona local y evitar desfase por UTC
                    const [anio, mes, dia] = fecha.split('-').map(Number);
                    const fechaLocal = new Date(anio, mes - 1, dia);
                    diaSemana = dias[fechaLocal.getDay()];
                }
                // Alternar color de fondo
                const bgAlt = (idx+maqIdx)%2===0 ? 'bg-white' : 'bg-stone-100';
                // Icono advertencia si pasa de 45 min
                const advertencia = totalSeg > 2700 ? `<span title="Supera 45 minutos" class="ml-2 text-red-600 text-2xl align-middle">&#9888;</span>` : '';
                // Mostrar hielo
                const hielo = maq.hielo ? maq.hielo : '--';
                // Dedupe badge (si ya fue enviada esta amasadora a la BD)
                let _sent = false; let _sentBadge='';
                try { _sent = __wasSent(__sig(fecha, maq)); if(_sent){ _sentBadge = '<span class="ml-2 inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-semibold bg-emerald-600 text-white">Enviado</span>'; } } catch(_){ }
                const enviarBtnHtml = _sent
                    ? `<button class="enviar-bd bg-stone-400 text-white px-6 py-3 rounded-lg font-bold text-lg shadow cursor-not-allowed" data-idx="${idx}" data-maqidx="${maqIdx}" disabled>Ya enviado</button>`
                    : `<button class="enviar-bd bg-amber-600 text-white px-6 py-3 rounded-lg hover:bg-amber-700 transition-colors font-bold text-lg shadow" data-idx="${idx}" data-maqidx="${maqIdx}">Enviar a BD</button>`;
                resultadosLista.innerHTML += `
                <div class="${bgAlt} rounded-2xl shadow-lg p-8 border border-stone-200 mb-6 fade-in">
                    <div class="mb-6 flex flex-wrap gap-8 justify-between items-center">
                        <span class="text-stone-800 font-bold text-xl">Fecha: <span class="font-mono text-lg">${fecha}</span> <span class="text-base text-stone-500">(${diaSemana})</span> ${_sentBadge}</span>
                        <span class="text-stone-800 font-bold text-xl">Lote: <span class="font-mono text-lg">${lote}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Tipo de masa: <span class="font-mono text-lg">${tipoPan}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Amasadora: <span class="font-mono text-lg">${(maq.numeroAmasadora || (nombre.match(/\d+/)?.[0]) || '?')}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Hielo: <span class="font-mono text-lg">${hielo}</span></span>
                        <span class="text-stone-800 font-bold text-xl">H: <span class="font-mono text-lg">${maq.humedad || '--'}%</span></span>
                        <span class="text-stone-800 font-bold text-xl">TM: <span class="font-mono text-lg">${maq.tempMasa || '--'}C</span></span>
                        <span class="text-stone-800 font-bold text-xl">TA: <span class="font-mono text-lg">${maq.tempAmbiente || '--'}C</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 1: <span class="font-mono text-lg">${formatTime(tiempoMuerto1)}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 2: <span class="font-mono text-lg">${formatTime(tiempoMuerto2)}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muertos Total: <span class="font-mono text-lg">${formatTime(totalMuertos)}</span></span>
                        ${maqIdx === 0 && (personalGeneralMin || personalGeneralMax) ? `<span class='text-stone-800 font-bold text-xl'>Personal: <span class='font-mono text-lg'>${personalGeneralMin||'?'}–${personalGeneralMax||'?'}</span></span>` : ''}
                    </div>
                    <div class="mb-4 divide-y divide-stone-200">
                        ${procesosHtml}
                    </div>
                    <div class="mb-4">
                        <span class="block text-base font-semibold text-stone-800">Obs:</span>
                        <div class="bg-stone-100 rounded p-2 min-h-[2rem]">${maq.observaciones ? maq.observaciones : '<span class=\"text-stone-400\">(Sin observaciones)</span>'}</div>
                    </div>
                    <div class="mt-4 font-extrabold text-2xl text-blue-700 text-right">Total: ${totalSeg !== null ? formatTime(totalSeg) : '--:--:--'} ${advertencia}</div>
                    <div class="mt-6 flex flex-wrap gap-3 justify-center">
                        ${enviarBtnHtml}
                        <button class="borrar-resultado bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition-colors font-bold text-lg shadow" data-idx="${idx}" data-maqidx="${maqIdx}">Borrar</button>
                    </div>
                </div>
                `;
            });
        });
    // Mostrar promedios generales y por tipo de masa
        let promediosHtml = '';
        function stddev(arr) {
            if (!arr.length) return 0;
            const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
            return Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-mean,2),0)/arr.length);
        }
        function relStddev(std, mean) {
            if (!mean) return '0%';
            return ((std/mean)*100).toFixed(1) + '%';
        }
        // Promedios generales
        if (cuentaTotales > 0) {
            const prom = Math.round(sumaTotales/cuentaTotales);
            const std = Math.round(stddev(totalesArr));
            const rel = relStddev(std, prom);
            promediosHtml += `<span>Promedio total: <span class=\"font-mono\">${formatTime(prom)}</span> (±${formatTime(std)}, ${rel})</span> &nbsp;`;
            for (let i=0; i<3; i++) {
                if (cuentaProc[i]) {
                    const promP = Math.round(sumaProc[i]/cuentaProc[i]);
                    const stdP = Math.round(stddev(procArr[i]));
                    const relP = relStddev(stdP, promP);
                    promediosHtml += `<span>${['Esponja','Masa','Mantequilla'][i]}: <span class=\"font-mono\">${formatTime(promP)}</span> (±${formatTime(stdP)}, ${relP})</span> &nbsp;`;
                }
            }
        }
    // (Tabla de promedios por tipo de masa movida solo a gráficas)
        document.getElementById('promedios').innerHTML = promediosHtml;
    // Evento para borrar resultado
    resultadosLista.addEventListener('click', function(e) {
        const btn = e.target.closest('.borrar-resultado');
        if (!btn) return;
        if (!confirm('¿Seguro que deseas borrar este resultado?')) return;
        const card = btn.closest('div.rounded-2xl');
        if (card) {
            card.classList.remove('fade-in');
            card.classList.add('fade-out');
            setTimeout(() => {
                const idx = parseInt(btn.getAttribute('data-idx'));
                const maqIdx = parseInt(btn.getAttribute('data-maqidx'));
                let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
                if (resultados[idx] && resultados[idx].maquinas && resultados[idx].maquinas[maqIdx]) {
                    resultados[idx].maquinas.splice(maqIdx, 1);
                    if (resultados[idx].maquinas.length === 0) {
                        resultados.splice(idx, 1);
                    }
                    localStorage.setItem('resultadosMezclado', JSON.stringify(resultados));
                    cargarResultados();
                }
            }, 500);
        }
    });
    // Subpestañas Local/BD
    (function(){
        const localW = document.getElementById('resultados-local-wrapper');
        const bdW = document.getElementById('bd-wrapper');
        const subLocal = document.getElementById('subtab-local');
        const subBD = document.getElementById('subtab-bd');
        function showLocal(){ localStorage.setItem('RESULTADOS_SUBTAB','local'); localW?.classList.remove('hidden'); bdW?.classList.add('hidden'); subLocal?.classList.add('tab-btn-active'); subBD?.classList.remove('tab-btn-active'); }
        function showBD(){ localStorage.setItem('RESULTADOS_SUBTAB','bd'); bdW?.classList.remove('hidden'); localW?.classList.add('hidden'); subBD?.classList.add('tab-btn-active'); subLocal?.classList.remove('tab-btn-active'); loadBDView(); }
        subLocal?.addEventListener('click', e=>{ e.preventDefault(); showLocal(); });
        subBD?.addEventListener('click', e=>{ e.preventDefault(); showBD(); });
        const preferred = localStorage.getItem('RESULTADOS_SUBTAB');
        const apiUrl = localStorage.getItem('API_URL_OVERRIDE')||'';
        const apiKey = sessionStorage.getItem('API_KEY') || localStorage.getItem('API_KEY_PERSIST') || '';
        if(preferred==='bd' && (apiUrl||apiKey)) { showBD(); return; }
        if(apiUrl || apiKey){
            // Si no hay preferencia pero usuario tiene credenciales, mostrar BD directamente
            showBD();
        } else {
            showLocal();
        }
    })();

    // Enviar todo a la BD (local)
    let _sendingAllInFlight = false;
    document.getElementById('btn-enviar-todo-bd')?.addEventListener('click', async function(){
        const fecha = document.getElementById('filtro-fecha')?.value || document.getElementById('fecha')?.value;
        const status = document.getElementById('local-bd-status');
        try{
            if(_sendingAllInFlight){ return; }
            _sendingAllInFlight = true;
            if(!fecha){ status.textContent = 'Selecciona una fecha o filtra una fecha para enviar.'; status.className='text-xs text-red-600 text-center'; return; }
            const payload = construirPayloadFecha(fecha);
            if(!payload){ status.textContent = 'No hay datos locales para esa fecha.'; status.className='text-xs text-stone-600 text-center'; return; }
            // --- DEDUPE (filtrar amasadoras ya enviadas) ---
            try {
                const original = payload.amasadoras || [];
                let skipped = 0;
                payload.amasadoras = original.filter(m=>{ const s=__sig(payload.fecha, m); if(__wasSent(s)){ skipped++; return false;} return true; });
                if(payload.amasadoras.length===0){ status.textContent = 'Todos los registros de esa fecha ya habían sido enviados (0 nuevos).'; status.className='text-xs text-amber-600 text-center'; return; }
                if(skipped>0){ status.textContent = `Filtrados ${skipped} duplicados. Enviando ${payload.amasadoras.length} nuevos...`; status.className='text-xs text-stone-600 text-center'; }
            }catch(_){ /* ignore dedupe errors */ }
            const base=resolveApiBase();
            const url = base + '/registros';
            const r = await fetch(url,{ method:'POST', headers: apiHeaders(true), body: JSON.stringify(payload) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            const n = payload.amasadoras?.length || 0;
            status.textContent = `¡Enviado a BD correctamente! (${n} amasadora${n===1?'':'s'})`; status.className='text-xs text-green-600 text-center';
            // Marcar firmas enviadas
            try { (payload.amasadoras||[]).forEach(m=> __markSent(__sig(payload.fecha,m))); } catch(_){ }
        }catch(e){ status.textContent = 'Error enviando: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
        finally{ _sendingAllInFlight = false; }
    });

    // Manejar click en "Enviar a BD" por tarjeta
    let _sendingCardInFlight = false;
    document.getElementById('resultados-lista')?.addEventListener('click', async function(e){
        const btn = e.target.closest('.enviar-bd');
        if(!btn) return;
        const idx = parseInt(btn.getAttribute('data-idx'));
        const maqIdx = parseInt(btn.getAttribute('data-maqidx'));
        const status = document.getElementById('local-bd-status');
        try{
            if(_sendingCardInFlight){ return; }
            _sendingCardInFlight = true;
            const resultados = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            const reg = resultados[idx];
            if(!reg){ throw new Error('Registro no encontrado'); }
            const maq = reg.maquinas?.[maqIdx];
            if(!maq){ throw new Error('Amasadora no encontrada'); }
            // Construir payload solo con esa máquina
            const procesos=[]; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ procesos.push({ id:i, minutos: parseInt(p.minutos)||0, segundos: parseInt(p.segundos)||0, startTime: p.startTime||null, endTime: p.endTime||null }); } }
            // Derivados: TM1, TM2, muertos total, total real (primer inicio a último fin) y total procesos
            const p1 = maq.proceso1||{}; const p2 = maq.proceso2||{}; const p3 = maq.proceso3||{};
            const toSecs = (pp)=> (parseInt(pp?.minutos)||0)*60 + (parseInt(pp?.segundos)||0);
            const sumProcesosSeg = toSecs(p1)+toSecs(p2)+toSecs(p3);
            const tm1Seg = (p1?.endTime && p2?.startTime) ? Math.max(0, Math.floor((p2.startTime - p1.endTime)/1000)) : null;
            const tm2Seg = (p2?.endTime && p3?.startTime) ? Math.max(0, Math.floor((p3.startTime - p2.endTime)/1000)) : null;
            const muertosSeg = (tm1Seg||0) + (tm2Seg||0);
            const totalRealSeg = (p1?.startTime && p3?.endTime) ? Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)) : null;
            const nombreMaq = maq.nombre||maq.id||'';
            const numeroAmasadora = maq.numeroAmasadora || (nombreMaq.match(/\d+/)?.[0]) || '';
            const payload = {
                fecha: reg.fecha,
                tempAmbiente: maq.tempAmbiente||reg.maquinas?.[0]?.tempAmbiente||'',
                humedad: maq.humedad||reg.maquinas?.[0]?.humedad||'',
                personalMin: reg.maquinas?.[0]?.personalMin||'',
                personalMax: reg.maquinas?.[0]?.personalMax||'',
                // Resumen/agrupados a nivel de registro (un solo equipo en este caso)
                resumenDia: (function(){
                    const tMasa = parseFloat(maq.tempMasa);
                    const tipo = (maq.tipoMasa||maq.tipoPan||'').trim();
                    const hielo = (maq.hielo||'').trim();
                    return {
                        fecha: reg.fecha,
                        cantidadAmasadoras: 1,
                        tm1SegDia: tm1Seg||0,
                        tm2SegDia: tm2Seg||0,
                        muertosSegDia: muertosSeg,
                        totalRealSegDia: totalRealSeg||0,
                        totalProcesosSegDia: sumProcesosSeg,
                        promedioTempMasaDia: Number.isFinite(tMasa) ? tMasa : null,
                        tiposMasaConteo: tipo ? { [tipo]: 1 } : {},
                        hieloConteo: hielo ? { [hielo]: 1 } : {}
                    };
                })(),
                amasadoras: [{
                    id: maq.id||numeroAmasadora||'',
                    nombre: nombreMaq,
                    numeroAmasadora,
                    tipoMasa: maq.tipoMasa||maq.tipoPan||'',
                    hielo: maq.hielo||'',
                    lote: maq.lote||'',
                    tempMasa: maq.tempMasa||'',
                    observaciones: maq.observaciones||'',
                    // factores por máquina (también en raíz, pero se duplican aquí para auditoría por máquina)
                    personalMin: maq.personalMin||reg.maquinas?.[0]?.personalMin||'',
                    personalMax: maq.personalMax||reg.maquinas?.[0]?.personalMax||'',
                    tempAmbiente: maq.tempAmbiente||reg.maquinas?.[0]?.tempAmbiente||'',
                    humedad: maq.humedad||reg.maquinas?.[0]?.humedad||'',
                    // métricas derivadas
                    tm1Seg, tm2Seg, muertosSeg, totalRealSeg, totalProcesosSeg: sumProcesosSeg,
                    procesos
                }]
            };
            const base=resolveApiBase();
            const url = base + '/registros';
            // DEDUPE single tarjeta
            try {
                const sig = __sig(payload.fecha, payload.amasadoras?.[0]||{});
                if(__wasSent(sig)){
                    status.textContent = 'Esta amasadora ya fue enviada antes. (Omitida)'; status.className='text-xs text-amber-600 text-center';
                    return;
                }
            }catch(_){ /* ignore */ }
            const r = await fetch(url,{ method:'POST', headers: apiHeaders(true), body: JSON.stringify(payload) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            status.textContent = '¡Tarjeta enviada a BD correctamente!'; status.className='text-xs text-green-600 text-center';
            try { const sig = __sig(payload.fecha, payload.amasadoras?.[0]||{}); __markSent(sig); }catch(_){ }
        }catch(err){ status.textContent = 'Error enviando tarjeta: '+(err.message||err); status.className='text-xs text-red-600 text-center'; }
        finally{ _sendingCardInFlight = false; }
    });

    // ============ Vista BD remota ============
    let BD_CACHE = [];
    async function loadBDView(){
        const base = resolveApiBase();
        const url = base + '/registros';
        const cont = document.getElementById('bd-lista');
        const status = document.getElementById('sync-status');
        if(!cont) return;
        cont.innerHTML = '<div class="text-stone-500 text-center">Cargando...</div>';
        try{
            const r = await fetch(url, { headers: apiHeaders(false) });
            if(!r.ok) throw new Error('HTTP '+r.status);
            const arr = await r.json();
            BD_CACHE = Array.isArray(arr) ? arr : [];
            renderBDList();
            status.textContent = `Cargados ${arr.length} registros de la BD.`; status.className='text-xs text-green-600 text-center';
        }catch(e){ cont.innerHTML = '<div class="text-red-600 text-center">Error cargando BD: '+(e.message||e)+'</div>'; status.textContent=''; }
    }
    function getBDFiltered(){
        const fFecha = document.getElementById('bd-filtro-fecha')?.value || '';
        const fTipo = (document.getElementById('bd-filtro-tipo')?.value || '').toLowerCase();
        const fMaq = (document.getElementById('bd-filtro-maquina')?.value || '').toLowerCase();
        if(!Array.isArray(BD_CACHE) || !BD_CACHE.length) return [];
        // Filtrado: fecha en el registro; tipo/amasadora en cada máquina
        const out = [];
        BD_CACHE.forEach(rec=>{
            const fecha = rec.data?.fecha || rec.fecha || '';
            if(fFecha && fecha !== fFecha) return;
            const amas = Array.isArray(rec.data?.amasadoras) ? rec.data.amasadoras : [];
            const amasFiltradas = amas.filter(m=>{
                const tipo = (m.tipoMasa || m.tipoPan || '').toLowerCase();
                const nombre = (m.nombre || m.id || '').toLowerCase();
                const amNum = (m.numeroAmasadora || (String(m.nombre||m.id||'').match(/\d+/)?.[0]||'')).toString();
                const maqStr = (nombre + ' ' + amNum).toLowerCase();
                if(fTipo && !tipo.includes(fTipo)) return false;
                if(fMaq && !maqStr.includes(fMaq)) return false;
                return true;
            });
            if(amasFiltradas.length){
                out.push({ ...rec, data: { ...(rec.data||{}), amasadoras: amasFiltradas } });
            }
        });
        return out;
    }
    function renderBDList(){
        const cont = document.getElementById('bd-lista');
        if(!cont) return;
        const items = getBDFiltered();
        if(!Array.isArray(items) || !items.length){ cont.innerHTML = '<div class="text-stone-500 text-center">No hay registros en la BD.</div>'; return; }
        cont.innerHTML = '';
        // Helper: normaliza procesos[] a proceso1..3 si faltan
        function normalizeMaq(m){
            if(m && !m.proceso1 && Array.isArray(m.procesos)){
                const map = {}; m.procesos.forEach(p=>{ if(p && p.id!=null){ map['proceso'+p.id] = { minutos: p.minutos||0, segundos: p.segundos||0, startTime: p.startTime||null, endTime: p.endTime||null }; } });
                return { ...m, ...map };
            }
            return m;
        }
        // Aplanar: una tarjeta por amasadora
        items.forEach(it=>{
            const fecha = it.data?.fecha || it.fecha || '';
            const id = it.id;
            const creado = it.createdAt ? new Date(it.createdAt).toLocaleString() : '';
            const amas = (it.data?.amasadoras || []).map(normalizeMaq);
            (amas||[]).forEach((m,i)=>{
                const amNumRaw = m.numeroAmasadora || ((m.nombre||m.id||'').match(/\d+/)?.[0]);
                const amNum = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                const nombreAma = 'Amasadora ' + amNum;
                const tipo = (m.tipoMasa||m.tipoPan||'')||'--';
                const lote = m.lote||'--';
                const hielo = m.hielo||'--';
                const tm = (m.tempMasa!=null && m.tempMasa!=='')? `${m.tempMasa}`:'--';
                const ta = (m.tempAmbiente!=null && m.tempAmbiente!=='')? `${m.tempAmbiente}`:'--';
                const h = (m.humedad!=null && m.humedad!=='')? `${m.humedad}`:'--';
                const perMin = m.personalMin||'';
                const perMax = m.personalMax||'';
                // Derivados si faltan
                const p1 = m.proceso1||{}; const p2 = m.proceso2||{}; const p3 = m.proceso3||{};
                const tm1Seg = (m.tm1Seg!=null)? m.tm1Seg : ((p1?.endTime && p2?.startTime)? Math.max(0, Math.floor((p2.startTime - p1.endTime)/1000)) : null);
                const tm2Seg = (m.tm2Seg!=null)? m.tm2Seg : ((p2?.endTime && p3?.startTime)? Math.max(0, Math.floor((p3.startTime - p2.endTime)/1000)) : null);
                const muertosSeg = (tm1Seg||0) + (tm2Seg||0);
                const totalRealSeg = (m.totalRealSeg!=null)? m.totalRealSeg : ((p1?.startTime && p3?.endTime)? Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)) : null);
                // Helpers
                const pFmt = (p)=> p? `${String(p.minutos||0).padStart(2,'0')}:${String(p.segundos||0).padStart(2,'0')}` : '--:--';
                const ini = (x)=> x? new Date(x).toLocaleTimeString() : '--:--:--';
                const fin = (x)=> x? new Date(x).toLocaleTimeString() : '--:--:--';
                const advertencia = (totalRealSeg!=null && totalRealSeg>2700) ? `<span title="Supera 45 minutos" class="ml-2 text-red-600 text-2xl align-middle">&#9888;</span>` : '';
                const card = document.createElement('div');
                const _selKey = id+':'+i;
                const checked = __BD_SELECTED.some(s=> s.key===_selKey) ? 'checked' : '';
                card.className = 'relative bg-white rounded-2xl shadow-lg p-6 border border-stone-200 mb-6';
                card.setAttribute('data-id', id);
                card.setAttribute('data-ama-index', i);
                card.innerHTML = `
                    ${__BD_SELECT_MODE ? `<div class='absolute top-2 left-2'><input type="checkbox" class="bd-select-chk w-5 h-5" data-key="${_selKey}" ${checked} /></div>`:''}
                    <div class="mb-4 flex flex-wrap gap-6 justify-between items-center">
                        <span class="text-stone-800 font-bold text-xl">Fecha: <span class="font-mono text-lg">${fecha}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Lote: <span class="font-mono text-lg">${lote}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Tipo de masa: <span class="font-mono text-lg">${tipo}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Amasadora: <span class="font-mono text-lg">${amNum}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Hielo: <span class="font-mono text-lg">${hielo}</span></span>
                        <span class="text-stone-800 font-bold text-xl">H: <span class="font-mono text-lg">${h}%</span></span>
                        <span class="text-stone-800 font-bold text-xl">TM: <span class="font-mono text-lg">${tm}C</span></span>
                        <span class="text-stone-800 font-bold text-xl">TA: <span class="font-mono text-lg">${ta}C</span></span>
                        ${(perMin||perMax)? `<span class="text-stone-800 font-bold text-xl">Personal: <span class="font-mono text-lg">${perMin||'?'}–${perMax||'?'}</span></span>`:''}
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 1: <span class="font-mono text-lg">${tm1Seg!=null? formatTime(tm1Seg):'--:--:--'}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 2: <span class="font-mono text-lg">${tm2Seg!=null? formatTime(tm2Seg):'--:--:--'}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muertos Total: <span class="font-mono text-lg">${formatTime(muertosSeg)}</span></span>
                    </div>
                    <div class="mb-4 divide-y divide-stone-200">
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700'>Esponja:</span>
                                <span class='font-mono text-lg text-stone-900'>${pFmt(p1)}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${ini(p1.startTime)}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin(p1.endTime)}</span></div>
                        </div>
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700'>Masa:</span>
                                <span class='font-mono text-lg text-stone-900'>${pFmt(p2)}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${ini(p2.startTime)}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin(p2.endTime)}</span></div>
                        </div>
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700'>Mantequilla:</span>
                                <span class='font-mono text-lg text-stone-900'>${pFmt(p3)}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${ini(p3.startTime)}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin(p3.endTime)}</span></div>
                        </div>
                    </div>
                    <div class="mb-4">
                        <span class="block text-base font-semibold text-stone-800">Obs:</span>
                        <div class="bg-stone-100 rounded p-2 min-h-[2rem]">${m.observaciones ? m.observaciones : '<span class=\"text-stone-400\">(Sin observaciones)</span>'}</div>
                    </div>
                    <div class="mt-2 font-extrabold text-2xl text-blue-700 text-right">Total: ${totalRealSeg!=null? formatTime(totalRealSeg):'--:--:--'} ${advertencia}</div>
                    <div class="mt-6 flex flex-wrap gap-2 justify-end text-xs text-stone-500">
                        <span>Registro ID: ${id}</span>
                        <span>Creado: ${creado}</span>
                    </div>
                    <div class="mt-3 flex flex-wrap gap-3 justify-center">
                        <button class="bd-view-json-ama bg-stone-600 text-white px-3 py-1 rounded text-sm" data-id="${id}" data-ama-index="${i}">Ver JSON (amasadora)</button>
                        ${__BD_SELECT_MODE? '' : `<button class="bd-delete bg-red-600 text-white px-3 py-1 rounded text-sm" data-id="${id}" title="Borra todo el registro (todas las amasadoras)">Borrar registro</button>`}
                    </div>
                `;
                cont.appendChild(card);
            });
        });
    }
    document.getElementById('bd-refresh')?.addEventListener('click', loadBDView);
    // Refiltrar al escribir
    ['bd-filtro-fecha','bd-filtro-tipo','bd-filtro-maquina'].forEach(id=>{
        document.getElementById(id)?.addEventListener('input', ()=> renderBDList());
    });
    document.getElementById('bd-delete-all')?.addEventListener('click', async function(){
        if(!confirm('¿Seguro que deseas borrar TODOS los registros en la BD?')) return;
        const base=resolveApiBase();
        const url = base + '/registros';
        const status = document.getElementById('sync-status');
        try{
            const r = await fetch(url,{ method:'DELETE', headers: apiHeaders(false) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            status.textContent = 'Registros eliminados.'; status.className='text-xs text-green-600 text-center';
            loadBDView();
        }catch(e){ status.textContent='Error al borrar: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
    });
    document.getElementById('bd-lista')?.addEventListener('click', async function(e){
        // Selección múltiple (checkbox)
        const chk = e.target.closest('.bd-select-chk');
        if(chk){
            const key = chk.getAttribute('data-key');
            const card = chk.closest('div[data-id]');
            const id = card?.getAttribute('data-id');
            const amaIndex = card?.getAttribute('data-ama-index');
            if(chk.checked){
                if(!__BD_SELECTED.some(s=>s.key===key)) __BD_SELECTED.push({ key, id, amaIndex: parseInt(amaIndex) });
            } else {
                __BD_SELECTED = __BD_SELECTED.filter(s=> s.key!==key);
            }
            updateBDSelectedUI();
            return;
        }
        // Ver JSON de la amasadora individual
        const viewAmaBtn = e.target.closest('.bd-view-json-ama');
        if(viewAmaBtn){
            const id = viewAmaBtn.getAttribute('data-id');
            const idx = parseInt(viewAmaBtn.getAttribute('data-ama-index'));
            const rec = (BD_CACHE||[]).find(x=> String(x.id)===String(id));
            const ama = rec?.data?.amasadoras?.[idx];
            const modal = document.getElementById('json-modal');
            const pre = document.getElementById('json-modal-content');
            if(modal && pre){
                const payload = ama ? { registroId: rec.id, fecha: rec.data?.fecha||rec.fecha||'', ...ama } : (rec?.data ?? rec ?? {});
                pre.textContent = JSON.stringify(payload, null, 2);
                modal.classList.remove('hidden');
                modal.classList.add('flex');
            }
            return;
        }
        const btn = e.target.closest('.bd-delete');
        if(!btn) return;
        const id = btn.getAttribute('data-id');
        if(!id) return;
        if(!confirm('¿Borrar registro '+id+'? (Se eliminarán todas las amasadoras de ese registro)')) return;
        const base=resolveApiBase();
        const url = base + '/registros/'+id;
        const status = document.getElementById('sync-status');
        try{
            const r = await fetch(url,{ method:'DELETE', headers: apiHeaders(false) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            status.textContent = 'Registro eliminado.'; status.className='text-xs text-green-600 text-center';
            loadBDView();
        }catch(e){ status.textContent = 'Error al borrar: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
    });

    // --------- MULTI-SELECT BD STATE & HELPERS ---------
    let __BD_SELECT_MODE = false;
    let __BD_SELECTED = [];
    function updateBDSelectedUI(){
        const countEl = document.getElementById('bd-selected-count');
        if(countEl) countEl.textContent = __BD_SELECTED.length;
        const delBtn = document.getElementById('bd-delete-selected');
        if(delBtn) delBtn.classList.toggle('hidden', __BD_SELECTED.length===0 || !__BD_SELECT_MODE);
    }
    function toggleBDSelectMode(){
        __BD_SELECT_MODE = !__BD_SELECT_MODE;
        if(!__BD_SELECT_MODE){ __BD_SELECTED = []; }
        const btn = document.getElementById('bd-select-mode');
        if(btn) btn.textContent = __BD_SELECT_MODE ? 'Cancelar selección' : 'Seleccionar';
        updateBDSelectedUI();
        renderBDList();
    }
    document.getElementById('bd-select-mode')?.addEventListener('click', toggleBDSelectMode);
    document.getElementById('bd-delete-selected')?.addEventListener('click', async function(){
        if(!__BD_SELECTED.length) return;
        if(!confirm('¿Eliminar '+__BD_SELECTED.length+' elemento(s) seleccionados?')) return;
        const status = document.getElementById('sync-status');
        const base = resolveApiBase();
        let ok=0, fail=0;
        for(const sel of __BD_SELECTED){
            try{
                // Determinar si eliminamos una sola amasadora o registro completo (si sólo 1 en data)
                const rec = (BD_CACHE||[]).find(r=> String(r.id)===String(sel.id));
                const amas = Array.isArray(rec?.data?.amasadoras)? rec.data.amasadoras: [];
                let url='';
                if(amas.length>1){ // borrar solo la amasadora
                    url = base + '/registros/'+sel.id+'/amasadoras/'+sel.amaIndex;
                } else {
                    url = base + '/registros/'+sel.id;
                }
                const r = await fetch(url,{ method:'DELETE', headers: apiHeaders(false) });
                if(!r.ok) throw new Error('HTTP '+r.status);
                ok++;
            }catch(_){ fail++; }
        }
        status.textContent = `Eliminación múltiple: OK ${ok}, Fallidos ${fail}`; status.className='text-xs '+(fail? 'text-amber-600':'text-green-600')+' text-center';
        __BD_SELECTED=[]; updateBDSelectedUI(); loadBDView();
    });

    // --------- FRONTEND DEDUPE (FIRMAS ENVIADAS) ---------
    const __ENVIADAS_KEY = 'ENVIADAS_BD';
    function __loadSent(){ try { return JSON.parse(localStorage.getItem(__ENVIADAS_KEY)||'{}'); } catch(_){ return {}; } }
    let __ENVIADAS_MAP = __loadSent();
    function __saveSent(){ try { localStorage.setItem(__ENVIADAS_KEY, JSON.stringify(__ENVIADAS_MAP)); }catch(_){ } }
    function __sig(fecha, m){
        try {
            const tipo = (m?.tipoMasa||m?.tipoPan||'').toString().trim().toLowerCase();
            const nombre = (m?.nombre||m?.id||'').toString().trim().toLowerCase();
            const p1Start = m?.proceso1?.startTime || (Array.isArray(m?.procesos)? m.procesos[0]?.startTime: '') || '';
            return [fecha||'', nombre, tipo, p1Start||''].join('__');
        }catch(_){ return fecha+'__err'; }
    }
    function __wasSent(sig){ return !!__ENVIADAS_MAP[sig]; }
    function __markSent(sig){ __ENVIADAS_MAP[sig]=Date.now(); __saveSent(); }
    // (Opcional) limpiar entradas muy antiguas >30 días para no crecer indefinidamente
    (function(){
        const THIRTY = 30*24*3600*1000; const now=Date.now(); let changed=false;
        for(const k in __ENVIADAS_MAP){ if(now - (__ENVIADAS_MAP[k]||0) > THIRTY){ delete __ENVIADAS_MAP[k]; changed=true; } }
        if(changed) __saveSent();
    })();

    // Cierre del modal JSON
    document.getElementById('json-modal-close')?.addEventListener('click', ()=>{
        const modal=document.getElementById('json-modal'); if(!modal) return; modal.classList.add('hidden'); modal.classList.remove('flex');
    });
    document.getElementById('json-modal')?.addEventListener('click', (e)=>{
        if(e.target.id==='json-modal'){
            const modal=document.getElementById('json-modal'); if(!modal) return; modal.classList.add('hidden'); modal.classList.remove('flex');
        }
    });

    // Cambio de fuente de datos en Tablas
    document.getElementById('tablas-source')?.addEventListener('change', function(){
        localStorage.setItem('TABLAS_SOURCE', this.value);
        const btnPdf=document.getElementById('tablas-export-pdf');
        const btnCsv=document.getElementById('tablas-export-csv');
        if(btnPdf) btnPdf.textContent = `Exportar (${this.value==='bd'?'BD':'Locales'}) PDF`;
        if(btnCsv) btnCsv.textContent = `Exportar (${this.value==='bd'?'BD':'Locales'}) CSV`;
        buildTablasVista();
    });
    // Filtros BD para Tablas
    const bdDesdeEl = document.getElementById('tablas-bd-desde');
    const bdHastaEl = document.getElementById('tablas-bd-hasta');
    const bdLoteEl = document.getElementById('tablas-bd-lote');
    const bdTipoEl = document.getElementById('tablas-bd-tipo');
    function persistFilters(){
        if(bdDesdeEl) localStorage.setItem('TABLAS_BD_DESDE', bdDesdeEl.value||'');
        if(bdHastaEl) localStorage.setItem('TABLAS_BD_HASTA', bdHastaEl.value||'');
        if(bdLoteEl) localStorage.setItem('TABLAS_BD_LOTE', bdLoteEl.value||'');
        if(bdTipoEl) localStorage.setItem('TABLAS_BD_TIPO', bdTipoEl.value||'');
    }
    [bdDesdeEl, bdHastaEl, bdLoteEl, bdTipoEl].forEach(el=> el?.addEventListener('change', ()=>{ persistFilters(); buildTablasVista(); }));
    const topNPatronesEl = document.getElementById('patrones-lote-topN');
    if(topNPatronesEl){ topNPatronesEl.addEventListener('change', ()=> buildTablasVista()); }
    // Recalculo ligero de panel de patrones sin redibujar toda la vista (preserva scroll)
    function recalcPatronesLigero(){
        const y = window.scrollY;
        try { if(typeof renderPatrones==='function') renderPatrones(); } catch(_){ }
        try { if(typeof window.__calcularPatronesLote==='function') window.__calcularPatronesLote(); } catch(_){ }
        requestAnimationFrame(()=> window.scrollTo(0,y));
    }
    ['patrones-min-grupo','patrones-top-fact','patrones-lote-minN','patrones-lote-topN'].forEach(id=>{
        const el=document.getElementById(id);
        if(el){ el.addEventListener('change', recalcPatronesLigero); }
    });
    document.getElementById('tablas-bd-clear')?.addEventListener('click', function(){
        if(bdDesdeEl) bdDesdeEl.value=''; if(bdHastaEl) bdHastaEl.value=''; if(bdLoteEl) bdLoteEl.value=''; if(bdTipoEl) bdTipoEl.value='';
        ['TABLAS_BD_DESDE','TABLAS_BD_HASTA','TABLAS_BD_LOTE','TABLAS_BD_TIPO'].forEach(k=> localStorage.removeItem(k));
        buildTablasVista();
    });

    // Copiar JSON del modal
    document.getElementById('json-modal-copy')?.addEventListener('click', async function(){
        const pre = document.getElementById('json-modal-content');
        const btn = this;
        const text = pre?.textContent || '';
        try{
            if(navigator.clipboard?.writeText){ await navigator.clipboard.writeText(text); }
            else { const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); }
            const prev=btn.textContent; btn.textContent='Copiado'; setTimeout(()=>btn.textContent=prev,1200);
        }catch(_){ const prev=btn.textContent; btn.textContent='Error'; setTimeout(()=>btn.textContent=prev,1200); }
    });
    // Exportar CSV
    document.getElementById('btn-exportar-csv')?.addEventListener('click', function() {
        let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
        let rows = [];
        let sumaTiemposMuertos = 0;
        let sumaTotalGeneral = 0;
        // Utilidad para limpiar caracteres raros
        function limpiarTexto(txt) {
            if (!txt) return '';
            // Eliminar caracteres no imprimibles, tildes, símbolos y todo lo no ASCII
            return String(txt)
                .replace(/[\uFFFD\uFEFF\u200B\u00A0]/g, '') // invisibles
                .replace(/[±]/g, '+/-')
                .replace(/[°]/g, ' deg')
                .replace(/[ÁÀÂÃÄáàâãä]/g, 'a')
                .replace(/[ÉÈÊËéèêë]/g, 'e')
                .replace(/[ÍÌÎÏíìîï]/g, 'i')
                .replace(/[ÓÒÔÕÖóòôõö]/g, 'o')
                .replace(/[ÚÙÛÜúùûü]/g, 'u')
                .replace(/[Ññ]/g, 'n')
                .replace(/[^A-Za-z0-9 %.,;:_\-\(\)\[\]\{\}/\\+\/=<>\?\!\|\'\"]+/g, '') // solo ASCII seguro
                .normalize('NFC');
        }
        resultados.forEach(res => {
            const fecha = limpiarTexto(res.fecha || '');
            (res.maquinas||[]).forEach(maq => {
                let totalSegundos = 0;
                let firstRow = true;
                // Calcular tiempos muertos entre procesos
                let tiempoMuerto1 = '';
                let tiempoMuerto2 = '';
                if (maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime) {
                    tiempoMuerto1 = Math.max(0, Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000));
                }
                if (maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime) {
                    tiempoMuerto2 = Math.max(0, Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000));
                }
                let totalMuertos = (tiempoMuerto1 || 0) + (tiempoMuerto2 || 0);
                sumaTiemposMuertos += totalMuertos;
                for (let i=1; i<=3; i++) {
                    const proc = maq[`proceso${i}`] || {};
                    const t = (parseInt(proc.minutos)||0)*60 + (parseInt(proc.segundos)||0);
                    totalSegundos += t;
                    // Día de la semana limpio
                    let diaSemana = '';
                    if (firstRow && fecha && fecha.length===10) {
                        const dias = ['Domingo','Lunes','Martes','Miércoles','Jueves','Viernes','Sábado'];
                        const [anio, mes, dia] = fecha.split('-').map(Number);
                        const fechaLocal = new Date(anio, mes - 1, dia);
                        diaSemana = dias[fechaLocal.getDay()];
                        diaSemana = limpiarTexto(diaSemana);
                    }
                    rows.push({
                        Fecha: firstRow ? fecha : '',
                        Dia: firstRow ? diaSemana : '',
                        Maquina: firstRow ? limpiarTexto(maq.nombre||maq.id||'') : '',
                        TipoMasa: firstRow ? limpiarTexto(maq.tipoMasa||maq.tipoPan||'') : '',
                        Hielo: firstRow ? limpiarTexto(maq.hielo||'') : '',
                        'TA': firstRow ? limpiarTexto(maq.tempAmbiente||'') : '',
                        'H': firstRow ? limpiarTexto(maq.humedad||'') : '',
                        'TM': firstRow ? limpiarTexto(maq.tempMasa||'') : '',
                        PersonalMin: firstRow ? limpiarTexto(maq.personalMin||'') : '',
                        PersonalMax: firstRow ? limpiarTexto(maq.personalMax||'') : '',
                        Proceso: ['Esponja','Masa','Mantequilla'][i-1],
                        Minutos: proc.minutos||0,
                        Segundos: proc.segundos||0,
                        Inicio: proc.startTime ? new Date(proc.startTime).toLocaleTimeString() : '',
                        Fin: proc.endTime ? new Date(proc.endTime).toLocaleTimeString() : '',
                        SegT: '',
                        TM1: firstRow ? tiempoMuerto1 : '',
                        TM2: firstRow ? tiempoMuerto2 : '',
                        'TTot (s)': firstRow ? (totalSegundos + totalMuertos) : '',
                        'TTot (m)': firstRow ? ((totalSegundos + totalMuertos) ? formatTime(totalSegundos + totalMuertos) : '') : '',
                        Obs: firstRow ? limpiarTexto(maq.observaciones||'') : ''
                    });
                    firstRow = false;
                }
                // Agregar fila de total
                sumaTotalGeneral += totalSegundos + totalMuertos;
                rows.push({
                    Fecha: '',
                    Dia: '',
                    Maquina: '',
                    TipoMasa: '',
                    Hielo: '',
                    'TA': '',
                    'H': '',
                    'TM': '',
                    Proceso: 'TOTAL',
                    Minutos: Math.floor(totalSegundos/60),
                    Segundos: totalSegundos%60,
                    Inicio: '',
                    Fin: '',
                    SegT: totalSegundos,
                    TM1: tiempoMuerto1,
                    TM2: tiempoMuerto2,
                    TMTot: totalMuertos,
                    TTot: totalSegundos + totalMuertos,
                    Obs: ''
                });
            });
        });
        // Agregar bloque resumen de tiempos muertos y total general
        rows.push({});
        rows.push({Pro: 'RESUMEN TIEMPOS MUERTOS'});
        rows.push({Pro: 'Suma total de tiempos muertos (s)', Valor: sumaTiemposMuertos});
        rows.push({Pro: 'Suma total general (incluye tiempos muertos) (s)', Valor: sumaTotalGeneral});
        // Utilidades
        function stddev(arr) {
            if (!arr.length) return 0;
            const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
            return Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-mean,2),0)/arr.length);
        }
        function relStddev(std, mean) {
            if (!mean) return '0%';
            return ((std/mean)*100).toFixed(1) + '%';
        }
    // Promedios por tipo de masa (tiempo)
        let panStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const tipo = maq.tipoMasa || maq.tipoPan || 'Sin especificar';
                let total = 0;
                for (let i=1; i<=3; i++) {
                    const proc = maq[`proceso${i}`];
                    if (proc) total += (parseInt(proc.minutos)||0)*60 + (parseInt(proc.segundos)||0);
                }
                if (!panStats[tipo]) panStats[tipo] = [];
                panStats[tipo].push(total);
            });
        });
        rows.push({});
        rows.push({TipoMasa: 'Promedios por tipo de masa (tiempo)', Minutos: 'Promedio', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({TipoMasa: 'Promedios por tipo de masa (tiempo)', Minutos: 'Promedio (s)', Segundos: '+/-Desv (s)', Inicio: '%Desv'});
        for (const tipo in panStats) {
            const arr = panStats[tipo];
            if (!arr.length) continue;
            const prom = Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
            const std = Math.round(stddev(arr));
            const rel = relStddev(std, prom);
            rows.push({TipoMasa: tipo, Minutos: prom, Segundos: std, Inicio: rel});
        }

        // Promedios por amasadora (tiempo)
        let amasadoraStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const amNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.nombreMaquina||'').match(/\d+/)?.[0]);
                const amasadora = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                let total = 0;
                for (let i=1; i<=3; i++) {
                    const proc = maq[`proceso${i}`];
                    if (proc) total += (parseInt(proc.minutos)||0)*60 + (parseInt(proc.segundos)||0);
                }
                if (!amasadoraStats[amasadora]) amasadoraStats[amasadora] = [];
                amasadoraStats[amasadora].push(total);
            });
        });
        rows.push({});
        rows.push({Maquina: 'Promedios por amasadora (tiempo)', Minutos: 'Promedio', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({Maquina: 'Promedios por amasadora (tiempo)', Minutos: 'Promedio (s)', Segundos: '+/-Desv (s)', Inicio: '%Desv'});
        for (const amasadora in amasadoraStats) {
            const arr = amasadoraStats[amasadora];
            if (!arr.length) continue;
            const prom = Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
            const std = Math.round(stddev(arr));
            const rel = relStddev(std, prom);
            rows.push({Maquina: amasadora, Minutos: prom, Segundos: std, Inicio: rel});
        }

        // Temperatura por amasadora
        let tempAmasadoraStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const amNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.nombreMaquina||'').match(/\d+/)?.[0]);
                const amasadora = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                const temp = parseFloat(maq.tempMasa);
                if (!isNaN(temp)) {
                    if (!tempAmasadoraStats[amasadora]) tempAmasadoraStats[amasadora] = [];
                    tempAmasadoraStats[amasadora].push(temp);
                }
            });
        });
        rows.push({});
        rows.push({Maquina: 'Temperatura de masa por amasadora', Minutos: 'Promedio (°C)', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({Maquina: 'Temperatura de masa por amasadora', Minutos: 'Promedio (grados C)', Segundos: '+/-Desv (grados C)', Inicio: '%Desv'});
        for (const amasadora in tempAmasadoraStats) {
            const arr = tempAmasadoraStats[amasadora];
            if (!arr.length) continue;
            const prom = arr.reduce((a,b)=>a+b,0)/arr.length;
            const std = stddev(arr);
            const rel = relStddev(std, prom);
            rows.push({Maquina: amasadora, Minutos: prom.toFixed(1), Segundos: std.toFixed(1), Inicio: rel});
        }

    // Temperatura por tipo de masa
        let tempPanStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const tipo = maq.tipoMasa || maq.tipoPan || 'Sin especificar';
                const temp = parseFloat(maq.tempMasa);
                if (!isNaN(temp)) {
                    if (!tempPanStats[tipo]) tempPanStats[tipo] = [];
                    tempPanStats[tipo].push(temp);
                }
            });
        });
        rows.push({});
        rows.push({TipoMasa: 'Temperatura de masa por tipo de masa', Minutos: 'Promedio (°C)', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({TipoMasa: 'Temperatura de masa por tipo de masa', Minutos: 'Promedio (grados C)', Segundos: '+/-Desv (grados C)', Inicio: '%Desv'});
        for (const tipo in tempPanStats) {
            const arr = tempPanStats[tipo];
            if (!arr.length) continue;
            const prom = arr.reduce((a,b)=>a+b,0)/arr.length;
            const std = stddev(arr);
            const rel = relStddev(std, prom);
            rows.push({TipoMasa: tipo, Minutos: prom.toFixed(1), Segundos: std.toFixed(1), Inicio: rel});
        }

    // Tabla cruzada: amasadora vs tipo de masa (temperatura)
        let tempAmasadoraLabels = Object.keys(tempAmasadoraStats);
        let tempPanLabels = Object.keys(tempPanStats);
        rows.push({});
    let cruzadaHeader = {Maquina: 'Temp. masa por amasadora y tipo de masa'};
        tempPanLabels.forEach(tipo => cruzadaHeader[tipo] = tipo);
        rows.push(cruzadaHeader);
        tempAmasadoraLabels.forEach(amasadora => {
            let row = {Maquina: amasadora};
            tempPanLabels.forEach(tipo => {
                let arr = [];
                resultados.forEach(res => {
                    (res.maquinas||[]).forEach(maq => {
                        const amNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.nombreMaquina||'').match(/\d+/)?.[0]);
                        const amaKey = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                        if (amaKey === amasadora && ((maq.tipoMasa||maq.tipoPan)||'Sin especificar') === tipo) {
                            const temp = parseFloat(maq.tempMasa);
                            if (!isNaN(temp)) arr.push(temp);
                        }
                    });
                });
                row[tipo] = arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(1) : '';
            });
            rows.push(row);
        });

    // (Tabla cruzada tipo de masa vs amasadora eliminada)
        // Ordenar columnas para que Obs quede al extremo derecho despues de SegundosTotales
        if (rows.length > 0) {
            let cols = Object.keys(rows[0]);
            // Quitar Obs y TTot si existen
            const idxObs = cols.indexOf('Obs');
            if (idxObs !== -1) cols.splice(idxObs, 1);
            // Quitar TTot (s) y TTot (m) si existen
            const idxTTotS = cols.indexOf('TTot (s)');
            if (idxTTotS !== -1) cols.splice(idxTTotS, 1);
            const idxTTotM = cols.indexOf('TTot (m)');
            if (idxTTotM !== -1) cols.splice(idxTTotM, 1);
            // Mover Personal antes de Proceso
            const idxPersonal = cols.indexOf('Personal');
            if (idxPersonal !== -1) cols.splice(idxPersonal, 1);
            const idxProceso = cols.indexOf('Proceso');
            if (idxProceso !== -1) cols.splice(idxProceso, 0, 'Personal');
            // Insertar TTot (s) y TTot (m) antes de Obs
            cols.push('TTot (s)');
            cols.push('TTot (m)');
            cols.push('Obs');
            // Limpiar todos los encabezados y valores
            cols = cols.map(c => limpiarTexto(c));
            rows = rows.map(r => {
                const nuevo = {};
                cols.forEach(c => {
                    // Buscar la clave original (sin limpiar) que corresponde a este encabezado limpio
                    let claveOriginal = Object.keys(r).find(k => limpiarTexto(k) === c);
                    nuevo[c] = limpiarTexto(claveOriginal ? r[claveOriginal] : '');
                });
                return nuevo;
            });
        }
        const csv = Papa.unparse(rows);
        const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
        saveAs(blob, 'resultados_mezclado.csv');
    });
    }

    // Si necesitas cargar resultados de amasadoras automáticamente al iniciar:
    document.addEventListener('DOMContentLoaded', function() {
        // Migración de datos legacy: copiar tipoPan -> tipoMasa si falta
        try {
            let legacy = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            let mod=false;
            legacy.forEach(r=> (r.maquinas||[]).forEach(m=>{ if(!m.tipoMasa && m.tipoPan){ m.tipoMasa = m.tipoPan; mod=true; } }));
            if(mod) localStorage.setItem('resultadosMezclado', JSON.stringify(legacy));
        } catch(_){}
    const viewMain = document.getElementById('view-main-menu');
    const viewMedicion = document.getElementById('view-medicion');
        const viewResultados = document.getElementById('view-resultados');
        const viewTablas = document.getElementById('view-tablas');
    const sectionAmas = document.getElementById('section-amasadoras');
    const sectionFerm = document.getElementById('section-fermentadora');
    const sectionHornos = document.getElementById('section-hornos');
    const tabMainMenu = document.getElementById('tab-main-menu');
    const tabMainAmas = document.getElementById('tab-main-amasadoras');
    const tabMainFerm = document.getElementById('tab-main-fermentadora');
    const tabMainHornos = document.getElementById('tab-main-hornos');
        const tabMedicion = document.getElementById('tab-medicion');
        const tabResultados = document.getElementById('tab-resultados');
        const tabTablas = document.getElementById('tab-tablas');

        // Estado inicial
        // Initial: show Menu and ensure sub-vistas de Amasadoras no se "cuelen"
        if (viewMain) viewMain.classList.remove('hidden');
        if (sectionAmas) sectionAmas.classList.add('hidden');
        // Asegurar todo oculto por defecto fuera de Amasadoras
        viewMedicion?.classList.add('hidden');
        viewResultados?.classList.add('hidden');
        viewTablas?.classList.add('hidden');
        sectionFerm?.classList.add('hidden');
        sectionHornos?.classList.add('hidden');

        function hideAmasadorasSubviews(){
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.add('hidden');
            tabMedicion?.classList.remove('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
        }

        function showMedicionDefault(){
            // Mostrar Medición como subpestaña por defecto
            // Asegurar que la vista Mesa quede oculta al entrar a Amasadoras
            viewMesa?.classList.add('hidden');
            viewMedicion?.classList.remove('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.add('hidden');
            tabMedicion?.classList.add('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
            // Renderizar tarjetas de máquinas si aún no se han creado (o si quedaron vacías)
            try {
                const cont = document.getElementById('machine-cards');
                if(cont && (!cont.children.length || cont.getAttribute('data-needs-render')==='1')){
                    if(typeof createMachineCards==='function') createMachineCards();
                    cont.removeAttribute('data-needs-render');
                }
            } catch(_){ }
        }

        function activateMainTab(which){
            [tabMainMenu, tabMainAmas, tabMainFerm, tabMainHornos].forEach(b=> b?.classList.remove('tab-btn-active'));
            viewMain?.classList.add('hidden');
            sectionAmas?.classList.add('hidden');
            hideAmasadorasSubviews();
            sectionFerm?.classList.add('hidden');
            sectionHornos?.classList.add('hidden');
            if(which==='menu'){ tabMainMenu?.classList.add('tab-btn-active'); viewMain?.classList.remove('hidden'); return; }
            if(which==='amas'){ tabMainAmas?.classList.add('tab-btn-active'); sectionAmas?.classList.remove('hidden'); showMedicionDefault(); return; }
            if(which==='ferm'){ tabMainFerm?.classList.add('tab-btn-active'); sectionFerm?.classList.remove('hidden'); return; }
            if(which==='horn'){ tabMainHornos?.classList.add('tab-btn-active'); sectionHornos?.classList.remove('hidden'); return; }
        }
        tabMainMenu?.addEventListener('click', ()=> activateMainTab('menu'));
        tabMainAmas?.addEventListener('click', ()=> activateMainTab('amas'));
        tabMainFerm?.addEventListener('click', ()=> activateMainTab('ferm'));
        tabMainHornos?.addEventListener('click', ()=> activateMainTab('horn'));
        // Force start on Menu to avoid Amasadoras content appearing under Menu
        activateMainTab('menu');
        // ========= Sidebar subviews (Amasadoras & Mesa) =========
        const amasSidebar = document.getElementById('amas-sidebar');
        const amasSubCaptura = document.getElementById('amas-sub-captura');
        const amasSubResultados = document.getElementById('amas-sub-resultados');
        const amasSubTablas = document.getElementById('amas-sub-tablas');
        const originalResultadosView = document.getElementById('view-resultados');
        const originalTablasView = document.getElementById('view-tablas');
        // Reubicar contenido existente dentro de wrappers si existen
        if(originalResultadosView && amasSubResultados){ amasSubResultados.querySelector('#amas-sub-resultados-wrapper')?.appendChild(originalResultadosView); originalResultadosView.classList.remove('hidden'); }
        if(originalTablasView && amasSubTablas){ amasSubTablas.querySelector('#amas-sub-tablas-wrapper')?.appendChild(originalTablasView); originalTablasView.classList.remove('hidden'); }
        function setAmasSubview(which){
            [amasSubCaptura, amasSubResultados, amasSubTablas].forEach(v=> v?.classList.add('hidden'));
            // Ocultar Mesa siempre que se navega dentro de Amasadoras
            viewMesa?.classList.add('hidden');
            if(which==='captura') amasSubCaptura?.classList.remove('hidden');
            if(which==='resultados') amasSubResultados?.classList.remove('hidden');
            if(which==='tablas') amasSubTablas?.classList.remove('hidden');
            amasSidebar?.querySelectorAll('button[data-amas-sub]')?.forEach(btn=>{
                if(btn.getAttribute('data-amas-sub')===which) btn.classList.add('tab-btn-active'); else btn.classList.remove('tab-btn-active');
            });
            localStorage.setItem('AMAS_LAST_SUB', which||'captura');
        }
        amasSidebar?.addEventListener('click', e=>{
            const b=e.target.closest('button[data-amas-sub]'); if(!b) return; setAmasSubview(b.getAttribute('data-amas-sub'));
        });
        document.getElementById('switch-to-mesa')?.addEventListener('click', ()=>{ activateMainTab('amas'); showMesa(); });
        // Mesa sidebar subviews (ya existe showMesa / mesaRenderLista etc.)
        const mesaSidebar=document.getElementById('mesa-sidebar');
        const mesaSubCaptura=document.getElementById('mesa-sub-captura');
        const mesaSubResultados=document.getElementById('mesa-sub-resultados');
        const mesaSubTablas=document.getElementById('mesa-sub-tablas');
        function setMesaSubview(which){
            [mesaSubCaptura, mesaSubResultados, mesaSubTablas].forEach(v=> v?.classList.add('hidden'));
            if(which==='captura') mesaSubCaptura?.classList.remove('hidden');
            if(which==='resultados') mesaSubResultados?.classList.remove('hidden');
            if(which==='tablas') mesaSubTablas?.classList.remove('hidden');
            mesaSidebar?.querySelectorAll('button[data-mesa-sub]')?.forEach(btn=>{
                if(btn.getAttribute('data-mesa-sub')===which) btn.classList.add('tab-btn-active'); else btn.classList.remove('tab-btn-active');
            });
            localStorage.setItem('MESA_LAST_SUB', which||'captura');
        }
        mesaSidebar?.addEventListener('click', e=>{ const b=e.target.closest('button[data-mesa-sub]'); if(!b) return; setMesaSubview(b.getAttribute('data-mesa-sub')); });
        document.getElementById('switch-to-amas')?.addEventListener('click', ()=>{ activateMainTab('amas'); setAmasSubview('captura'); });
        // Set defaults
        setAmasSubview('captura');
        // Restaurar última subpestaña si existe
        const lastAmas = localStorage.getItem('AMAS_LAST_SUB'); if(lastAmas) setAmasSubview(lastAmas);
        const lastMesa = localStorage.getItem('MESA_LAST_SUB'); if(lastMesa) setMesaSubview(lastMesa);

        // Colapsar / expandir sidebars
        function setupCollapsibleSidebar(sidebarId, collapseBtnId, storageKey){
            const btn = document.getElementById(collapseBtnId);
            const sidebar = document.getElementById(sidebarId);
            if(!sidebar||!btn) return;
            function apply(state){
                if(state==='collapsed'){
                    sidebar.classList.add('opacity-0','pointer-events-none');
                    sidebar.style.maxHeight='0px';
                    btn.textContent='Mostrar menú';
                } else {
                    sidebar.classList.remove('opacity-0','pointer-events-none');
                    sidebar.style.maxHeight='';
                    btn.textContent='Ocultar menú';
                }
            }
            let current = localStorage.getItem(storageKey)||'expanded';
            apply(current);
            btn.addEventListener('click', ()=>{
                current = (current==='expanded')?'collapsed':'expanded';
                localStorage.setItem(storageKey, current);
                apply(current);
            });
        }
        setupCollapsibleSidebar('amas-sidebar','amas-sidebar-collapse','AMAS_SIDEBAR_STATE');
        // ================= Subpestaña Mesa (procesado de bandejas) =================
        const tabMesa = document.getElementById('tab-mesa');
        const viewMesa = document.getElementById('view-mesa');
        function showMesa(){
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.add('hidden');
            viewMesa?.classList.remove('hidden');
            tabMedicion?.classList.remove('tab-btn-active');
            tabMesa?.classList.add('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
            mesaRenderLista();
        }
        tabMesa?.addEventListener('click', showMesa);
        tabMedicion?.addEventListener('click', ()=>{ showMedicionDefault(); viewMesa?.classList.add('hidden'); tabMesa?.classList.remove('tab-btn-active'); });
        tabResultados?.addEventListener('click', ()=>{ viewMesa?.classList.add('hidden'); });
        tabTablas?.addEventListener('click', ()=>{ viewMesa?.classList.add('hidden'); });

        // Cronómetro Mesa
        let mesaTimer=null, mesaStart=null, mesaAccum=0;
        const mesaDisp=document.getElementById('mesa-tiempo-display');
        const mesaBtnStart=document.getElementById('mesa-start');
        const mesaBtnStop=document.getElementById('mesa-stop');
        const mesaBtnReset=document.getElementById('mesa-reset');
        function mesaFmt(s){ const h=Math.floor(s/3600).toString().padStart(2,'0'); const m=Math.floor((s%3600)/60).toString().padStart(2,'0'); const sec=Math.floor(s%60).toString().padStart(2,'0'); return `${h}:${m}:${sec}`; }
        function mesaTick(){ if(!mesaStart) return; const diff=mesaAccum + Math.floor((Date.now()-mesaStart)/1000); if(mesaDisp) mesaDisp.textContent=mesaFmt(diff); }
        mesaBtnStart?.addEventListener('click', ()=>{ if(mesaStart) return; mesaStart=Date.now(); mesaTimer=setInterval(mesaTick,1000); mesaBtnStart.disabled=true; mesaBtnStop.disabled=false; mesaBtnReset.disabled=false; });
        mesaBtnStop?.addEventListener('click', ()=>{ if(!mesaStart) return; mesaAccum += Math.floor((Date.now()-mesaStart)/1000); clearInterval(mesaTimer); mesaTimer=null; mesaStart=null; mesaTick(); mesaBtnStart.disabled=false; mesaBtnStop.disabled=true; });
        mesaBtnReset?.addEventListener('click', ()=>{ if(mesaTimer) clearInterval(mesaTimer); mesaTimer=null; mesaStart=null; mesaAccum=0; if(mesaDisp) mesaDisp.textContent='00:00:00'; mesaBtnStart.disabled=false; mesaBtnStop.disabled=true; mesaBtnReset.disabled=true; });

        // Habilitar tipoPan solo para Tradicional
        const mesaTipoMasa = document.getElementById('mesa-tipo-masa');
        const mesaTipoPan = document.getElementById('mesa-tipo-pan');
        mesaTipoMasa?.addEventListener('change', ()=>{
            if(mesaTipoMasa.value==='Tradicional'){ mesaTipoPan.disabled=false; mesaTipoPan.classList.remove('opacity-50'); } else { mesaTipoPan.disabled=true; mesaTipoPan.value=''; mesaTipoPan.classList.add('opacity-50'); }
        });

        function mesaGet(){ try { return JSON.parse(localStorage.getItem('mesaRegistros')||'[]')||[]; } catch(_){ return []; } }
        function mesaSave(arr){ localStorage.setItem('mesaRegistros', JSON.stringify(arr)); }
        function mesaRenderLista(){ const cont=document.getElementById('mesa-lista'); if(!cont) return; const data=mesaGet(); if(!data.length){ cont.innerHTML='<div class="text-sm text-stone-500">Sin lotes registrados.</div>'; return;} data.sort((a,b)=> (a.fecha+a.lote).localeCompare(b.fecha+b.lote)); cont.innerHTML=data.map((r,i)=>{ const perMid=(r.perMin!=null&&r.perMax!=null)?((r.perMin+r.perMax)/2).toFixed(2):''; return `<div class='border border-stone-200 rounded-lg p-3 bg-white text-xs flex flex-col gap-1'><div class='flex flex-wrap gap-3 items-center'><span class='font-semibold'>#${i+1}</span><span class='font-mono'>${r.fecha}</span><span>Lote:<strong>${r.lote}</strong></span><span>${r.tipoMasa}${r.tipoPan? ' / '+r.tipoPan:''}</span><span>Dur:<strong>${mesaFmt(r.duracionSeg||0)}</strong></span><span>PerMid:${perMid}</span></div><div class='text-stone-600 break-words'>${(r.obs||'').replace(/</g,'&lt;')}</div></div>`; }).join(''); }

        document.getElementById('mesa-guardar')?.addEventListener('click', ()=>{
            const msg=document.getElementById('mesa-msg'); if(msg) msg.textContent='';
            const fecha=(document.getElementById('mesa-fecha')?.value||'').trim();
            const lote=(document.getElementById('mesa-lote')?.value||'').trim();
            const tipoMasa=(mesaTipoMasa?.value||'').trim();
            const tipoPanVal=(mesaTipoPan?.value||'').trim();
            const perMinStr=document.getElementById('mesa-per-min')?.value; const perMaxStr=document.getElementById('mesa-per-max')?.value; const perMin=perMinStr?parseInt(perMinStr):null; const perMax=perMaxStr?parseInt(perMaxStr):null;
            const obs=(document.getElementById('mesa-obs')?.value||'').trim();
            let dur=mesaAccum; if(mesaStart) dur += Math.floor((Date.now()-mesaStart)/1000);
            if(!fecha||!lote||!tipoMasa||dur<=0){ if(msg){ msg.className='text-sm text-red-600'; msg.textContent='Faltan campos o duración 0.';} return; }
            const reg={fecha,lote,tipoMasa,tipoPan:(tipoMasa==='Tradicional'?tipoPanVal:''),perMin,perMax,obs,duracionSeg:dur};
            const data=mesaGet(); data.push(reg); mesaSave(data); mesaRenderLista(); mesaBtnReset?.click(); document.getElementById('mesa-obs').value=''; document.getElementById('mesa-lote').value=''; if(msg){ msg.className='text-sm text-emerald-700'; msg.textContent='Lote guardado.'; }
        });
        document.getElementById('mesa-limpiar')?.addEventListener('click', ()=>{ mesaBtnReset?.click(); document.getElementById('mesa-obs').value=''; });
        document.getElementById('mesa-export')?.addEventListener('click', ()=>{ const data=mesaGet(); if(!data.length){ mostrarToast('Sin datos'); return; } const rows=data.map(r=>({Fecha:r.fecha,Lote:r.lote,TipoMasa:r.tipoMasa,TipoPan:r.tipoPan||'',Duracion_s:r.duracionSeg,PersonalMin:r.perMin??'',PersonalMax:r.perMax??'',PersonalMid:(r.perMin!=null&&r.perMax!=null?((r.perMin+r.perMax)/2).toFixed(2):''),Obs:r.obs||''})); const csv=Papa.unparse(rows); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); saveAs(blob,'mesa_lotes.csv'); });
        document.getElementById('mesa-borrar-todo')?.addEventListener('click', ()=>{ if(!confirm('¿Eliminar todos los lotes de Mesa?')) return; localStorage.removeItem('mesaRegistros'); mesaRenderLista(); });
        // ======================= Resultados Mesa =======================
        const mesaResLocalBtn = document.getElementById('mesa-res-sub-local');
        const mesaResBdBtn = document.getElementById('mesa-res-sub-bd');
        const mesaLocalCtrls = document.getElementById('mesa-local-controls');
        const mesaBdCtrls = document.getElementById('mesa-bd-controls');
        function setMesaResultadosFuente(src){
            if(src==='bd'){
                mesaLocalCtrls?.classList.add('hidden');
                mesaBdCtrls?.classList.remove('hidden');
                mesaResBdBtn?.classList.add('tab-btn-active');
                mesaResLocalBtn?.classList.remove('tab-btn-active');
                loadMesaBD();
            } else {
                mesaBdCtrls?.classList.add('hidden');
                mesaLocalCtrls?.classList.remove('hidden');
                mesaResLocalBtn?.classList.add('tab-btn-active');
                mesaResBdBtn?.classList.remove('tab-btn-active');
                renderMesaResultadosLocales();
            }
            localStorage.setItem('MESA_RES_SOURCE', src);
        }
        mesaResLocalBtn?.addEventListener('click', ()=> setMesaResultadosFuente('local'));
        mesaResBdBtn?.addEventListener('click', ()=> setMesaResultadosFuente('bd'));
        setMesaResultadosFuente(localStorage.getItem('MESA_RES_SOURCE')||'local');
        function mesaCalculosBasicos(dataset){
            const out={n:dataset.length, totalSeg:0, arr:[], porTipo:{}, porPan:{}, perMid:[], fechas:{}};
            dataset.forEach(r=>{ out.totalSeg += r.duracionSeg||0; out.arr.push(r.duracionSeg||0); if(r.tipoMasa){ (out.porTipo[r.tipoMasa]=out.porTipo[r.tipoMasa]||[]).push(r.duracionSeg||0);} if(r.tipoPan){ (out.porPan[r.tipoPan]=out.porPan[r.tipoPan]||[]).push(r.duracionSeg||0);} if(r.perMin!=null && r.perMax!=null){ out.perMid.push((r.perMin+r.perMax)/2); } if(r.fecha){ out.fechas[r.fecha]=(out.fechas[r.fecha]||[]); out.fechas[r.fecha].push(r.duracionSeg||0);} });
            function prom(arr){ return arr.length? arr.reduce((a,b)=>a+b,0)/arr.length:0; }
            function std(arr){ if(arr.length<2) return 0; const m=prom(arr); return Math.sqrt(arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length);} 
            return { ...out, prom: prom(out.arr), std: std(out.arr), promTipos:Object.fromEntries(Object.entries(out.porTipo).map(([k,v])=>[k,prom(v)])), promPanes:Object.fromEntries(Object.entries(out.porPan).map(([k,v])=>[k,prom(v)])) };
        }
        function renderMesaResultadosLocales(){
            const lista=document.getElementById('mesa-resultados-lista'); const status=document.getElementById('mesa-status'); const promDiv=document.getElementById('mesa-promedios'); if(!lista) return;
            const all=mesaGet(); const fFecha=document.getElementById('mesa-filtro-fecha')?.value||''; const fTipo=(document.getElementById('mesa-filtro-tipo')?.value||'').toLowerCase(); const fPan=(document.getElementById('mesa-filtro-pan')?.value||'').toLowerCase();
            const filtrados=all.filter(r=> (!fFecha||r.fecha===fFecha) && (!fTipo|| (r.tipoMasa||'').toLowerCase().includes(fTipo)) && (!fPan|| (r.tipoPan||'').toLowerCase().includes(fPan)) );
            if(status) status.textContent=`Locales: ${filtrados.length} lote(s)`;
            const calc=mesaCalculosBasicos(filtrados);
            if(promDiv){ promDiv.innerHTML = calc.n? `Promedio: <strong>${formatTime(Math.round(calc.prom))}</strong> (±${formatTime(Math.round(calc.std))}) · Tipos: ${Object.keys(calc.promTipos).length}`:'Sin datos'; }
            if(!filtrados.length){ lista.innerHTML='<div class="text-xs text-stone-500">Sin datos.</div>'; return; }
            lista.innerHTML = filtrados.map((r,i)=>{
                const perMid=(r.perMin!=null&&r.perMax!=null)?((r.perMin+r.perMax)/2).toFixed(1):'';
                return `<div class='border border-stone-200 rounded-lg p-3 bg-white text-xs flex flex-col gap-1'>
                    <div class='flex flex-wrap gap-3 items-center'><span class='font-semibold'>${i+1}</span><span class='font-mono'>${r.fecha}</span><span>Lote:<strong>${r.lote}</strong></span><span>${r.tipoMasa}${r.tipoPan? ' / '+r.tipoPan:''}</span><span>Dur:<strong>${formatTime(r.duracionSeg||0)}</strong></span><span>PerMid:${perMid}</span></div>
                    <div class='text-stone-600 break-words'>${(r.obs||'').replace(/</g,'&lt;')}</div>
                    <div class='flex justify-end gap-2 mt-1'>
                        <button class='mesa-enviar-bd bg-amber-600 text-white px-2 py-0.5 rounded text-[11px]' data-index='${all.indexOf(r)}'>Enviar BD</button>
                        <button class='mesa-borrar bg-red-600 text-white px-2 py-0.5 rounded text-[11px]' data-index='${all.indexOf(r)}'>Borrar</button>
                    </div>
                </div>`; }).join('');
        }
        document.getElementById('mesa-filtro-fecha')?.addEventListener('input', renderMesaResultadosLocales);
        document.getElementById('mesa-filtro-tipo')?.addEventListener('input', renderMesaResultadosLocales);
        document.getElementById('mesa-filtro-pan')?.addEventListener('input', renderMesaResultadosLocales);
        document.getElementById('mesa-borrar-locales')?.addEventListener('click', ()=>{ if(!confirm('¿Borrar todos los lotes locales de Mesa?')) return; localStorage.removeItem('mesaRegistros'); renderMesaResultadosLocales(); mesaRenderLista(); });
        document.getElementById('mesa-export-local-csv')?.addEventListener('click', ()=>{
            const data=mesaGet(); if(!data.length){ mostrarToast('Sin datos'); return; } const rows=data.map(r=>({Fecha:r.fecha,Lote:r.lote,TipoMasa:r.tipoMasa,TipoPan:r.tipoPan||'',Duracion_s:r.duracionSeg,Duracion_fmt:formatTime(r.duracionSeg||0),PerMin:r.perMin??'',PerMax:r.perMax??'',PerMid:(r.perMin!=null&&r.perMax!=null?((r.perMin+r.perMax)/2).toFixed(2):''),Obs:r.obs||''})); const csv=Papa.unparse(rows); const blob=new Blob([csv],{type:'text/csv'}); saveAs(blob,'mesa_local.csv');
        });
        document.getElementById('mesa-resultados-lista')?.addEventListener('click', async (e)=>{
            const del=e.target.closest('.mesa-borrar'); if(del){ const idx=parseInt(del.getAttribute('data-index')); let arr=mesaGet(); if(idx>=0){ arr.splice(idx,1); mesaSave(arr); renderMesaResultadosLocales(); mesaRenderLista(); } return; }
            const send=e.target.closest('.mesa-enviar-bd'); if(send){ const idx=parseInt(send.getAttribute('data-index')); const arr=mesaGet(); const reg=arr[idx]; if(!reg){ return; } try{ const payload={ fecha:reg.fecha, tipo:'mesa_lote', mesa:[reg] }; const base=resolveApiBase(); const r=await fetch(base+'/registros',{method:'POST', headers:apiHeaders(true), body:JSON.stringify(payload)}); if(!r.ok) throw new Error('HTTP '+r.status); mostrarToast('Enviado'); }catch(err){ mostrarToast('Error enviando','err'); } }
        });
        document.getElementById('mesa-enviar-todo-bd')?.addEventListener('click', async ()=>{
            const fecha=document.getElementById('mesa-filtro-fecha')?.value || document.getElementById('mesa-fecha')?.value; const status=document.getElementById('mesa-status'); if(!fecha){ status.textContent='Selecciona/filtra una fecha.'; status.className='text-xs text-red-600 text-center'; return; }
            const all=mesaGet().filter(r=> r.fecha===fecha); if(!all.length){ status.textContent='Sin lotes para esa fecha.'; status.className='text-xs text-stone-600 text-center'; return; }
            try{ const payload={ fecha, tipo:'mesa_lotes', mesa:all }; const base=resolveApiBase(); const r=await fetch(base+'/registros',{method:'POST', headers:apiHeaders(true), body:JSON.stringify(payload)}); if(!r.ok) throw new Error('HTTP '+r.status); status.textContent='Enviados '+all.length+' lotes'; status.className='text-xs text-green-600 text-center'; mostrarToast('Mesa fecha enviada'); }catch(e){ status.textContent='Error enviando: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
        });
        // ---- BD Mesa ----
        let MESA_BD_CACHE=[];
        async function loadMesaBD(){ const status=document.getElementById('mesa-status'); if(status) status.textContent='Cargando BD...'; try{ const base=resolveApiBase(); const params=[]; const d=document.getElementById('mesa-bd-desde')?.value; const h=document.getElementById('mesa-bd-hasta')?.value; if(d) params.push('desde='+encodeURIComponent(d)); if(h) params.push('hasta='+encodeURIComponent(h)); const url=base+'/registros'+(params.length?('?'+params.join('&')):''); const r=await fetch(url,{headers:apiHeaders(false)}); if(!r.ok) throw new Error('HTTP '+r.status); const arr=await r.json(); // Filtrar solo registros con campo mesa
                MESA_BD_CACHE = arr.filter(x=> Array.isArray(x.data?.mesa) && x.data.mesa.length);
                renderMesaResultadosBD(); }catch(e){ if(status) status.textContent='Error BD: '+(e.message||e); }
        }
        document.getElementById('mesa-bd-refresh')?.addEventListener('click', loadMesaBD);
        document.getElementById('mesa-bd-clear-filtros')?.addEventListener('click', ()=>{ ['mesa-bd-desde','mesa-bd-hasta','mesa-bd-fecha','mesa-bd-tipo','mesa-bd-pan'].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=''; }); loadMesaBD(); });
        ['mesa-bd-fecha','mesa-bd-tipo','mesa-bd-pan'].forEach(id=> document.getElementById(id)?.addEventListener('input', renderMesaResultadosBD));
        function renderMesaResultadosBD(){ const lista=document.getElementById('mesa-resultados-lista'); const status=document.getElementById('mesa-status'); const promDiv=document.getElementById('mesa-promedios'); if(!lista) return; const fFecha=document.getElementById('mesa-bd-fecha')?.value||''; const fTipo=(document.getElementById('mesa-bd-tipo')?.value||'').toLowerCase(); const fPan=(document.getElementById('mesa-bd-pan')?.value||'').toLowerCase(); let lotes=[]; MESA_BD_CACHE.forEach(r=> (r.data?.mesa||[]).forEach(m=> lotes.push({...m,fecha:r.data?.fecha||r.fecha||''}))); const filtrados=lotes.filter(r=> (!fFecha||r.fecha===fFecha) && (!fTipo||(r.tipoMasa||'').toLowerCase().includes(fTipo)) && (!fPan||(r.tipoPan||'').toLowerCase().includes(fPan)) ); if(status) status.textContent=`BD: ${filtrados.length} lote(s)`; const calc=mesaCalculosBasicos(filtrados); if(promDiv){ promDiv.innerHTML=calc.n?`Promedio: <strong>${formatTime(Math.round(calc.prom))}</strong> (±${formatTime(Math.round(calc.std))})`:'Sin datos'; } if(!filtrados.length){ lista.innerHTML='<div class="text-xs text-stone-500">Sin datos.</div>'; return;} lista.innerHTML=filtrados.map((r,i)=> `<div class='border border-stone-200 rounded-lg p-3 bg-white text-xs flex flex-col gap-1'><div class='flex flex-wrap gap-3 items-center'><span class='font-semibold'>${i+1}</span><span class='font-mono'>${r.fecha}</span><span>Lote:<strong>${r.lote}</strong></span><span>${r.tipoMasa}${r.tipoPan?' / '+r.tipoPan:''}</span><span>Dur:<strong>${formatTime(r.duracionSeg||0)}</strong></span></div><div class='text-stone-600 break-words'>${(r.obs||'').replace(/</g,'&lt;')}</div></div>`).join(''); }
        // ======================= Tablas Mesa =======================
        const mesaTablasFuenteSel=document.getElementById('mesa-tablas-fuente');
        mesaTablasFuenteSel?.addEventListener('change', ()=>{ localStorage.setItem('MESA_TABLAS_FUENTE', mesaTablasFuenteSel.value); buildMesaTablas(); });
        function mesaTable(headers, rows){ return `<table class='min-w-full border border-stone-300 text-[11px] bg-white rounded overflow-hidden'><thead class='bg-stone-100'><tr>${headers.map(h=>`<th class='px-2 py-1 border-b border-stone-300 text-left font-semibold'>${h}</th>`).join('')}</tr></thead><tbody>${rows.map((r,i)=>`<tr class='${i%2?'bg-stone-50':''}'>${r.map(c=>`<td class='px-2 py-1 border-b border-stone-200 font-mono'>${c}</td>`).join('')}</tr>`).join('')}</tbody></table>`; }
        let _MESA_TABLAS_DATA=[]; function mesaTablasData(){ return _MESA_TABLAS_DATA; }
        document.getElementById('mesa-tablas-refresh')?.addEventListener('click', buildMesaTablas);
        document.getElementById('mesa-tablas-clear')?.addEventListener('click', ()=>{ ['mesa-tablas-desde','mesa-tablas-hasta','mesa-tablas-tipo','mesa-tablas-pan'].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=''; }); buildMesaTablas(); });
        ['mesa-tablas-desde','mesa-tablas-hasta','mesa-tablas-tipo','mesa-tablas-pan'].forEach(id=> document.getElementById(id)?.addEventListener('change', buildMesaTablas));
        function buildMesaTablas(){ const status=document.getElementById('mesa-tablas-status'); const fuente=(mesaTablasFuenteSel?.value)||localStorage.getItem('MESA_TABLAS_FUENTE')||'local'; if(mesaTablasFuenteSel && mesaTablasFuenteSel.value!==fuente) mesaTablasFuenteSel.value=fuente; const filtrosBD=document.getElementById('mesa-tablas-filtros-bd'); filtrosBD?.classList.toggle('hidden', fuente!=='bd'); let datos=[]; if(fuente==='local'){ datos=mesaGet(); if(status) status.textContent=`Fuente: Locales (${datos.length})`; } else { (async()=>{ try{ const base=resolveApiBase(); const d=document.getElementById('mesa-tablas-desde')?.value; const h=document.getElementById('mesa-tablas-hasta')?.value; const params=[]; if(d) params.push('desde='+encodeURIComponent(d)); if(h) params.push('hasta='+encodeURIComponent(h)); const url=base+'/registros'+(params.length?('?'+params.join('&')):''); const r=await fetch(url,{headers:apiHeaders(false)}); if(!r.ok) throw new Error('HTTP '+r.status); const arr=await r.json(); datos=[]; arr.forEach(x=> (x.data?.mesa||[]).forEach(m=> datos.push({...m, fecha:x.data?.fecha||x.fecha||''}))); if(status) status.textContent=`Fuente: BD (${datos.length})`; _MESA_TABLAS_DATA=aplicarFiltrosMesaTablas(datos); renderMesaTablas(); }catch(e){ if(status) status.textContent='Error BD: '+(e.message||e); } })(); return; } _MESA_TABLAS_DATA=aplicarFiltrosMesaTablas(datos); renderMesaTablas(); }
        function aplicarFiltrosMesaTablas(datos){ const fTipo=(document.getElementById('mesa-tablas-tipo')?.value||'').toLowerCase(); const fPan=(document.getElementById('mesa-tablas-pan')?.value||'').toLowerCase(); return datos.filter(r=> (!fTipo||(r.tipoMasa||'').toLowerCase().includes(fTipo)) && (!fPan||(r.tipoPan||'').toLowerCase().includes(fPan)) ); }
        function renderMesaTablas(){ const datos=mesaTablasData(); const resumenEl=document.getElementById('mesa-tabla-resumen'); if(!resumenEl) return; if(!datos.length){ resumenEl.innerHTML='<div class="text-xs text-stone-500">Sin datos</div>'; ['mesa-tabla-tipo-masa','mesa-tabla-tipo-pan','mesa-boxplot-stats'].forEach(id=>{ const el=document.getElementById(id); if(el) el.innerHTML=''; }); return; } function prom(a){ return a.length?a.reduce((x,y)=>x+y,0)/a.length:0;} function std(a){ if(a.length<2) return 0; const m=prom(a); return Math.sqrt(a.reduce((s,v)=>s+(v-m)**2,0)/a.length); } const arr=datos.map(d=>d.duracionSeg||0); const promG=prom(arr); const stdG=std(arr); const resumenRows=[['Registros',datos.length],['Promedio (s)',Math.round(promG)],['Desv (s)',Math.round(stdG)],['%Desv', (stdG/promG*100).toFixed(1)+'%']]; resumenEl.innerHTML=mesaTable(['Métrica','Valor'],resumenRows); // por tipo masa
            const porTipo={}; const porPan={}; const porSemana={}; datos.forEach(d=>{ (porTipo[d.tipoMasa]=porTipo[d.tipoMasa]||[]).push(d.duracionSeg||0); if(d.tipoPan) (porPan[d.tipoPan]=porPan[d.tipoPan]||[]).push(d.duracionSeg||0); if(d.fecha){ const [Y,M,D]=d.fecha.split('-').map(Number); const dt=new Date(Y,M-1,D); const dow=dt.getDay()||7; dt.setDate(dt.getDate()+4-dow); const yearStart=new Date(dt.getFullYear(),0,1); const wk=Math.ceil((((dt - yearStart)/86400000)+1)/7); const key=dt.getFullYear()+'-W'+String(wk).padStart(2,'0'); (porSemana[key]=porSemana[key]||[]).push(d.duracionSeg||0);} });
            const tipoRows=Object.entries(porTipo).map(([k,v])=>[k,v.length,Math.round(prom(v)),Math.round(std(v)), ((std(v)/prom(v))*100).toFixed(1)+'%']); document.getElementById('mesa-tabla-tipo-masa').innerHTML=mesaTable(['Tipo masa','N','Prom (s)','Desv (s)','%Desv'],tipoRows);
            const panRows=Object.entries(porPan).map(([k,v])=>[k,v.length,Math.round(prom(v)),Math.round(std(v)), ((std(v)/prom(v))*100).toFixed(1)+'%']); document.getElementById('mesa-tabla-tipo-pan').innerHTML=panRows.length? mesaTable(['Tipo pan','N','Prom (s)','Desv (s)','%Desv'],panRows):'<div class="text-xs text-stone-500">Sin datos (solo Tradicional)</div>';
            // Charts básicos
            try{ if(window.Chart){ const palette=['#2563eb','#16a34a','#f59e0b','#dc2626','#7c3aed','#0d9488','#d946ef']; const ctx1=document.getElementById('mesa-chart-tipo-masa'); if(ctx1){ new Chart(ctx1,{type:'bar',data:{labels:tipoRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:tipoRows.map(r=>r[2]),backgroundColor:palette}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}}); } const ctx2=document.getElementById('mesa-chart-tipo-pan'); if(ctx2 && panRows.length){ new Chart(ctx2,{type:'bar',data:{labels:panRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:panRows.map(r=>r[2]),backgroundColor:palette}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}}); }
                // Boxplot simple (custom)
                const boxCanvas=document.getElementById('mesa-chart-boxplot'); const boxStatsDiv=document.getElementById('mesa-boxplot-stats'); if(boxCanvas){ const stats=Object.entries(porTipo).map(([k,vals])=>{ const s=vals.slice().sort((a,b)=>a-b); const q=p=>{ const pos=(s.length-1)*p; const b=Math.floor(pos); const r=pos-b; return r? s[b]+(s[b+1]-s[b])*r: s[b]; }; return {tipo:k,n:s.length,min:s[0],q1:q(0.25),med:q(0.5),q3:q(0.75),max:s[s.length-1]}; }); if(boxStatsDiv){ boxStatsDiv.innerHTML=mesaTable(['Tipo','n','min','Q1','Med','Q3','max'], stats.map(o=>[o.tipo,o.n,o.min,o.q1.toFixed(0),o.med.toFixed(0),o.q3.toFixed(0),o.max])); } new Chart(boxCanvas,{type:'scatter',data:{labels:stats.map(s=>s.tipo),datasets:[{label:'med',data:stats.map((s,i)=>({x:i,y:s.med})),pointRadius:0}]},options:{plugins:{legend:{display:false}},scales:{x:{type:'category',labels:stats.map(s=>s.tipo)},y:{beginAtZero:true}}},plugins:[{id:'mesaBox',afterDraw(c){ const {ctx,scales:{x,y}}=c; stats.forEach((s,i)=>{ const center=x.getPixelForValue(i); const next=x.getPixelForValue(i+1); const prev=x.getPixelForValue(i-1); const gap=(next?next-center: (prev? center-prev:60)); const boxW=Math.min(70,Math.max(40,gap*1.1)); const yMin=y.getPixelForValue(s.min), yQ1=y.getPixelForValue(s.q1), yMed=y.getPixelForValue(s.med), yQ3=y.getPixelForValue(s.q3), yMax=y.getPixelForValue(s.max); ctx.save(); ctx.strokeStyle='#475569'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(center,yMin); ctx.lineTo(center,yQ1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center,yQ3); ctx.lineTo(center,yMax); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center-10,yMin); ctx.lineTo(center+10,yMin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center-10,yMax); ctx.lineTo(center+10,yMax); ctx.stroke(); ctx.fillStyle='rgba(59,130,246,0.16)'; ctx.strokeStyle='#2563eb'; ctx.beginPath(); ctx.rect(center-boxW/2,yQ3,boxW,yQ1-yQ3); ctx.fill(); ctx.stroke(); ctx.strokeStyle='#dc2626'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(center-boxW/2,yMed); ctx.lineTo(center+boxW/2,yMed); ctx.stroke(); ctx.restore(); }); }}]}); }
                // Histograma
                const histCanvas=document.getElementById('mesa-chart-hist'); if(histCanvas){ const max=Math.max(...arr); const bins=Math.min(15, Math.max(5, Math.round(Math.sqrt(arr.length)))); const binSize=Math.max(1, Math.ceil(max/bins)); const counts=new Array(bins).fill(0); arr.forEach(v=>{ const idx=Math.min(bins-1, Math.floor(v/binSize)); counts[idx]++; }); const labels=counts.map((_,i)=> `${i*binSize}-${(i+1)*binSize-1}`); new Chart(histCanvas,{type:'bar',data:{labels,datasets:[{label:'Frecuencia',data:counts,backgroundColor:'#94a3b8'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}}); }
                // Tendencia semanal
                const semCanvas=document.getElementById('mesa-chart-semanal'); if(semCanvas){ const semKeys=Object.keys(porSemana).sort(); const semProm=semKeys.map(k=> prom(porSemana[k])); new Chart(semCanvas,{type:'line',data:{labels:semKeys,datasets:[{label:'Prom (s)',data:semProm,fill:false,borderColor:'#2563eb',tension:0.15}]},options:{responsive:true,plugins:{legend:{position:'bottom'}},scales:{y:{beginAtZero:true}}}}); }
                // Scatter personal midpoint vs duración
                const perCanvas = document.getElementById('mesa-chart-scatter-personal');
                if (perCanvas) {
                    const tienePersonal = datos.some(d => d.perMin != null && d.perMax != null);
                    if (tienePersonal) {
                        const points = datos
                            .filter(d => d.perMin != null && d.perMax != null)
                            .map(d => ({ x: (d.perMin + d.perMax) / 2, y: d.duracionSeg || 0 }));
                        new Chart(perCanvas, {
                            type: 'scatter',
                            data: {
                                datasets: [{
                                    label: 'Mid vs Dur',
                                    data: points,
                                    backgroundColor: '#16a34a'
                                }]
                            },
                            options: {
                                responsive: true,
                                scales: {
                                    x: { title: { display: true, text: 'Personal midpoint' } },
                                    y: { title: { display: true, text: 'Duración (s)' }, beginAtZero: true }
                                },
                                plugins: { legend: { position: 'bottom' } }
                            }
                        });
                    }
                }
            } }catch(_){ /* ignore chart errors */ }
        }
        document.getElementById('mesa-tablas-export-csv')?.addEventListener('click', ()=>{ const datos=mesaTablasData(); if(!datos.length){ alert('Sin datos'); return; } const rows=[['Fecha','Lote','TipoMasa','TipoPan','Duracion(s)','PerMin','PerMax','Obs']]; datos.forEach(d=> rows.push([d.fecha||'',d.lote||'',d.tipoMasa||'',d.tipoPan||'',d.duracionSeg||'',d.perMin??'',d.perMax??'',(d.obs||'').replace(/\n/g,' ') ])); const csv=rows.map(r=> r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='mesa_tablas.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),500); });
        // Auto build inicial
        buildMesaTablas();
        // =================================================================
        // Settings bindings
        const settingsApiUrl = document.getElementById('settings-api-url');
        const settingsSaveApi = document.getElementById('settings-save-api');
    const settingsApiKey = document.getElementById('settings-api-key');
    const settingsRememberKey = document.getElementById('settings-remember-key');
    const settingsSaveKey = document.getElementById('settings-save-key');
        if(settingsApiUrl){ settingsApiUrl.value = localStorage.getItem('API_URL_OVERRIDE')||''; }
        settingsSaveApi?.addEventListener('click', ()=>{
            const v = (settingsApiUrl?.value||'').trim();
            if(v){ localStorage.setItem('API_URL_OVERRIDE', v); mostrarToast('URL API guardada'); }
            else { localStorage.removeItem('API_URL_OVERRIDE'); mostrarToast('URL API borrada'); }
        });
        settingsSaveKey?.addEventListener('click', async ()=>{
            const k = settingsApiKey?.value||'';
            const remember = !!settingsRememberKey?.checked;
            const statusEl = document.getElementById('settings-key-status');
            if(statusEl) statusEl.textContent='';
            if(k){ sessionStorage.setItem('API_KEY', k); if(remember) localStorage.setItem('API_KEY_PERSIST', k); else localStorage.removeItem('API_KEY_PERSIST'); mostrarToast('Clave API guardada'); }
            else { sessionStorage.removeItem('API_KEY'); localStorage.removeItem('API_KEY_PERSIST'); mostrarToast('Clave API borrada'); }
            try{
                const base=resolveApiBase();
                const r=await fetch(base + '/registros?limit=1',{ headers: apiHeaders(false) });
                if(r.ok){ if(statusEl){statusEl.textContent='Clave verificada ✅'; statusEl.className='mt-2 text-sm text-emerald-700';} }
                else { const msg = (r.status===401||r.status===403)?'Clave inválida ❌':'Error: HTTP '+r.status; if(statusEl){statusEl.textContent=msg; statusEl.className='mt-2 text-sm text-red-600';} }
            }catch(e){ if(statusEl){ statusEl.textContent='Error de red al verificar clave'; statusEl.className='mt-2 text-sm text-red-600'; } }
        });
        // Toggle mostrar/ocultar API key
        const toggleBtn = document.getElementById('settings-api-toggle');
        if(toggleBtn && settingsApiKey){
            toggleBtn.addEventListener('click', ()=>{
                const isPwd = settingsApiKey.type === 'password';
                settingsApiKey.type = isPwd ? 'text' : 'password';
                toggleBtn.textContent = isPwd ? 'Ocultar' : 'Mostrar';
            });
        }
        if (typeof createMachineCards === 'function') createMachineCards();

        // Listeners de pestañas seguros
        if (tabMedicion) tabMedicion.addEventListener('click', () => {
            sectionAmas?.classList.remove('hidden');
            if (!viewMedicion) return;
            viewMedicion.classList.remove('hidden');
            viewResultados.classList.add('hidden');
            viewTablas.classList.add('hidden');
            tabMedicion.classList.add('tab-btn-active');
            tabResultados.classList.remove('tab-btn-active');
            tabTablas.classList.remove('tab-btn-active');
            try{ document.getElementById('section-amasadoras')?.scrollIntoView({behavior:'smooth', block:'start'});}catch(_){ }
            if (typeof createMachineCards === 'function') createMachineCards();
        });
        if (tabResultados) tabResultados.addEventListener('click', () => {
            sectionAmas?.classList.remove('hidden');
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.remove('hidden');
            viewTablas?.classList.add('hidden');
            tabResultados.classList.add('tab-btn-active');
            tabMedicion?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
            try{ document.getElementById('view-resultados')?.scrollIntoView({behavior:'smooth', block:'start'});}catch(_){ }
            if (typeof cargarResultados === 'function') cargarResultados();
        });
        if (tabTablas) tabTablas.addEventListener('click', () => {
            sectionAmas?.classList.remove('hidden');
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.remove('hidden');
            tabTablas.classList.add('tab-btn-active');
            tabMedicion?.classList.remove('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            try{ document.getElementById('view-tablas')?.scrollIntoView({behavior:'smooth', block:'start'});}catch(_){ }
            if (typeof buildTablasVista === 'function') buildTablasVista();
        });
    });

    // ================= TABLAS Y GRAFICOS =================
    let chartsCache = [];
    function destroyCharts(){ chartsCache.forEach(c=>{try{c.destroy();}catch(_){}}); chartsCache=[]; }
    function fmt(n){return typeof n==='number'&&!isNaN(n)?n:0;}
    function std(arr){ if(!arr.length) return 0; const m=arr.reduce((a,b)=>a+b,0)/arr.length; return Math.sqrt(arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length);} 
    function percent(a,b){ return b? (a*100/b).toFixed(1)+'%':'0%'; }
    function tableFromRows(headers, rows){
        return `<table class='min-w-full border border-stone-300 text-xs md:text-sm bg-white rounded-lg overflow-hidden'><thead class='bg-stone-100 text-stone-700'><tr>${headers.map(h=>`<th class='px-3 py-2 border-b border-stone-300 text-left font-semibold'>${h}</th>`).join('')}</tr></thead><tbody>${rows.map((r,i)=>`<tr class='${i%2?'bg-stone-50':''}'>${r.map(c=>`<td class='px-3 py-1 border-b border-stone-200 font-mono'>${c}</td>`).join('')}</tr>`).join('')}</tbody></table>`;
    }
    let _TABLAS_DATA_LAST = [];
    function getTablasData(){ return _TABLAS_DATA_LAST; }
    async function buildTablasVista(){
        destroyCharts();
        const fuenteSel = document.getElementById('tablas-source');
        const statusEl = document.getElementById('tablas-status');
        const bdCtrls = document.getElementById('tablas-bd-controls');
        const desdeInput = document.getElementById('tablas-bd-desde');
        const hastaInput = document.getElementById('tablas-bd-hasta');
        const loteInput = document.getElementById('tablas-bd-lote');
        const tipoInput = document.getElementById('tablas-bd-tipo');
        let fuente = (localStorage.getItem('TABLAS_SOURCE')||'local');
        if(fuenteSel){
            if(!fuenteSel.value) fuenteSel.value = fuente; else fuente = fuenteSel.value;
        }
        localStorage.setItem('TABLAS_SOURCE', fuente);
    if(bdCtrls){ bdCtrls.classList.toggle('hidden', fuente !== 'bd'); }
    // Ajustar etiquetas de export segun fuente
    const btnPdf=document.getElementById('tablas-export-pdf');
    const btnCsv=document.getElementById('tablas-export-csv');
    if(btnPdf) btnPdf.textContent = `Exportar (${fuente==='bd'?'BD':'Locales'}) PDF`;
    if(btnCsv) btnCsv.textContent = `Exportar (${fuente==='bd'?'BD':'Locales'}) CSV`;
    // Leer filtros persistidos
    let fDesde = localStorage.getItem('TABLAS_BD_DESDE')||'';
    let fHasta = localStorage.getItem('TABLAS_BD_HASTA')||'';
    let fLote = localStorage.getItem('TABLAS_BD_LOTE')||'';
    let fTipo = localStorage.getItem('TABLAS_BD_TIPO')||'';
    if(desdeInput){ if(!desdeInput.value && fDesde) desdeInput.value=fDesde; else fDesde=desdeInput.value||''; }
    if(hastaInput){ if(!hastaInput.value && fHasta) hastaInput.value=fHasta; else fHasta=hastaInput.value||''; }
    if(loteInput){ if(!loteInput.value && fLote) loteInput.value=fLote; else fLote=loteInput.value||''; }
    if(tipoInput){ if(!tipoInput.value && fTipo) tipoInput.value=fTipo; else fTipo=tipoInput.value||''; }
        let datos = [];
        if(statusEl) statusEl.textContent = '';
        if(fuente === 'local'){
            try { datos = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]') || []; } catch(_) { datos = []; }
            if(statusEl) statusEl.textContent = `Fuente: Locales · ${datos.length} registros.`;
        } else {
            const base = resolveApiBase();
            if(statusEl) statusEl.textContent = 'Cargando datos de la BD...';
            try{
                // Prefer server-side filters when available: desde/hasta
                let q = [];
                if(fDesde) q.push('desde='+encodeURIComponent(fDesde));
                if(fHasta) q.push('hasta='+encodeURIComponent(fHasta));
                const url = base + '/registros' + (q.length? ('?'+q.join('&')) : '');
                const r = await fetch(url, { headers: apiHeaders(false) });
                if(!r.ok) throw new Error('HTTP '+r.status);
                const arr = await r.json();
                const total = Array.isArray(arr)? arr.length: 0;
                let arrFiltrado = Array.isArray(arr)? arr: [];
                    // Mantener filtros extra en cliente (lote/tipo) y como respaldo si API no filtra fecha
                    if(fDesde){ arrFiltrado = arrFiltrado.filter(it=> (it.data?.fecha||it.fecha||'') >= fDesde); }
                    if(fHasta){ arrFiltrado = arrFiltrado.filter(it=> (it.data?.fecha||it.fecha||'') <= fHasta); }
                if(fLote){ arrFiltrado = arrFiltrado.filter(it=> (it.data?.amasadoras||[]).some(m=> (m.lote||'').toString().includes(fLote))); }
                if(fTipo){ const fx=fTipo.toLowerCase(); arrFiltrado = arrFiltrado.filter(it=> (it.data?.amasadoras||[]).some(m=> ((m.tipoMasa||m.tipoPan||'').toLowerCase().includes(fx)))); }
                // Normalizar 'Bs.' -> 'Mant.' también en datos remotos (si la API aún tiene registros antiguos)
                try { if(window.__normalizeTipoMasaMant) window.__normalizeTipoMasaMant(arrFiltrado.map(r=> r.data ? r.data : r)); } catch(_){ }
                // Normalizar cada amasadora: si viene como 'procesos'[] mapear a proceso1..3
                function normalizeMaq(m){
                    if(!m) return m;
                    const n = { ...m };
                    if(Array.isArray(m.procesos) && (!m.proceso1 || !m.proceso2 || !m.proceso3)){
                        const p1 = m.procesos.find(p=> String(p.id)==='1');
                        const p2 = m.procesos.find(p=> String(p.id)==='2');
                        const p3 = m.procesos.find(p=> String(p.id)==='3');
                        const mk = (p)=> p? ({
                            minutos: parseInt(p.minutos)||0,
                            segundos: parseInt(p.segundos)||0,
                            startTime: p.startTime||null,
                            endTime: p.endTime||null
                        }): undefined;
                        if(p1) n.proceso1 = mk(p1);
                        if(p2) n.proceso2 = mk(p2);
                        if(p3) n.proceso3 = mk(p3);
                    }
                    return n;
                }
                datos = (arrFiltrado||[]).map(it=>({
                    fecha: it.data?.fecha || it.fecha,
                    personalMin: parseInt(it.data?.personalMin ?? it.data?.personal_min ?? it.data?.personal?.min) || undefined,
                    personalMax: parseInt(it.data?.personalMax ?? it.data?.personal_max ?? it.data?.personal?.max) || undefined,
                    maquinas: Array.isArray(it.data?.amasadoras)? it.data.amasadoras.map(normalizeMaq) : []
                }));
                const filtrosAct = [fDesde?`Desde ${fDesde}`:'', fHasta?`Hasta ${fHasta}`:'', fLote?`Lote ${fLote}`:'', fTipo?`Tipo ${fTipo}`:''].filter(Boolean).join(' · ');
                if(statusEl) statusEl.textContent = `Fuente: BD · ${datos.length} registros${filtrosAct?` (filtros: ${filtrosAct})`:''}. Total disponibles: ${total}.`;
            }catch(e){
                const msg = 'Error cargando BD: ' + (e.message||e);
                if(statusEl) statusEl.textContent = msg;
                ['tabla-resumen','tabla-pan','tabla-amasadora','tabla-proceso','tabla-temp','tabla-temp-cruzada','tabla-personal-dia','tabla-ta-h-dia'].forEach(id=>{const el=document.getElementById(id); if(el) el.innerHTML='<div class="text-red-600">'+msg+'</div>';});
                return;
            }
        }
    // Aplicar filtro día si está activado (para que tablas y gráficas reflejen la selección de la lista de fechas)
    const _modoFechaSel = localStorage.getItem('TABLAS_FECHA_MODO');
    const _diaSel = localStorage.getItem('TABLAS_BD_DIA');
    let datosParaMostrar = datos;
    if(_modoFechaSel==='dia' && _diaSel){ datosParaMostrar = datos.filter(r=> r.fecha === _diaSel); }
    _TABLAS_DATA_LAST = datosParaMostrar;
    // Construir lista de fechas (si existe contenedor)
        try{
            const fechasList = document.getElementById('tablas-fechas-list');
            const fechasDetalle = document.getElementById('tablas-fechas-detalle');
            const fechasTotal = document.getElementById('tablas-fechas-total');
            if(fechasList){
                const mapa={};
                datos.forEach(r=>{ if(r.fecha){ mapa[r.fecha] = (mapa[r.fecha]||0) + (r.maquinas? r.maquinas.length:0); } });
                const fechas = Object.keys(mapa).sort();
                fechasList.innerHTML = fechas.map(f=>{
                    const activo = (_modoFechaSel==='dia' && _diaSel===f);
                    return `<button data-fecha="${f}" class="px-3 py-1 text-xs rounded-full border ${activo?'bg-blue-600 text-white border-blue-600 shadow':'border-stone-300 bg-white hover:bg-blue-50 hover:border-blue-400'} transition flex items-center gap-1">${f}<span class='inline-block text-[10px] px-1 rounded ${activo?'bg-white/20 text-white':'bg-stone-200 text-stone-700'}'>${mapa[f]}</span></button>`;
                }).join('');
                if(fechasTotal) fechasTotal.textContent = `(${fechas.length})`;
                fechasList.querySelectorAll('button[data-fecha]').forEach(btn=>{
                    btn.addEventListener('click', ()=>{
                        const f = btn.getAttribute('data-fecha');
                        localStorage.setItem('TABLAS_FECHA_MODO','dia');
                        localStorage.setItem('TABLAS_BD_DIA', f);
                        const modoSelEl=document.getElementById('tablas-fecha-modo'); if(modoSelEl) modoSelEl.value='dia';
                        const diaInputEl=document.getElementById('tablas-dia'); if(diaInputEl) diaInputEl.value=f;
                        buildTablasVista();
                    });
                });
                if(fechasDetalle){
                    const modoActual = localStorage.getItem('TABLAS_FECHA_MODO')||'rango';
                    const fechaDia = localStorage.getItem('TABLAS_BD_DIA')||'';
                    if(modoActual==='dia' && fechaDia){
                        const registrosDia = datos.filter(r=> r.fecha===fechaDia);
                        const totalMaq = registrosDia.reduce((a,r)=> a + (r.maquinas? r.maquinas.length:0), 0);
                        const tipos={}; registrosDia.forEach(r=> (r.maquinas||[]).forEach(m=>{ const t=m.tipoMasa||m.tipoPan||'Sin tipo'; tipos[t]=(tipos[t]||0)+1; }));
                        fechasDetalle.classList.remove('hidden');
                        fechasDetalle.innerHTML = `<div class='p-3 border border-blue-200 bg-blue-50 rounded-lg text-xs'><div class='font-semibold mb-1'>Detalle ${fechaDia}</div><div>Total registros: <strong>${registrosDia.length}</strong> · Total máquinas: <strong>${totalMaq}</strong></div><div class='mt-1 flex flex-wrap gap-2'>${Object.keys(tipos).map(t=>`<span class='px-2 py-0.5 rounded bg-white border border-stone-300'>${t}: ${tipos[t]}</span>`).join('')||'<em>Sin tipos</em>'}</div><button id='tablas-fechas-volver' class='mt-2 text-[11px] underline text-blue-700'>Ver todas las fechas</button></div>`;
                        fechasDetalle.querySelector('#tablas-fechas-volver')?.addEventListener('click', ()=>{
                            localStorage.setItem('TABLAS_FECHA_MODO','rango');
                            localStorage.removeItem('TABLAS_BD_DIA');
                            const modoSelEl2=document.getElementById('tablas-fecha-modo'); if(modoSelEl2) modoSelEl2.value='rango';
                            buildTablasVista();
                        });
                    } else { fechasDetalle.classList.add('hidden'); fechasDetalle.innerHTML=''; }
                }
            }
        }catch(_){ }
        if(!_TABLAS_DATA_LAST.length){
            ['tabla-resumen','tabla-pan','tabla-amasadora','tabla-proceso','tabla-temp','tabla-temp-cruzada','tabla-personal-dia','tabla-ta-h-dia'].forEach(id=>{const el=document.getElementById(id); if(el) el.innerHTML='<div class="text-stone-500">Sin datos</div>';});
            return;
        }
        // Estructuras
        const procesosNombres=['Esponja','Masa','Mantequilla'];
        let totalGenerales=[]; let procesoStats=[[],[],[]];
    let masaStats={}, amasadoraStats={}, tempMasaStats={}, tempCrossRaw=[];
    let globalRealSum=0, globalProdSum=0, globalMuertoSum=0;
    _TABLAS_DATA_LAST.forEach(reg=>{
            (reg.maquinas||[]).forEach(maq=>{
                // total máquina (primer start a último end)
                const p1=maq.proceso1, p3=maq.proceso3;
                if(p1&&p1.startTime && p3 && p3.endTime){
                    const total = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
                    totalGenerales.push(total);
                }
                for(let i=1;i<=3;i++){
                    const p=maq['proceso'+i];
                    if(p){ const t=(parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0); procesoStats[i-1].push(t); }
                }
                const tipo=maq.tipoMasa||maq.tipoPan||'Sin tipo';
                // Normalizar clave de amasadora: usar numeroAmasadora o dígitos de nombre/id; limitar a '1','2','3' o '?' si desconocido
                const amaNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.id||'').match(/\d+/)?.[0]);
                const ama = (amaNumRaw && ['1','2','3'].includes(String(amaNumRaw))) ? String(amaNumRaw) : (amaNumRaw ? String(amaNumRaw) : '?');
                let totalSimple = 0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ totalSimple += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0);} }
                (masaStats[tipo]=masaStats[tipo]||[]).push(totalSimple);
                (amasadoraStats[ama]=amasadoraStats[ama]||[]).push(totalSimple);
                const tm = parseFloat(maq.tempMasa); if(!isNaN(tm)) { (tempMasaStats[tipo]=tempMasaStats[tipo]||[]).push(tm); tempCrossRaw.push({tipo, ama, tm}); }
                if(p1&&p1.startTime && p3 && p3.endTime){
                    const real = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
                    globalRealSum += real;
                    globalProdSum += totalSimple;
                    globalMuertoSum += Math.max(0, real - totalSimple);
                }
            });
        });
        /* ================= PATRONES POR LOTE (% MUERTO) =================
           Construir ranking de lotes con mayor y menor % de tiempo muerto
           y detectar factores comunes: tipoMasa, hielo, amasadora, rango tempMasa.
        */
    (function calcularPatronesLote(){
            const panel = document.getElementById('patrones-lote-panel');
            const statusEl = document.getElementById('patrones-lote-status');
            if(!panel) return; // si no existe sección, salir
            let muestras=[]; // {lote, pctMuerto, tipo, hielo, ama, tempMasa}
            _TABLAS_DATA_LAST.forEach(reg=>{
                (reg.maquinas||[]).forEach(maq=>{
                    const p1=maq.proceso1, p3=maq.proceso3; if(!(p1&&p1.startTime&&p3&&p3.endTime)) return;
                    let sumaProc=0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ sumaProc += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0); } }
                    const real = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)); if(!real) return;
                    const pctMuerto = Math.max(0, real - sumaProc) * 100 / real;
                    // Personal bucket
                    const pers = (parseInt(maq.personal)||parseInt(maq.personalMax)||parseInt(maq.personalMin)||parseInt(reg.personalMax)||parseInt(reg.personalMin))||NaN;
                    let personalBucket=null; if(Number.isFinite(pers)){ if(pers<=4) personalBucket='≤4'; else if(pers<=6) personalBucket='5–6'; else personalBucket='≥7'; }
                    muestras.push({
                        lote: (maq.lote||'').toString().trim()||'_sin_',
                        pctMuerto,
                        tipo: (maq.tipoMasa||maq.tipoPan||'Sin tipo').trim(),
                        hielo: (maq.hielo||'').trim()||'No?',
                        ama: (maq.numeroAmasadora||maq.id||'?'),
                        tempMasa: parseFloat(maq.tempMasa),
                        personalBucket
                    });
                });
            });
            if(!muestras.length){ panel.innerHTML='<div class="text-stone-500 text-xs">Sin datos suficientes.</div>'; if(statusEl) statusEl.textContent=''; return; }
            // Agrupar por lote
            const byLote={}; muestras.forEach(m=>{ (byLote[m.lote]=byLote[m.lote]||[]).push(m); });
            const lotesArr = Object.entries(byLote).map(([lote, arr])=>{
                const pctProm = arr.reduce((a,b)=>a+b.pctMuerto,0)/arr.length;
                return { lote, n:arr.length, pctProm, arr };
            }).filter(o=> o.n>=1);
            if(lotesArr.length<2){ panel.innerHTML='<div class="text-stone-500 text-xs">Muy pocos lotes.</div>'; if(statusEl) statusEl.textContent=''; return; }
            lotesArr.sort((a,b)=> b.pctProm - a.pctProm);
            const topNInput=document.getElementById('patrones-lote-topN');
            const minXLoteInput=document.getElementById('patrones-lote-minN');
            let N = parseInt(topNInput?.value||'3'); if(isNaN(N)||N<2) N=3; if(N>10) N=10; if(topNInput && topNInput.value!=N) topNInput.value=N;
            let minXLote = parseInt(minXLoteInput?.value||'1'); if(isNaN(minXLote)||minXLote<1) minXLote=1; if(minXLoteInput && minXLoteInput.value!=minXLote) minXLoteInput.value=minXLote;
            const lotesValidos = lotesArr.filter(l=> l.n>=minXLote);
            if(lotesValidos.length<2){ panel.innerHTML='<div class="text-stone-500 text-xs">No hay lotes que cumplan el mínimo.</div>'; if(statusEl) statusEl.textContent=''; return; }
            const altos = lotesValidos.slice(0,N);
            const bajos = lotesValidos.slice(-N).reverse();
            function factoresComunes(grupo){
                if(!grupo.length) return {};
                // Flatten muestras
                const all = grupo.flatMap(g=> g.arr);
                function modo(campo){
                    const map={}; all.forEach(m=>{ const v=m[campo]; map[v]=(map[v]||0)+1; });
                    const entries=Object.entries(map).sort((a,b)=> b[1]-a[1]);
                    const top=entries[0];
                    return top? {valor:top[0], freq:top[1], pct: top[1]*100/all.length}: null;
                }
                function rangoTemp(){
                    const temps = all.map(m=>m.tempMasa).filter(v=>Number.isFinite(v));
                    if(temps.length<2) return null;
                    temps.sort((a,b)=>a-b);
                    const p=x=> temps[Math.floor(x*(temps.length-1))];
                    return {min:temps[0], p25:p(0.25), med:p(0.5), p75:p(0.75), max:temps[temps.length-1]};
                }
                return {
                    tipo: modo('tipo'),
                    hielo: modo('hielo'),
                    ama: modo('ama'),
                    personal: modo('personalBucket'),
                    temp: rangoTemp()
                };
            }
            const comunesAltos = factoresComunes(altos);
            const comunesBajos = factoresComunes(bajos);
            function badgeFactor(label, dat){
                if(!dat) return `<span class='px-2 py-0.5 rounded bg-stone-200 text-stone-700'>${label}: n/d</span>`;
                return `<span class='px-2 py-0.5 rounded bg-white border border-stone-300'>${label}: <strong>${dat.valor}</strong> <span class='text-[10px] text-stone-500'>${dat.freq}/${(dat.pct).toFixed(0)}%</span></span>`;
            }
            function bloque(title, lotes, comunes, color){
                return `<div class='flex-1 min-w-[260px] border rounded-lg p-3 ${color}'>
                    <div class='text-[11px] font-semibold mb-1 uppercase tracking-wide'>${title}</div>
                    <div class='text-[11px] mb-2'>${lotes.map(l=>`<span class='inline-block mr-1 mb-1 px-2 py-0.5 rounded bg-stone-800 text-white'>Lote ${l.lote} · ${(l.pctProm).toFixed(1)}% (${l.n})</span>`).join('')||'<em>n/d</em>'}</div>
                    <div class='flex flex-wrap gap-1 mb-2'>
                        ${badgeFactor('Tipo', comunes.tipo)}
                        ${badgeFactor('Hielo', comunes.hielo)}
                        ${badgeFactor('Amas', comunes.ama)}
                        ${badgeFactor('Personal', comunes.personal)}
                    </div>
                    <div class='text-[10px] text-stone-600'>${comunes.temp?`Temp masa (°C) rango: ${comunes.temp.min.toFixed(1)}–${comunes.temp.max.toFixed(1)} (P50=${comunes.temp.med.toFixed(1)})`: 'Temp masa: n/d'}</div>
                </div>`;
            }
            panel.innerHTML = `<div class='flex flex-wrap gap-4'>${
                bloque('Más alto % muerto', altos, comunesAltos, 'bg-rose-50 border-rose-200') +
                bloque('Más bajo % muerto', bajos, comunesBajos, 'bg-emerald-50 border-emerald-200')
            }</div>`;
            if(statusEl){
                const promAltos = altos.reduce((a,b)=>a+b.pctProm,0)/altos.length;
                const promBajos = bajos.reduce((a,b)=>a+b.pctProm,0)/bajos.length;
                statusEl.textContent = `Δ promedio = ${(promAltos-promBajos).toFixed(1)} pts (% muerto)`;
            }
            // CSV export lotes extremos
            function exportLotes(){
                const rows=[["grupo","lote","n_maquinas","pct_muerto_prom","factor_tipo_dominante","factor_hielo_dominante","factor_ama_dominante","factor_personal_dominante"]];
                function dom(f){ return f && f.valor? f.valor: ''; }
                altos.forEach(l=> rows.push(['ALTO', l.lote, l.n, l.pctProm.toFixed(2), dom(comunesAltos.tipo), dom(comunesAltos.hielo), dom(comunesAltos.ama), dom(comunesAltos.personal)]));
                bajos.forEach(l=> rows.push(['BAJO', l.lote, l.n, l.pctProm.toFixed(2), dom(comunesBajos.tipo), dom(comunesBajos.hielo), dom(comunesBajos.ama), dom(comunesBajos.personal)]));
                const csv=rows.map(r=> r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
                const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='patrones_lotes_extremos.csv'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
            }
            // CSV export global (desde renderPatrones ya pintado)
            function exportGlobal(){
                try{
                    const anal=analizarPatrones();
                    const rows=[['factor','grupo','n','pct_muerto','prod','score','delta_pct_muerto_rel','delta_prod_rel']];
                    (anal.factores||[]).forEach(f=>{
                        (f.grupos||[]).forEach(g=>{
                            rows.push([f.campo.replace('__b_',''), g.valor, g.n, g.pctAvg.toFixed(2), (g.ratioAvg*100).toFixed(2), g.score.toFixed(3), (g.mejoraMuerto*100).toFixed(2), (g.mejoraProd*100).toFixed(2)]);
                        });
                    });
                    const csv=rows.map(r=> r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
                    const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='patrones_globales.csv'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },0);
                }catch(e){ alert('Error exportando global: '+e); }
            }
            // Wire buttons
            const btnAll=document.getElementById('patrones-recalc-todo');
            if(btnAll && !btnAll.__wired){ btnAll.__wired=true; btnAll.addEventListener('click', ()=>{ const y=window.scrollY; renderPatrones(); calcularPatronesLote(); requestAnimationFrame(()=>window.scrollTo(0,y)); }); }
            const btnCSVL=document.getElementById('patrones-export-lotes'); if(btnCSVL && !btnCSVL.__wired){ btnCSVL.__wired=true; btnCSVL.addEventListener('click', exportLotes); }
            const btnCSVG=document.getElementById('patrones-export-global'); if(btnCSVG && !btnCSVG.__wired){ btnCSVG.__wired=true; btnCSVG.addEventListener('click', exportGlobal); }
            // Exponer para recalculo ligero
            window.__calcularPatronesLote = calcularPatronesLote;
        })();
        // Resumen tabla
        const resumenHeaders=['Métrica','Valor'];
        const resumenRows=[];
        if(totalGenerales.length){
            const prom=Math.round(totalGenerales.reduce((a,b)=>a+b,0)/totalGenerales.length);
            const desv=Math.round(std(totalGenerales));
            resumenRows.push(['N registros', totalGenerales.length]);
            resumenRows.push(['Promedio total (s)', prom]);
            resumenRows.push(['Desv (s)', desv]);
            resumenRows.push(['%Desv', percent(desv,prom)]);
        }
        procesoStats.forEach((arr,i)=>{
            if(arr.length){
                const prom=Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
                const desv=Math.round(std(arr));
                resumenRows.push([`Prom ${procesosNombres[i]} (s)`, prom]);
                resumenRows.push([`Desv ${procesosNombres[i]} (s)`, desv]);
                resumenRows.push([`%Desv ${procesosNombres[i]}`, percent(desv,prom)]);
            }
        });
        if(globalRealSum>0){
            const tiempoMuerto = globalMuertoSum;
            resumenRows.push(['Tiempo productivo (s)', globalProdSum]);
            resumenRows.push(['Tiempo muerto (s)', tiempoMuerto]);
            resumenRows.push(['%Muerto', percent(tiempoMuerto, globalRealSum)]);
            resumenRows.push(['OEE (%)', percent(globalProdSum, globalRealSum)]);
        }
        const tblResumen=document.getElementById('tabla-resumen'); if(tblResumen) tblResumen.innerHTML=tableFromRows(resumenHeaders,resumenRows);
    // Recalcular panel experimental general de factores si existe (#patrones-panel)
    if(typeof renderPatrones==='function'){ try { renderPatrones(); } catch(_){ } }
        // ================== PATRÓN AUTOMÁTICO SIMPLE ==================
    (function patronAutomatico(){
            const cont = document.getElementById('patron-simple'); if(!cont) return;
            try{
                // Construir dataset por máquina con tiempo real y atributos clave
                const maquinas=[];
                _TABLAS_DATA_LAST.forEach(r=> (r.maquinas||[]).forEach(m=>{
                    const p1=m.proceso1, p3=m.proceso3; if(!(p1&&p1.startTime&&p3&&p3.endTime)) return;
                    const real = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)); if(real<=0) return;
                    // Determinar personal usando punto medio del rango si existe
                    let pmn = parseInt(m.personalMin||r.personalMin);
                    let pmx = parseInt(m.personalMax||r.personalMax);
                    if(Number.isNaN(pmn) && !Number.isNaN(pmx)) pmn=pmx;
                    if(Number.isNaN(pmx) && !Number.isNaN(pmn)) pmx=pmn;
                    const pers = (!Number.isNaN(pmn) && !Number.isNaN(pmx))? (pmn+pmx)/2 : parseInt(m.personal||r.personal)||NaN;
                    maquinas.push({
                        lote:(m.lote||'').toString().trim()||'_sin_',
                        tipo:(m.tipoMasa||m.tipoPan||'Sin tipo').trim(),
                        hielo:(m.hielo||'').trim()||'No',
                        ama:(m.numeroAmasadora||m.id||'?'),
                        tempMasa: parseFloat(m.tempMasa),
                        personal: pers,
                        real
                    });
                }));
                if(!maquinas.length){ cont.textContent='Sin datos suficientes.'; return; }
                // Agrupar por lote y promedio real
                const byLote={}; maquinas.forEach(m=>{ (byLote[m.lote]=byLote[m.lote]||[]).push(m); });
                let lotesArr = Object.entries(byLote).map(([lote, arr])=>({
                    lote,
                    n:arr.length,
                    realProm: arr.reduce((a,b)=>a+b.real,0)/arr.length,
                    arr
                }));
                if(lotesArr.length<2){ cont.textContent='Muy pocos lotes para analizar.'; return; }
                // Tomar top 20% (al menos 2) de lotes más lentos por realProm
                lotesArr.sort((a,b)=> b.realProm - a.realProm);
                const topCount = Math.max(2, Math.round(lotesArr.length*0.2));
                const topLotes = lotesArr.slice(0, topCount);
                // Recopilar valores dominantes (moda) en esos top lotes para cada variable categórica
                function moda(values){ const map={}; values.forEach(v=> map[v]=(map[v]||0)+1); const arr=Object.entries(map).sort((a,b)=> b[1]-a[1]); if(!arr.length) return null; const [valor, freq]=arr[0]; return {valor,freq, pct:freq*100/values.length}; }
                // Bucketizar personal (si existe) en rangos
                maquinas.forEach(m=>{ if(Number.isFinite(m.personal)){ if(m.personal<=4) m.personalBucket='≤4'; else if(m.personal<=6) m.personalBucket='5–6'; else m.personalBucket='≥7'; } });
                const catVars=['tipo','hielo','ama','personalBucket']; // 'tipo' ya representa tipoMasa/tipoPan consolidado
                const resumenCat = catVars.map(v=>{
                    const vals = topLotes.flatMap(l=> l.arr.map(m=> m[v]));
                    const m = moda(vals); return {var:v, moda:m};
                });
                // Temp de masa: rango y si está concentrada
                const temps = topLotes.flatMap(l=> l.arr.map(m=> m.tempMasa).filter(x=>Number.isFinite(x)));
                let tempInfo='n/d';
                if(temps.length>=3){ temps.sort((a,b)=>a-b); const p=qq=> temps[Math.floor((temps.length-1)*qq)]; const min=temps[0], max=temps[temps.length-1]; const p50=p(0.5); const iqr=p(0.75)-p(0.25); tempInfo = `${min.toFixed(1)}–${max.toFixed(1)} (P50=${p50.toFixed(1)})${iqr?` · IQR=${iqr.toFixed(1)}`:''}`; }
                // Elegir variable “más común”: mayor porcentaje de moda sobre su universo
                let mejor = resumenCat.filter(r=> r.moda).sort((a,b)=> b.moda.pct - a.moda.pct)[0] || null;
                // Si personalBucket existe y su frecuencia relativa es >= 60% y mayor que la siguiente, forzarla como principal
                const pb = resumenCat.find(r=> r.var==='personalBucket' && r.moda);
                if(pb && pb.moda.pct>=60){ mejor = pb; }
                // Frase resultado principal
                const gap = topLotes[0].realProm - lotesArr[lotesArr.length-1].realProm;
                let html = `<div class='mb-1'><strong>${topCount}</strong> lotes más lentos (promedio real = <strong>${Math.round(topLotes.reduce((a,b)=>a+b.realProm,0)/topLotes.length)}s</strong>) · Δ respecto al más rápido aprox <strong>${Math.round(gap)}s</strong></div>`;
                if(mejor){
                    html += `<div class='mb-1'>Variable común destacada: <span class='font-semibold uppercase'>${mejor.var}</span> → <strong>${mejor.moda.valor}</strong> (${mejor.moda.freq}/${Math.round(mejor.moda.pct)}%)</div>`;
                }
                const labelsMap={tipo:'tipo', hielo:'hielo', ama:'amas', personalBucket:'personal'};
                html += `<div class='mb-1 flex flex-wrap gap-2'>` +
                    resumenCat.filter(r=> r.moda).map(r=> `<span class='px-2 py-0.5 rounded bg-stone-100 border border-stone-300'>${labelsMap[r.var]||r.var}: ${r.moda.valor} (${Math.round(r.moda.pct)}%)</span>` ).join('') + `</div>`;
                html += `<div class='text-[11px] text-stone-500'>Temp masa rango (lotes lentos): ${tempInfo}</div>`;
                cont.innerHTML = html;
            }catch(e){ cont.textContent='Error cálculo patrón: '+e; }
        })();
        // OEE indicador
        (function(){
            const el = document.getElementById('oee-indicador'); if(!el) return;
            const prod = globalProdSum; const real = globalRealSum; if(!(real>0)){ el.textContent='Sin datos suficientes para OEE.'; return; }
            const oee = (prod*100/real);
            let color='bg-stone-300 text-stone-800';
            if(oee>=80) color='bg-emerald-600 text-white'; else if(oee>=60) color='bg-amber-500 text-white'; else color='bg-red-600 text-white';
            el.innerHTML = `<div class="inline-flex items-center gap-3"><span class="px-3 py-1 rounded ${color} font-semibold">${oee.toFixed(1)}%</span><span class="text-stone-600">Productivo ${formatTime(prod)} / Real ${formatTime(real)} · TM muerto ${(real-prod)>0?formatTime(real-prod):'00:00:00'}</span></div>`;
        })();
            // Control Charts (tiempo total y % muerto)
            (function(){
                // (Removido try/catch previo que causaba errores de sintaxis)
            const canvasTiempo = document.getElementById('chart-ctrl-tiempo');
            const canvasMuerto = document.getElementById('chart-ctrl-muerto');
            if(!canvasTiempo && !canvasMuerto) return;
            // Construir dataset ordenado cronológicamente por fecha y dentro de fecha por amasadora
            const puntosTiempo=[]; const puntosPctMuerto=[]; const labels=[]; const lotes=[]; const detalleFilas=[];
            _TABLAS_DATA_LAST.slice().sort((a,b)=> (a.fecha||'').localeCompare(b.fecha||''))
                .forEach(reg=>{
                    (reg.maquinas||[]).forEach(maq=>{
                        const p1=maq.proceso1, p3=maq.proceso3; if(!(p1&&p1.startTime&&p3&&p3.endTime)) return;
                        const total = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
                        let sumaProc=0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ sumaProc += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0); } }
                        const muerto = Math.max(0, total - sumaProc);
                        const pctMuerto = total? (muerto*100/total):0;
                        const etiquetaBase = reg.fecha+' M'+(maq.numeroAmasadora||maq.id||'');
                        labels.push(etiquetaBase);
                        lotes.push(maq.lote||'');
                        puntosTiempo.push(total);
                        puntosPctMuerto.push(pctMuerto);
                        detalleFilas.push({idx: labels.length-1, fecha: reg.fecha||'', amasadora:(maq.numeroAmasadora||maq.id||''), lote: maq.lote||'', tiempoTotal: total, pctMuerto});
                    });
                });
            function stats(arr){ if(!arr.length) return null; const mean=arr.reduce((a,b)=>a+b,0)/arr.length; const variance=arr.reduce((a,b)=>a+(b-mean)**2,0)/arr.length; const sd=Math.sqrt(variance); return {mean, sd, ucl:mean+3*sd, lcl:Math.max(0, mean-3*sd)}; }
            const stTiempo = stats(puntosTiempo);
            const stMuerto = stats(puntosPctMuerto);
            // Multi-segment persistence (base + adicionales)
            const REBASE_KEY_TIEMPO='spc_rebase_tiempo_segments';
            const REBASE_KEY_MUERTO='spc_rebase_muerto_segments';
            function loadSegments(key){ try{ const v=JSON.parse(localStorage.getItem(key)||'[]'); return Array.isArray(v)? v: []; }catch(e){ return []; } }
            function saveSegments(key,list){ localStorage.setItem(key, JSON.stringify(list||[])); }
            function clearRebase(key){ localStorage.removeItem(key); }
            function computeSegment(fromIndex, arr){ const subset=arr.slice(fromIndex).filter(v=> typeof v==='number'); if(subset.length<2) return null; const mean=subset.reduce((a,b)=>a+b,0)/subset.length; const variance=subset.reduce((a,b)=>a+(b-mean)**2,0)/subset.length; const sd=Math.sqrt(variance); return {fromIndex, mean, sd, ucl:mean+3*sd, lcl:Math.max(0, mean-3*sd)}; }
            function normalize(list){ const m=new Map(); list.forEach(s=>{ if(s && Number.isFinite(s.fromIndex)) m.set(s.fromIndex,s); }); return Array.from(m.values()).sort((a,b)=> a.fromIndex-b.fromIndex); }
            let segsTiempo = normalize(loadSegments(REBASE_KEY_TIEMPO));
            let segsMuerto = normalize(loadSegments(REBASE_KEY_MUERTO));
            // Ensure base segment exists
            if(puntosTiempo.length>=5 && !segsTiempo.some(s=> s.fromIndex===0) && stTiempo){ const base=computeSegment(0,puntosTiempo); if(base) segsTiempo.unshift(base); }
            if(puntosPctMuerto.length>=5 && !segsMuerto.some(s=> s.fromIndex===0) && stMuerto){ const base=computeSegment(0,puntosPctMuerto); if(base) segsMuerto.unshift(base); }
            function rebuildStats(list, arr){ for(let i=0;i<list.length;i++){ const seg=list[i]; const end = (i<list.length-1)? list[i+1].fromIndex: arr.length; const subset = arr.slice(seg.fromIndex, end).filter(v=> typeof v==='number'); if(subset.length>=2){ const mean=subset.reduce((a,b)=>a+b,0)/subset.length; const variance=subset.reduce((a,b)=>a+(b-mean)**2,0)/subset.length; const sd=Math.sqrt(variance); seg.mean=mean; seg.sd=sd; seg.ucl=mean+3*sd; seg.lcl=Math.max(0, mean-3*sd); seg.length=subset.length; } } }
            rebuildStats(segsTiempo, puntosTiempo);
            rebuildStats(segsMuerto, puntosPctMuerto);
            function segmentFor(list, idx){ let current=null; for(const s of list){ if(idx>=s.fromIndex) current=s; else break; } return current; }
            // Build per-index stats arrays for dynamic evaluation
            function expandStats(list, total){ const mean=new Array(total).fill(null), sd=new Array(total).fill(null), ucl=new Array(total).fill(null), lcl=new Array(total).fill(null), segFrom=new Array(total).fill(null), segIdx=new Array(total).fill(null); list.forEach((seg,i)=>{ const end = (i<list.length-1? list[i+1].fromIndex: total); for(let k=seg.fromIndex;k<end && k<total;k++){ mean[k]=seg.mean; sd[k]=seg.sd; ucl[k]=seg.ucl; lcl[k]=seg.lcl; segFrom[k]=seg.fromIndex; segIdx[k]=i; } }); return {mean,sd,ucl,lcl,segFrom,segIdx}; }
            const stxTiempo = expandStats(segsTiempo, puntosTiempo.length);
            const stxMuerto = expandStats(segsMuerto, puntosPctMuerto.length);
            // Detecta primera corrida de >=8 puntos consecutivos por debajo de la media (segment-aware)
            function findRunBelow(meanArr, arr, segIdxArr){
                let runStart=null, runLen=0, prevSeg=null; let found=null;
                for(let i=0;i<arr.length;i++){
                    const seg=segIdxArr[i];
                    if(prevSeg!==null && seg!==prevSeg){ // cambio de segmento => reiniciar
                        runStart=null; runLen=0;
                    }
                    prevSeg=seg;
                    if(meanArr[i]!=null && arr[i] < meanArr[i]){
                        if(runLen===0) runStart=i;
                        runLen++;
                        if(runLen===8){ // consolidar hasta que se rompa
                            let j=i+1;
                            while(j<arr.length && segIdxArr[j]===seg && meanArr[j]!=null && arr[j] < meanArr[j]) j++;
                            found={start:runStart, end:j-1, seg};
                            break;
                        }
                    } else {
                        runStart=null; runLen=0;
                    }
                }
                return found;
            }
            const eventos=[]; // {tipo, indice, etiqueta, valor, metrica, lote, segmentFrom, segmentIdx}
            function detectarEventos(arr, statsX, etiquetaBuilder, isPct, metrica, loteGetter){
                if(!statsX.mean.length || arr.length<2) return;
                const added = new Set();
                function pushEvento(tipo,i,val,etq){ const key=tipo+'|'+i+'|'+metrica; if(added.has(key)) return; added.add(key); eventos.push({tipo, indice:i, etiqueta:etq, valor:val, metrica, lote:(loteGetter?loteGetter(i):''), segmentFrom: statsX.segFrom[i], segmentIdx: statsX.segIdx[i]}); }
                // 1. Fuera de límites (segment-specific)
                arr.forEach((v,i)=>{ if(statsX.ucl[i]!=null && (v>statsX.ucl[i] || v<statsX.lcl[i])){ pushEvento('Fuera de límites', i, isPct? v.toFixed(2)+'%': v+'s', etiquetaBuilder(i)); } });
                // 2. Run >=7 & 8 mismo lado (respect segmented mean)
                let runSide=null, runLen=0; arr.forEach((v,i)=>{ const mean=statsX.mean[i]; if(mean==null) return; const side=v>=mean?'up':'down'; const prevSeg= statsX.segIdx[i-1]; const curSeg= statsX.segIdx[i]; if(i>0 && prevSeg!==curSeg){ // reset run when segment boundary changes
                        runSide=side; runLen=1; return;
                    }
                    if(side===runSide){ runLen++; } else { runSide=side; runLen=1; }
                    if(runLen===7) pushEvento('Run 7 mismo lado', i, isPct? v.toFixed(2)+'%': v+'s', etiquetaBuilder(i)+' (último)');
                    if(runLen===8) pushEvento('8 mismo lado', i, isPct? v.toFixed(2)+'%': v+'s', etiquetaBuilder(i)+' (último)');
                });
                // 3. Tendencia 6 asc/desc (global, independent of segments, but reset on boundary)
                let trendLen=1; for(let i=1;i<arr.length;i++){ const prevSeg=statsX.segIdx[i-1]; const curSeg=statsX.segIdx[i]; if(prevSeg!==curSeg){ trendLen=1; continue; } if(arr[i]>arr[i-1]){ if(trendLen>0) trendLen++; else trendLen=2; } else if(arr[i]<arr[i-1]){ if(trendLen<0) trendLen--; else trendLen=-2; } else { trendLen=1; } if(Math.abs(trendLen)===6){ pushEvento('Tendencia 6 '+(trendLen>0?'asc':'desc'), i, isPct? arr[i].toFixed(2)+'%': arr[i]+'s', etiquetaBuilder(i)+' (último)'); } }
                // 4 & 5. Zone rules with segment-specific σ
                for(let i=2;i<arr.length;i++){
                    const segIdx = statsX.segIdx[i]; if(segIdx==null) continue; const mean=statsX.mean[i]; const sd=statsX.sd[i]; if(!sd) continue; let pos=0,neg=0; for(let j=i-2;j<=i;j++){ if(statsX.segIdx[j]!==segIdx) { pos=0; neg=0; continue; } const z=(arr[j]-mean)/sd; if(Math.abs(z)>2){ if(z>0) pos++; else neg++; } }
                    if(pos>=2) pushEvento('2 de 3 >2σ arriba', i, isPct? arr[i].toFixed(2)+'%': arr[i]+'s', etiquetaBuilder(i));
                    if(neg>=2) pushEvento('2 de 3 >2σ abajo', i, isPct? arr[i].toFixed(2)+'%': arr[i]+'s', etiquetaBuilder(i));
                }
                for(let i=4;i<arr.length;i++){
                    const segIdx = statsX.segIdx[i]; if(segIdx==null) continue; const mean=statsX.mean[i]; const sd=statsX.sd[i]; if(!sd) continue; let pos=0,neg=0; for(let j=i-4;j<=i;j++){ if(statsX.segIdx[j]!==segIdx) { pos=0; neg=0; continue; } const z=(arr[j]-mean)/sd; if(Math.abs(z)>1){ if(z>0) pos++; else neg++; } }
                    if(pos>=4) pushEvento('4 de 5 >1σ arriba', i, isPct? arr[i].toFixed(2)+'%': arr[i]+'s', etiquetaBuilder(i));
                    if(neg>=4) pushEvento('4 de 5 >1σ abajo', i, isPct? arr[i].toFixed(2)+'%': arr[i]+'s', etiquetaBuilder(i));
                }
            }
            // Asignar score a cada evento
            function scoreEvento(tipo){
                if(tipo==='Fuera de límites') return 100;
                if(tipo.startsWith('2 de 3')) return 85;
                if(tipo.startsWith('4 de 5')) return 75;
                if(tipo==='8 mismo lado') return 60;
                if(tipo==='Run 7 mismo lado') return 55;
                if(tipo.startsWith('Tendencia 6')) return 50;
                return 40;
            }
            // Esta función debe llamarse tras detectar todos los eventos
            function prepararTopEventos(){
                eventos.forEach(e=> e.score = scoreEvento(e.tipo));
                // Orden: score DESC luego indice DESC (más reciente) y limitar 3
                const top = eventos.slice().sort((a,b)=> b.score - a.score || b.indice - a.indice).slice(0,3);
                const wrap = document.getElementById('spc-top3'); if(!wrap) return; if(!top.length){ wrap.classList.add('hidden'); return; }
                wrap.classList.remove('hidden');
                wrap.innerHTML = `<div class='flex flex-wrap gap-2 items-stretch'>${top.map(ev=>{
                    const badgeColor = ev.score>=90? 'bg-red-600' : ev.score>=80? 'bg-orange-600' : ev.score>=70? 'bg-amber-500' : ev.score>=60? 'bg-indigo-600':'bg-stone-500';
                    return `<div class='border border-stone-300 rounded-md px-2 py-1 bg-white shadow-sm flex flex-col gap-0.5 min-w-[160px]'>
                        <div class='flex items-center justify-between gap-2'><span class='text-[10px] font-semibold uppercase tracking-wide text-stone-500'>${ev.metrica}</span><span class='text-[10px] font-mono text-stone-400'>#${ev.indice}</span></div>
                        <div class='text-[12px] font-semibold text-stone-800 leading-tight'>${ev.tipo}</div>
                        <div class='text-[11px] text-stone-600'>${ev.etiqueta}</div>
                        <div class='flex items-center justify-between mt-0.5'><span class='text-[11px] text-stone-600'>Lote: <span class='font-mono'>${ev.lote||'-'}</span></span><span class='px-1.5 py-0.5 rounded text-[10px] font-bold text-white ${badgeColor}'>${ev.score}</span></div>
                    </div>`; }).join('')}</div>`;
            }
            // Preparar estructura de eventos agrupados por índice y métrica para tooltip compuesto
            const eventosPorMetrica = { 'Tiempo total': {}, '% Muerto': {} };
            eventos.forEach(ev=>{ const bucket=eventosPorMetrica[ev.metrica]; if(bucket){ (bucket[ev.indice]=bucket[ev.indice]||[]).push(ev); } });
            if(canvasTiempo && puntosTiempo.length){
                const ds=[{label:'Tiempo total (s)', data:puntosTiempo, borderColor:'#2563eb', backgroundColor:'#2563eb', tension:0.15, pointRadius:4, fill:false}];
                if(segsTiempo.length && puntosTiempo.length>=5){
                    // Add segment lines
                    segsTiempo.forEach((seg,i)=>{
                        const baseIdx = puntosTiempo.map((_,k)=> k>=seg.fromIndex? seg.mean:null);
                        const uclIdx = puntosTiempo.map((_,k)=> k>=seg.fromIndex? seg.ucl:null);
                        const lclIdx = puntosTiempo.map((_,k)=> k>=seg.fromIndex? seg.lcl:null);
                        const showLabel = (i===0)? 'CL' : '';
                        ds.push({label:showLabel, data:baseIdx, borderColor:'#16a34a', borderWidth:1.1, pointRadius:0, borderDash: i===0? []:[2,2]});
                        ds.push({label:showLabel? 'UCL': '', data:uclIdx, borderColor:'#dc2626', borderWidth:1.1, pointRadius:0, borderDash: i===0? [6,4]:[2,2]});
                        ds.push({label:showLabel? 'LCL': '', data:lclIdx, borderColor:'#dc2626', borderWidth:1.1, pointRadius:0, borderDash: i===0? [6,4]:[2,2]});
                    });
                    detectarEventos(puntosTiempo, stxTiempo, (i)=>labels[i], false, 'Tiempo total', (i)=>lotes[i]);
                }
                // Enriquecer puntos con eventos
                const eventoTiposTiempo={};
                eventos.filter(e=>e.metrica==='Tiempo total').forEach(e=>{ (eventoTiposTiempo[e.indice] = eventoTiposTiempo[e.indice]||[]).push(e.tipo); });
                if(Object.keys(eventoTiposTiempo).length){
                    const baseColor='#2563eb';
                    ds[0].pointBackgroundColor = (ctx)=> eventoTiposTiempo[ctx.dataIndex] ? '#dc2626' : baseColor;
                    ds[0].pointBorderColor = (ctx)=> eventoTiposTiempo[ctx.dataIndex] ? '#dc2626' : baseColor;
                    ds[0].pointRadius = (ctx)=> eventoTiposTiempo[ctx.dataIndex] ? 6 : 4;
                    ds[0].pointStyle = (ctx)=> eventoTiposTiempo[ctx.dataIndex] ? 'triangle' : 'circle';
                }
                const optTiempo = {responsive:true, plugins:{legend:{position:'bottom'}, tooltip:{callbacks:{label(ctx){ return `Valor: ${ctx.parsed.y}s`; }, afterBody(items){ if(!items.length) return; const idx=items[0].dataIndex; const fila = detalleFilas[idx]; const metaLinea = fila? [`Fecha: ${fila.fecha}`, `Amas: M${fila.amasadora}`, `Lote: ${fila.lote||''}`, `Segmento desde #${stxTiempo.segFrom[idx]}`] : [`Segmento desde #${stxTiempo.segFrom[idx]}`]; const evs = (eventosPorMetrica['Tiempo total'][idx]||[]).map(e=>'• '+e.tipo); return [...metaLinea, ...(evs.length?['Eventos:'].concat(evs):[])]; }}}}, scales:{y:{beginAtZero:true}}};
                mkChart(canvasTiempo,'line',{labels, datasets:ds}, optTiempo);
                const info=document.getElementById('chart-ctrl-tiempo-info'); if(info && segsTiempo.length){
                    info.textContent = segsTiempo.map((s,i)=>`S${i}#${s.fromIndex} CL=${s.mean.toFixed(1)} σ=${s.sd.toFixed(1)}`).join(' | ');
                    if(Object.keys(eventoTiposTiempo).length){ const note=document.createElement('div'); note.className='text-[11px] text-stone-500 mt-1'; note.textContent='Triángulo rojo = punto con evento SPC'; info.appendChild(note);} 
                    // Alerta textual de corrida >=8 abajo de la media
                    const runBelow = findRunBelow(stxTiempo.mean, puntosTiempo, stxTiempo.segIdx);
                    if(runBelow){
                        const alert=document.createElement('div');
                        alert.className='mt-1 text-[11px] rounded bg-emerald-50 border border-emerald-300 px-2 py-1 text-emerald-700';
                        alert.innerHTML=`<strong>Mejora sostenida:</strong> ${runBelow.end-runBelow.start+1} puntos consecutivos por debajo de la media (Segmento S${runBelow.seg} indices ${runBelow.start}–${runBelow.end}). Evalúa rebaseline si se mantiene.`;
                        info.appendChild(alert);
                    }
                }
            }
            if(canvasMuerto && puntosPctMuerto.length){
                const ds2=[{label:'% Muerto', data:puntosPctMuerto, borderColor:'#f59e0b', backgroundColor:'#f59e0b', tension:0.15, pointRadius:4, fill:false}];
                if(segsMuerto.length && puntosPctMuerto.length>=5){
                    segsMuerto.forEach((seg,i)=>{
                        const baseIdx = puntosPctMuerto.map((_,k)=> k>=seg.fromIndex? seg.mean:null);
                        const uclIdx = puntosPctMuerto.map((_,k)=> k>=seg.fromIndex? seg.ucl:null);
                        const lclIdx = puntosPctMuerto.map((_,k)=> k>=seg.fromIndex? seg.lcl:null);
                        const showLabel = (i===0)? 'CL' : '';
                        ds2.push({label:showLabel, data:baseIdx, borderColor:'#16a34a', borderWidth:1.1, pointRadius:0, borderDash: i===0? []:[2,2]});
                        ds2.push({label:showLabel? 'UCL': '', data:uclIdx, borderColor:'#dc2626', borderWidth:1.1, pointRadius:0, borderDash: i===0? [6,4]:[2,2]});
                        ds2.push({label:showLabel? 'LCL': '', data:lclIdx, borderColor:'#dc2626', borderWidth:1.1, pointRadius:0, borderDash: i===0? [6,4]:[2,2]});
                    });
                    detectarEventos(puntosPctMuerto, stxMuerto, (i)=>labels[i], true, '% Muerto', (i)=>lotes[i]);
                }
                const eventoTiposMuerto={};
                eventos.filter(e=>e.metrica==='% Muerto').forEach(e=>{ (eventoTiposMuerto[e.indice] = eventoTiposMuerto[e.indice]||[]).push(e.tipo); });
                if(Object.keys(eventoTiposMuerto).length){
                    const baseColor='#f59e0b';
                    ds2[0].pointBackgroundColor = (ctx)=> eventoTiposMuerto[ctx.dataIndex] ? '#dc2626' : baseColor;
                    ds2[0].pointBorderColor = (ctx)=> eventoTiposMuerto[ctx.dataIndex] ? '#dc2626' : baseColor;
                    ds2[0].pointRadius = (ctx)=> eventoTiposMuerto[ctx.dataIndex] ? 6 : 4;
                    ds2[0].pointStyle = (ctx)=> eventoTiposMuerto[ctx.dataIndex] ? 'triangle' : 'circle';
                }
                const optMuerto = {responsive:true, plugins:{legend:{position:'bottom'}, tooltip:{callbacks:{label(ctx){ return `%: ${ctx.parsed.y.toFixed(2)}%`; }, afterBody(items){ if(!items.length) return; const idx=items[0].dataIndex; const fila = detalleFilas[idx]; const metaLinea = fila? [`Fecha: ${fila.fecha}`, `Amas: M${fila.amasadora}`, `Lote: ${fila.lote||''}`, `Segmento desde #${stxMuerto.segFrom[idx]}`] : [`Segmento desde #${stxMuerto.segFrom[idx]}`]; const evs = (eventosPorMetrica['% Muerto'][idx]||[]).map(e=>'• '+e.tipo); return [...metaLinea, ...(evs.length?['Eventos:'].concat(evs):[])]; }}}}, scales:{y:{beginAtZero:true, title:{display:true,text:'%'}}}};
                mkChart(canvasMuerto,'line',{labels, datasets:ds2}, optMuerto);
                const info2=document.getElementById('chart-ctrl-muerto-info'); if(info2 && segsMuerto.length){
                    info2.textContent = segsMuerto.map((s,i)=>`S${i}#${s.fromIndex} CL=${s.mean.toFixed(2)} σ=${s.sd.toFixed(2)}`).join(' | ');
                    if(Object.keys(eventoTiposMuerto).length){ const note=document.createElement('div'); note.className='text-[11px] text-stone-500 mt-1'; note.textContent='Triángulo rojo = punto con evento SPC'; info2.appendChild(note);} 
                    // Alerta textual de corrida >=8 abajo de la media (menor % muerto = mejora)
                    const runBelowM = findRunBelow(stxMuerto.mean, puntosPctMuerto, stxMuerto.segIdx);
                    if(runBelowM){
                        const alert=document.createElement('div');
                        alert.className='mt-1 text-[11px] rounded bg-emerald-50 border border-emerald-300 px-2 py-1 text-emerald-700';
                        alert.innerHTML=`<strong>Mejora sostenida:</strong> ${runBelowM.end-runBelowM.start+1} puntos consecutivos por debajo de la media (Segmento S${runBelowM.seg} indices ${runBelowM.start}–${runBelowM.end}). Considera nuevo segmento.`;
                        info2.appendChild(alert);
                    }
                }
            }
            // Botones Rebaseline multi-segment
            const btnRbT = document.getElementById('btn-rebaseline-tiempo');
            const btnRbM = document.getElementById('btn-rebaseline-muerto');
            const inpRbT = document.getElementById('rebase-tiempo-indice');
            const inpRbM = document.getElementById('rebase-muerto-indice');
            const btnClrT = document.getElementById('btn-clear-rebaseline-tiempo');
            const btnClrM = document.getElementById('btn-clear-rebaseline-muerto');
            function addSegment(listKey, list, idx, arr){ if(list.some(s=> s.fromIndex===idx)){ alert('Segmento ya existe'); return false; } const seg=computeSegment(idx, arr); if(!seg){ alert('No hay suficientes puntos después del índice'); return false; } list.push(seg); list.sort((a,b)=>a.fromIndex-b.fromIndex); saveSegments(listKey, list); return true; }
            function removeSegment(listKey, list, idx){ const i=list.findIndex(s=> s.fromIndex===idx); if(i<=0) { alert('No se puede eliminar el segmento base o no existe.'); return false; } list.splice(i,1); saveSegments(listKey, list); return true; }
            function renderSegmentsUI(){
                const contT=document.getElementById('segments-tiempo'); const contM=document.getElementById('segments-muerto');
                function mk(list,key){ return list.map((s,i)=>`<span class='inline-flex items-center gap-1 px-1.5 py-0.5 rounded border ${i===0?'bg-stone-200 border-stone-300':'bg-white border-stone-300'}'>S${i}@${s.fromIndex}<span class='text-[9px] text-stone-500'>CL ${s.mean.toFixed(1)}${key==='muerto'?'%':'s'}</span>${i>0?`<button data-del-seg='${key}:${s.fromIndex}' class='text-red-600 hover:text-red-800 font-bold leading-none' title='Eliminar segmento'>×</button>`:''}</span>`).join(' '); }
                if(contT) contT.innerHTML = segsTiempo.length? mk(segsTiempo,'tiempo') : '<em>Sin segmentos</em>';
                if(contM) contM.innerHTML = segsMuerto.length? mk(segsMuerto,'muerto') : '<em>Sin segmentos</em>';
            }
            renderSegmentsUI();
            document.addEventListener('click', e=>{
                const btn=e.target.closest('button[data-del-seg]'); if(!btn) return; const val=btn.getAttribute('data-del-seg'); const [kind, from]=val.split(':'); const idx=parseInt(from,10); if(kind==='tiempo'){ if(removeSegment(REBASE_KEY_TIEMPO,segsTiempo,idx)) buildTablasVista(); } else if(kind==='muerto'){ if(removeSegment(REBASE_KEY_MUERTO,segsMuerto,idx)) buildTablasVista(); }
            });
            function applyRebaseTiempo(){ const idx=parseInt(inpRbT.value,10); if(isNaN(idx)|| idx<1 || idx>=puntosTiempo.length-2){ alert('Índice inválido'); return; } if(addSegment(REBASE_KEY_TIEMPO, segsTiempo, idx, puntosTiempo)) buildTablasVista(); }
            function applyRebaseMuerto(){ const idx=parseInt(inpRbM.value,10); if(isNaN(idx)|| idx<1 || idx>=puntosPctMuerto.length-2){ alert('Índice inválido'); return; } if(addSegment(REBASE_KEY_MUERTO, segsMuerto, idx, puntosPctMuerto)) buildTablasVista(); }
            if(btnRbT) btnRbT.onclick = applyRebaseTiempo;
            if(btnRbM) btnRbM.onclick = applyRebaseMuerto;
            if(btnClrT) btnClrT.onclick = ()=>{ clearRebase(REBASE_KEY_TIEMPO); buildTablasVista(); };
            if(btnClrM) btnClrM.onclick = ()=>{ clearRebase(REBASE_KEY_MUERTO); buildTablasVista(); };
            // Render filtros + tabla de eventos con filtrado dinámico
            (function(){
                const cont = document.getElementById('tabla-eventos-control'); if(!cont) return;
                const filtrosWrap = document.getElementById('spc-filtros');
                const tiposUnicos = Array.from(new Set(eventos.map(e=>e.tipo))).sort();
                const estado = {}; tiposUnicos.forEach(t=> estado[t]=true);
                function renderFiltros(){ if(!filtrosWrap) return; filtrosWrap.innerHTML = tiposUnicos.map(t=> `<label class='inline-flex items-center gap-1 bg-stone-100 px-2 py-1 rounded border border-stone-300'> <input type='checkbox' data-tipo='${t}' checked class='spc-filter accent-indigo-600 scale-90'/> <span>${t}</span></label>`).join(''); filtrosWrap.querySelectorAll('input.spc-filter').forEach(inp=>{ inp.addEventListener('change',()=>{ estado[inp.getAttribute('data-tipo')] = inp.checked; renderTabla(); }); }); }
                function renderTabla(){ if(!eventos.length){ cont.innerHTML='<div class="text-stone-500">Sin señales detectadas.</div>'; return; } const filtrados = eventos.filter(e=> estado[e.tipo]); if(!filtrados.length){ cont.innerHTML='<div class="text-stone-500">(Todos los tipos filtrados)</div>'; return; } const rows = filtrados.map(ev=> `<tr><td class='px-2 py-1 border-b border-stone-200 whitespace-nowrap'>${ev.tipo}</td><td class='px-2 py-1 border-b border-stone-200'>${ev.metrica}</td><td class='px-2 py-1 border-b border-stone-200 font-mono text-[10px]'>${ev.etiqueta}</td><td class='px-2 py-1 border-b border-stone-200'>${ev.lote||''}</td><td class='px-2 py-1 border-b border-stone-200 text-center'>S${(ev.segmentIdx??0)}</td><td class='px-2 py-1 border-b border-stone-200 text-right'>${ev.valor}</td></tr>`).join(''); cont.innerHTML = `<table class='min-w-[720px] text-[11px] border border-stone-300 bg-white rounded'><thead class='bg-stone-100 text-stone-700'><tr><th class='px-2 py-1 text-left'>Tipo</th><th class='px-2 py-1 text-left'>Métrica</th><th class='px-2 py-1 text-left'>Etiqueta</th><th class='px-2 py-1 text-left'>Lote</th><th class='px-2 py-1 text-left'>Seg</th><th class='px-2 py-1 text-right'>Valor</th></tr></thead><tbody>${rows}</tbody></table>`; }
                prepararTopEventos();
                renderFiltros();
                renderTabla();
                // Reglas y pesos (guía)
                (function(){
                    const box = document.getElementById('spc-reglas-pesos'); if(!box) return;
                    const definiciones = [
                        ['Fuera de límites','100','Punto fuera de UCL/LCL (±3σ)'],
                        ['2 de 3 >2σ arriba/abajo','85','Dos de tres consecutivos más allá de 2σ mismo lado'],
                        ['4 de 5 >1σ arriba/abajo','75','Cuatro de cinco más allá de 1σ mismo lado'],
                        ['8 mismo lado','60','Ocho puntos consecutivos en un lado de la media'],
                        ['Run 7 mismo lado','55','Siete puntos consecutivos en un lado (evento base)'],
                        ['Tendencia 6 asc/desc','50','Seis puntos ascendiendo o descendiendo estrictos']
                    ];
                    box.innerHTML = `<div class='bg-stone-50 border border-stone-300 rounded-md p-2'><div class='font-semibold text-stone-700 mb-1'>Reglas y pesos (prioridad)</div><ul class='grid md:grid-cols-3 gap-1'>${definiciones.map(([n,p,d])=> `<li class='flex items-start gap-2'><span class='px-1.5 py-0.5 rounded bg-stone-200 text-[10px] font-bold text-stone-700 min-w-[28px] text-center'>${p}</span><span class='text-stone-700 leading-tight'>${n}<br><span class='text-stone-500 font-normal'>${d}</span></span></li>`).join('')}</ul></div>`;
                })();
                // Export CSV button
                const btnExp = document.getElementById('btn-export-eventos-spc');
                if(btnExp){
                    btnExp.onclick = ()=>{
                        if(!eventos.length){ alert('No hay eventos para exportar'); return; }
                        const meta = [];
                        const now = new Date();
                        meta.push(`# Export Eventos SPC`);
                        meta.push(`# Generado: ${now.toISOString()}`);
                        meta.push(`# Reglas: Fuera de límites; Run>=7; 8 mismo lado; Tendencia>=6; 2 de 3 >2σ; 4 de 5 >1σ`);
                        if(stTiempo) meta.push(`# Tiempo Total: mean=${stTiempo.mean.toFixed(2)} sd=${stTiempo.sd.toFixed(2)} UCL=${stTiempo.ucl.toFixed(2)} LCL=${stTiempo.lcl.toFixed(2)}`);
                        if(stMuerto) meta.push(`# % Muerto: mean=${stMuerto.mean.toFixed(2)} sd=${stMuerto.sd.toFixed(2)} UCL=${stMuerto.ucl.toFixed(2)} LCL=${stMuerto.lcl.toFixed(2)}`);
                        meta.push(`# Total eventos: ${eventos.length}`);
                        const header = ['Tipo','Metrica','Etiqueta','Lote','Valor','Score','SegmentIdx','SegmentFrom'];
                        const body = eventos.map(e=> [e.tipo, e.metrica, e.etiqueta.replace(/,/g,';'), (e.lote||'').toString().replace(/,/g,';'), e.valor, e.score||scoreEvento(e.tipo), e.segmentIdx, e.segmentFrom]);
                        const csvLines = meta.concat(['']).concat([header.join(',')]).concat(body.map(r=> r.join(',')));
                        const blob = new Blob([csvLines.join('\n')], {type:'text/csv;charset=utf-8;'});
                        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='eventos_spc.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
                    };
                } // fin if btnExp
                // Fin bloque SPC
            })();
            // Tabla detalle de puntos (fecha, amasadora, lote)
            (function(){
                const cont = document.getElementById('tabla-detalle-control'); if(!cont) return;
                if(!detalleFilas.length){ cont.innerHTML='<div class="text-stone-500">Sin puntos calculados.</div>'; return; }
                const rows = detalleFilas.map(r=> `<tr><td class='px-1 py-0.5 border-b border-stone-200 text-right'>${r.idx}</td><td class='px-1 py-0.5 border-b border-stone-200 font-mono text-[10px]'>${r.fecha}</td><td class='px-1 py-0.5 border-b border-stone-200'>M${r.amasadora}</td><td class='px-1 py-0.5 border-b border-stone-200 font-mono text-[10px]'>${r.lote||''}</td><td class='px-1 py-0.5 border-b border-stone-200 text-right'>${r.tiempoTotal}</td><td class='px-1 py-0.5 border-b border-stone-200 text-right'>${r.pctMuerto.toFixed(2)}%</td></tr>`).join('');
                cont.innerHTML = `<table class='min-w-[640px] text-[11px] border border-stone-300 bg-white rounded'><thead class='bg-stone-100'><tr><th class='px-1 py-0.5 text-right'>#</th><th class='px-1 py-0.5 text-left'>Fecha</th><th class='px-1 py-0.5 text-left'>Amas.</th><th class='px-1 py-0.5 text-left'>Lote</th><th class='px-1 py-0.5 text-right'>Tiempo(s)</th><th class='px-1 py-0.5 text-right'>% Muerto</th></tr></thead><tbody>${rows}</tbody></table>`;
            })();
            // Sparkline semanal (OEE, tiempo promedio, % muerto)
            (function(){
                const wrap = document.getElementById('sparkline-semanal-wrapper'); if(!wrap) return;
                // Construir agregados por semana ISO
                function weekKey(fecha){ if(!fecha) return ''; const [Y,M,D]=fecha.split('-').map(Number); const d=new Date(Date.UTC(Y,M-1,D)); const dow=d.getUTCDay()||7; d.setUTCDate(d.getUTCDate()+4-dow); const yearStart=new Date(Date.UTC(d.getUTCFullYear(),0,1)); const week=Math.ceil((((d - yearStart)/86400000)+1)/7); return d.getUTCFullYear()+'-W'+String(week).padStart(2,'0'); }
                const weeks={};
                _TABLAS_DATA_LAST.forEach(reg=>{
                    const wk = weekKey(reg.fecha); if(!wk) return; (reg.maquinas||[]).forEach(maq=>{
                        const p1=maq.proceso1, p3=maq.proceso3; if(!(p1&&p1.startTime&&p3&&p3.endTime)) return;
                        const real=Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
                        let proc=0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ proc += (parseInt(p.minutos)||0)*60+(parseInt(p.segundos)||0); } }
                        const muerto=Math.max(0, real-proc);
                        const bucket = weeks[wk] = weeks[wk] || { real:0, prod:0, muerto:0, n:0 };
                        bucket.real += real; bucket.prod += proc; bucket.muerto += muerto; bucket.n += 1;
                    });
                });
                const list = Object.keys(weeks).sort();
                // Limitar a últimas 10 semanas
                const ordered = list.slice(-10).map(k=> ({ semana:k, promReal: weeks[k].real/weeks[k].n, oee: weeks[k].prod/weeks[k].real, pctMuerto: weeks[k].muerto/weeks[k].real*100 }));
                function renderSpark(arr, key, elId, suffix){ const el=document.getElementById(elId); if(!el){ return; } if(!arr.length){ el.textContent='(sin datos)'; return; } if(arr.length===1){ el.textContent = arr[0][key].toFixed(1)+suffix+' (≥2 sem para tendencia)'; return; } const w=100,h=32,p=3; const vals=arr.map(o=> o[key]); const min=Math.min(...vals), max=Math.max(...vals); const scale=v=> h-p - ((v-min)*(h-2*p)/(max-min||1)); const step=(w-2*p)/(vals.length-1); const first=vals[0]; const last=vals[vals.length-1]; let color='#2563eb'; if(key==='oee'){ if(last-first>1) color='#16a34a'; else if(first-last>1) color='#dc2626'; } else if(key==='promReal'){ if(first-last>30) color='#16a34a'; else if(last-first>30) color='#dc2626'; } else if(key==='pctMuerto'){ if(first-last>1) color='#16a34a'; else if(last-first>1) color='#dc2626'; } const avg = vals.reduce((a,b)=>a+b,0)/vals.length; const pts=vals.map((v,i)=> (p+i*step)+','+scale(v)).join(' '); const avgY=scale(avg); el.innerHTML = `<svg width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>
<polyline points='${pts}' fill='none' stroke='${color}' stroke-width='1.5' stroke-linejoin='round' stroke-linecap='round'/>
<line x1='${p}' y1='${avgY}' x2='${w-p}' y2='${avgY}' stroke='#94a3b8' stroke-dasharray='3,3' stroke-width='1'/>
<circle cx='${p+(vals.length-1)*step}' cy='${scale(last)}' r='3' fill='${color}'/>
</svg><div class='mt-0.5 text-[10px] text-stone-500'>Últ ${last.toFixed(1)}${suffix} (min ${min.toFixed(1)}, máx ${max.toFixed(1)}, media ${avg.toFixed(1)})</div>`; }
                renderSpark(ordered,'oee','spark-oee','%');
                renderSpark(ordered,'promReal','spark-tiempo','s');
                renderSpark(ordered,'pctMuerto','spark-muerto','%');
            })();
        })();
        // Pan table
    const panHeaders=['Tipo masa','N','Prom (s)','Desv (s)','%Desv'];
    const panRows=Object.keys(masaStats).map(k=>{const a=masaStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        document.getElementById('tabla-pan').innerHTML = tableFromRows(panHeaders, panRows);
        // Amasadora table
    const amaHeaders=['Amasadora','N','Prom (s)','Desv (s)','%Desv'];
    const amaRows=Object.keys(amasadoraStats).map(k=>{const a=amasadoraStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        document.getElementById('tabla-amasadora').innerHTML = tableFromRows(amaHeaders, amaRows);
        // Proceso table
        const procHeaders=['Proceso','N','Prom (s)','Desv (s)','%Desv'];
        const procRows=procesoStats.map((a,i)=> a.length? [procesosNombres[i], a.length, Math.round(a.reduce((x,y)=>x+y,0)/a.length), Math.round(std(a)), percent(Math.round(std(a)), Math.round(a.reduce((x,y)=>x+y,0)/a.length))]: null).filter(Boolean);
        document.getElementById('tabla-proceso').innerHTML = tableFromRows(procHeaders, procRows);
    // Temp masa por tipo de masa
    const tempHeaders=['Tipo masa','N','Prom (°C)','Desv (°C)','%Desv'];
    const tempRows=Object.keys(tempMasaStats).map(k=>{const a=tempMasaStats[k]; const m=a.reduce((x,y)=>x+y,0)/a.length; const d=std(a); return [k,a.length,m.toFixed(1),d.toFixed(1),percent(d,m)];});
        document.getElementById('tabla-temp').innerHTML = tableFromRows(tempHeaders, tempRows);
    // Tabla cruzada temp masa (amasadora vs tipo de masa)
        const tiposOrden = Array.from(new Set(tempCrossRaw.map(r=>r.tipo)));
        const amasOrden = Array.from(new Set(tempCrossRaw.map(r=>r.ama)));
        const cruzHeaders=['Amasadora', ...tiposOrden];
        const cruzRows = amasOrden.map(a=>{
            const c=[a];
            tiposOrden.forEach(t=>{
                const subset = tempCrossRaw.filter(r=>r.ama===a && r.tipo===t).map(r=>r.tm);
                if(subset.length){ const avg = subset.reduce((x,y)=>x+y,0)/subset.length; c.push(avg.toFixed(1)); } else { c.push(''); }
            });
            return c;
        });
        const cruzEl=document.getElementById('tabla-temp-cruzada'); if(cruzEl) cruzEl.innerHTML= tableFromRows(cruzHeaders, cruzRows);

        // Personal por día (mín–máx) agregado por fecha (una fila por día) + gráfico
        (function(){
            const cont = document.getElementById('tabla-personal-dia');
            if(!cont) return;
            const headers = ['Fecha','N máquinas','Personal mín','Personal máx','Midpoint','Rango'];
            const perDay = {}; // fecha -> {n, mins:[], maxs:[]}
            datos.forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const bucket = perDay[fecha] = perDay[fecha] || { n:0, mins:[], maxs:[] };
                bucket.n += (reg.maquinas||[]).length;
                (reg.maquinas||[]).forEach(m=>{
                    const vmin = parseInt(m.personalMin); if(!isNaN(vmin)) bucket.mins.push(vmin);
                    const vmax = parseInt(m.personalMax); if(!isNaN(vmax)) bucket.maxs.push(vmax);
                });
                // fallback con primera máquina si no hubo datos válidos
                if(bucket.mins.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) bucket.mins.push(v); }
                if(bucket.maxs.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) bucket.maxs.push(v); }
            });
            const rows = Object.keys(perDay).map(fecha=>{
                const b = perDay[fecha];
                if(!(b.mins.length||b.maxs.length)) return null;
                const min = b.mins.length? Math.min(...b.mins): '';
                const max = b.maxs.length? Math.max(...b.maxs): '';
                const midpoint = (typeof min==='number' && typeof max==='number')? Math.round((min+max)/2) : '';
                const rango = (typeof min==='number' && typeof max==='number')? (max-min) : '';
                return [fecha, b.n, min, max, midpoint, rango];
            }).filter(Boolean).sort((a,b)=> String(a[0]||'').localeCompare(String(b[0]||'')));
            cont.innerHTML = tableFromRows(headers, rows);
            // Gráfico de barras apiladas: OffsetMin (transparente) + Rango (max-min); midpoint como línea
            const el = document.getElementById('chart-personal-dia'); if(!el) return;
            const labels = rows.map(r=>r[0]);
            const dataMin = rows.map(r=> r[2] ?? 0);
            const dataMax = rows.map(r=> r[3] ?? 0);
            const dataMid = rows.map(r=> r[4] ?? 0);
            const dataRango = rows.map((r,i)=> (dataMax[i] - dataMin[i]));
            if(labels.length){
                const chart = mkChart(el,'bar',{
                    labels,
                    datasets:[
                        {label:'OffsetMin', data:dataMin, backgroundColor:'rgba(0,0,0,0)', stack:'pd', borderWidth:0},
                        {label:'Rango (min→max)', data:dataRango, backgroundColor:'#60a5fa', stack:'pd'}
                    ]
                },{
                    responsive:true,
                    plugins:{
                        legend:{position:'bottom', labels:{ filter:(item)=> item.text !== 'OffsetMin' }},
                        tooltip:{
                            callbacks:{
                                label:(ctx)=>{
                                    if(ctx.dataset.label!=='Rango (min→max)') return null;
                                    const s = ctx.chart.$personalStats?.[ctx.dataIndex];
                                    if(!s) return null;
                                    return [
                                        'Min: '+s.min,
                                        'Midpoint: '+s.mid,
                                        'Max: '+s.max
                                    ];
                                }
                            }
                        }
                    },
                    scales:{y:{beginAtZero:true}}
                });
                // Guardar stats para tooltip y dibujar midpoint
                chart.$personalStats = labels.map((_,i)=>({min:dataMin[i], mid:dataMid[i], max:dataMax[i]}));
                setTimeout(()=>{
                    const ctx = chart.ctx; const yScale = chart.scales.y; const xScale = chart.scales.x;
                    ctx.save(); ctx.fillStyle = '#dc2626';
                    dataMid.forEach((m,i)=>{
                        const x = xScale.getPixelForValue(i);
                        const y = yScale.getPixelForValue(m);
                        ctx.beginPath(); ctx.arc(x, y, 3.5, 0, Math.PI*2); ctx.fill();
                    });
                    ctx.restore();
                }, 60);
            }
        })();

        // TA/H por día (promedios por fecha)
        (function(){
            const cont = document.getElementById('tabla-ta-h-dia'); if(!cont) return;
            const headers=['Fecha','N máquinas','TA prom','H prom'];
            const acc={}; // fecha -> {n, ta:[], h:[]}
            datos.forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const b = acc[fecha] = acc[fecha] || { n:0, ta:[], h:[] };
                const maquinas = reg.maquinas||[]; b.n += maquinas.length;
                maquinas.forEach(m=>{
                    const ta = parseFloat(m.tempAmbiente); if(Number.isFinite(ta)) b.ta.push(ta);
                    const h  = parseFloat(m.humedad); if(Number.isFinite(h)) b.h.push(h);
                });
                // fallback: tomar valores de la primera máquina si listas vacías
                if(b.ta.length===0 && maquinas[0]){ const v=parseFloat(maquinas[0].tempAmbiente); if(Number.isFinite(v)) b.ta.push(v); }
                if(b.h.length===0 &&  maquinas[0]){ const v=parseFloat(maquinas[0].humedad); if(Number.isFinite(v)) b.h.push(v); }
            });
            const rows = Object.keys(acc).map(fecha=>{
                const b=acc[fecha];
                if(!(b.ta.length||b.h.length)) return null;
                const taProm = b.ta.length? (b.ta.reduce((x,y)=>x+y,0)/b.ta.length).toFixed(1): '';
                const hProm  = b.h.length?  (b.h.reduce((x,y)=>x+y,0)/b.h.length).toFixed(1): '';
                return [fecha, b.n, taProm, hProm];
            }).filter(Boolean).sort((a,b)=> String(a[0]).localeCompare(String(b[0])));
            cont.innerHTML = tableFromRows(headers, rows);
        })();

        // Charts
        function mkChart(ctx,type,data,options){ const c=new Chart(ctx,{type,data,options}); chartsCache.push(c); return c; }
        const palette=['#2563eb','#16a34a','#f59e0b','#dc2626','#7c3aed','#0d9488','#d946ef'];
        // Pan chart
        const panCtx=document.getElementById('chart-pan'); if(panCtx){ mkChart(panCtx,'bar',{labels:panRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:panRows.map(r=>r[2]),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }
        // Amasadora chart
        const amaCtx=document.getElementById('chart-amasadora'); if(amaCtx){ mkChart(amaCtx,'bar',{labels:amaRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:amaRows.map(r=>r[2]),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }
        // Proceso chart
        const procCtx=document.getElementById('chart-proceso'); if(procCtx){ mkChart(procCtx,'bar',{labels:procRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:procRows.map(r=>r[2]),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }
        // Temp chart
        const tempCtx=document.getElementById('chart-temp-pan'); if(tempCtx){ mkChart(tempCtx,'bar',{labels:tempRows.map(r=>r[0]),datasets:[{label:'Temp (°C)',data:tempRows.map(r=>parseFloat(r[2])),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }

        // ====== Nuevas gráficas analíticas ======
        // 1. Boxplot por tipo de masa (custom sin plugins externos)
        (function(){
            const canvas=document.getElementById('chart-boxplot-tipo'); if(!canvas) return;
            const statsDiv=document.getElementById('boxplot-stats');
            const explicacion=document.getElementById('boxplot-explicacion');
            const grupos={};
            datos.forEach(r=> (r.maquinas||[]).forEach(m=>{ const tipo=m.tipoMasa||m.tipoPan||'Sin tipo'; const s1=m.proceso1?.startTime; const e3=m.proceso3?.endTime; if(s1&&e3){ const total=Math.max(0,Math.floor((e3-s1)/1000)); (grupos[tipo]=grupos[tipo]||[]).push(total);} }));
            let stats=Object.keys(grupos).map(k=>{ const arr=[...grupos[k]].sort((a,b)=>a-b); if(!arr.length) return {tipo:k,n:0}; const q=p=>{const pos=(arr.length-1)*p; const b=Math.floor(pos); const r=pos-b; return r? arr[b]+(arr[b+1]-arr[b])*r:arr[b];}; return {tipo:k,n:arr.length,min:arr[0],q1:q(0.25),med:q(0.5),q3:q(0.75),max:arr[arr.length-1],iqr:q(0.75)-q(0.25)}; });
            stats.sort((a,b)=> (a.med||0)-(b.med||0));
            const labels=stats.map(s=>s.tipo);
            if(explicacion){ explicacion.classList.remove('hidden'); explicacion.textContent='Caja = Q1–Q3; línea roja = mediana; bigotes = min y max; n = registros por tipo; IQR% = (Q3-Q1)/(max-min). Pasa el mouse o toca una caja para ver detalle.'; }
            if(statsDiv){ const headers=['Tipo','n','min','Q1','Med','Q3','max','IQR','IQR%']; const rows=stats.map(s=>{ if(!s.n) return [s.tipo,0,'-','-','-','-','-','-','-']; const span=(s.max-s.min)||1; const pct=((s.iqr)*100/span).toFixed(1)+'%'; return [s.tipo,s.n,s.min,s.q1.toFixed(0),s.med.toFixed(0),s.q3.toFixed(0),s.max,s.iqr.toFixed(0),pct]; }); statsDiv.innerHTML=tableFromRows(headers,rows); }
            const datasetMed=stats.map((s,i)=>({x:i,y:s.med||0}));
            const chart=new Chart(canvas,{ type:'scatter', data:{labels,datasets:[{label:'med',data:datasetMed,pointRadius:0}]}, options:{animation:false,responsive:true,interaction:{mode:'nearest',intersect:false},plugins:{legend:{display:false},tooltip:{padding:8,backgroundColor:'rgba(15,23,42,0.9)',titleFont:{size:12,weight:'bold'},bodyFont:{size:11},callbacks:{title:(items)=>{ const i=items[0].dataIndex; return stats[i]?.tipo||''; },label:(ctx)=>{ const s=stats[ctx.dataIndex]; if(!s||!s.n) return s.tipo+': sin datos'; return `n=${s.n}  min:${s.min}s  Q1:${s.q1.toFixed(0)}s  Med:${s.med.toFixed(0)}s  Q3:${s.q3.toFixed(0)}s  max:${s.max}s  IQR:${s.iqr.toFixed(0)}s`; }}}},scales:{x:{type:'category',labels,offset:true,grid:{display:false}},y:{beginAtZero:true,title:{display:true,text:'Segundos'}}}}, plugins:[
                {id:'drawBoxes',afterDraw(c){ const {ctx,scales:{x,y}}=c; c.$boxRects=[]; stats.forEach((s,i)=>{ if(!s.n) return; const nextCenter=x.getPixelForValue(i+1); const prevCenter=x.getPixelForValue(i-1); const center=x.getPixelForValue(i); const gapRight = (nextCenter ? nextCenter-center : (prevCenter? center-prevCenter:60)); const catWidth = gapRight*2 || 120; const boxW=Math.min(90,Math.max(40,catWidth*0.55)); const yMin=y.getPixelForValue(s.min), yQ1=y.getPixelForValue(s.q1), yMed=y.getPixelForValue(s.med), yQ3=y.getPixelForValue(s.q3), yMax=y.getPixelForValue(s.max); c.$boxRects[i]={x1:center-boxW/2,x2:center+boxW/2,y1:Math.min(yQ1,yQ3),y2:Math.max(yQ1,yQ3),whiskerTop:Math.min(yMin,yMax),whiskerBottom:Math.max(yMin,yMax),center, yMed}; ctx.save(); const hovered=(c.$hoverIndex===i); ctx.strokeStyle=hovered?'#1e40af':'#64748b'; ctx.lineWidth=hovered?1.8:1.2; if(hovered){ ctx.shadowColor='rgba(30,64,175,0.35)'; ctx.shadowBlur=6; }
                    // Bigotes
                    ctx.beginPath(); ctx.moveTo(center,yMin); ctx.lineTo(center,yQ1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center,yQ3); ctx.lineTo(center,yMax); ctx.stroke();
                    // Topes
                    ctx.beginPath(); ctx.moveTo(center-12,yMin); ctx.lineTo(center+12,yMin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center-12,yMax); ctx.lineTo(center+12,yMax); ctx.stroke();
                    // Caja
                    ctx.fillStyle=hovered?'rgba(59,130,246,0.18)':'rgba(148,163,184,0.22)'; ctx.strokeStyle=hovered?'#1d4ed8':'#94a3b8'; ctx.beginPath(); ctx.rect(center-boxW/2,yQ3,boxW,yQ1-yQ3); ctx.fill(); ctx.stroke();
                    // Mediana
                    ctx.strokeStyle=hovered?'#ef4444':'#dc2626'; ctx.lineWidth=hovered?2.4:2; ctx.beginPath(); ctx.moveTo(center-boxW/2,yMed); ctx.lineTo(center+boxW/2,yMed); ctx.stroke();
                    // Label n
                    ctx.fillStyle='#334155'; ctx.font=hovered?'12px Inter':'10px Inter'; ctx.textAlign='center'; ctx.fillText('n='+s.n, center, yQ3-6);
                    ctx.restore(); }); }
                },
                {id:'boxHover',afterEvent(c,args){ const e=args.event; if(!c.$boxRects||!e) return; if(e.type==='mouseout'){ if(c.$hoverIndex!=null){ c.$hoverIndex=null; c.tooltip.setActiveElements([],{}); c.update('none'); canvas.style.cursor='default'; } return; } if(e.type!=='mousemove'&&e.type!=='click'&&e.type!=='touchmove') return; const {x,y}=e; let foundIndex=null; for(let i=0;i<c.$boxRects.length;i++){ const r=c.$boxRects[i]; if(!r) continue; if(x>=r.x1-4 && x<=r.x2+4 && y>=r.whiskerTop-4 && y<=r.whiskerBottom+4){ foundIndex=i; break; } } if(foundIndex!==c.$hoverIndex){ c.$hoverIndex=foundIndex; if(foundIndex==null){ c.tooltip.setActiveElements([],{}); canvas.style.cursor='default'; } else { c.tooltip.setActiveElements([{datasetIndex:0,index:foundIndex}],{x:c.$boxRects[foundIndex].center,y:c.$boxRects[foundIndex].yMed}); canvas.style.cursor='pointer'; } c.update('none'); } }}
            ]});
            chartsCache.push(chart);
        })();

        // 2. Stacked productivo vs muertos por amasadora
        (function(){
            const el=document.getElementById('chart-stacked-muertos'); if(!el) return;
            const amaMap={};
            datos.forEach(reg=> (reg.maquinas||[]).forEach(maq=>{
                const amaNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.id||'').match(/\d+/)?.[0]);
                const ama = (amaNumRaw && ['1','2','3'].includes(String(amaNumRaw))) ? String(amaNumRaw) : (amaNumRaw ? String(amaNumRaw) : '?');
                let tm1=0,tm2=0; if(maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime) tm1=Math.max(0,Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000));
                if(maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime) tm2=Math.max(0,Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000));
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; let totalProd=0; if(primerStart&&ultimoEnd){ totalProd=Math.max(0,Math.floor((ultimoEnd-primerStart)/1000)) - (tm1+tm2); }
                const rec = amaMap[ama] = amaMap[ama] || {prod:0, muertos:0};
                rec.prod += totalProd; rec.muertos += (tm1+tm2);
            }));
            const labels=Object.keys(amaMap);
            const prod=labels.map(l=>amaMap[l].prod);
            const muertos=labels.map(l=>amaMap[l].muertos);
            const chart = mkChart(el,'bar',{labels,datasets:[
                {label:'Productivo (s)', data:prod, backgroundColor:'#16a34a', stack:'t'},
                {label:'Muertos (s)', data:muertos, backgroundColor:'#dc2626', stack:'t'}
            ]},{responsive:true,plugins:{legend:{position:'bottom'}},
                animation:{onComplete:function(){
                    const c=this; const ctx=c.ctx; ctx.save(); ctx.font='10px Inter'; ctx.textAlign='center'; ctx.fillStyle='#111827';
                    const metaMuertos=c.getDatasetMeta(1); // top segment
                    muertos.forEach((m,i)=>{
                        const total = (prod[i]||0)+(m||0); if(!total) return;
                        const pct = (m*100/total).toFixed(1)+'% TM';
                        const bar = metaMuertos.data[i]; if(!bar) return;
                        const y = bar.y - 4; const x = bar.x; ctx.fillText(pct,x,y);
                    });
                    ctx.restore();
                }},
                scales:{x:{stacked:true}, y:{stacked:true, beginAtZero:true}}});
            chart.$stackVals={prod,muertos};
        })();

        // 3. Scatter temperatura masa vs tiempo total
        (function(){
            const el=document.getElementById('chart-scatter-temp-tiempo'); if(!el) return;
            const puntos=[];
            datos.forEach(reg=> (reg.maquinas||[]).forEach(maq=>{
                const tm=parseFloat(maq.tempMasa); if(isNaN(tm)) return;
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; if(!(primerStart&&ultimoEnd)) return;
                const total=Math.max(0,Math.floor((ultimoEnd-primerStart)/1000));
                puntos.push({x:tm,y:total});
            }));
            // Regresión lineal simple
            if(puntos.length>1){
                const n=puntos.length; let sumX=0,sumY=0,sumXY=0,sumX2=0,sumY2=0; puntos.forEach(p=>{sumX+=p.x; sumY+=p.y; sumXY+=p.x*p.y; sumX2+=p.x*p.x; sumY2+=p.y*p.y;});
                const denom = (n*sumX2 - sumX*sumX);
                let m=0,b=0,r=0; if(denom!==0){ m=(n*sumXY - sumX*sumY)/denom; b=(sumY - m*sumX)/n; const rDen=Math.sqrt((n*sumX2 - sumX*sumX)*(n*sumY2 - sumY*sumY)); if(rDen) r=(n*sumXY - sumX*sumY)/rDen; }
                const xs=puntos.map(p=>p.x); const minX=Math.min(...xs); const maxX=Math.max(...xs);
                const regData=[{x:minX,y:m*minX+b},{x:maxX,y:m*maxX+b}];
                const chart = mkChart(el,'scatter',{datasets:[
                    {label:'Temp vs Tiempo (s)', data:puntos, backgroundColor:'#2563eb'},
                    {type:'line', label:'Regresión', data:regData, borderColor:'#f59e0b', borderWidth:2, pointRadius:0, fill:false}
                ]},{responsive:true, scales:{x:{title:{display:true,text:'Temp masa (°C)'}}, y:{title:{display:true,text:'Tiempo total (s)'}, beginAtZero:true}}, plugins:{legend:{position:'bottom'}}});
                // Mostrar r en esquina superior
                setTimeout(()=>{
                    const ctx = chart.ctx; ctx.save(); ctx.font='12px Inter'; ctx.fillStyle='#1f2937';
                    ctx.fillText('r = '+r.toFixed(3), 50, 20); ctx.restore();
                },60);
            } else {
                mkChart(el,'scatter',{datasets:[{label:'Temp vs Tiempo (s)', data:puntos, backgroundColor:'#2563eb'}]},{responsive:true, scales:{x:{title:{display:true,text:'Temp masa (°C)'}}, y:{title:{display:true,text:'Tiempo total (s)'}, beginAtZero:true}}, plugins:{legend:{position:'bottom'}}});
            }
        })();
    }

    // ====== Export Tablas (CSV / PDF) ======
    function computeTablasStatsFromData(datos){
        const procesosNombres=['Esponja','Masa','Mantequilla'];
        let totalGenerales=[]; let procesoStats=[[],[],[]];
        let masaStats={}, amasadoraStats={}, tempMasaStats={}, tempCrossRaw=[];
        datos.forEach(reg=>{
            (reg.maquinas||[]).forEach(maq=>{
                const p1=maq.proceso1, p3=maq.proceso3;
                if(p1&&p1.startTime && p3 && p3.endTime){
                    const total=Math.max(0,Math.floor((p3.endTime-p1.startTime)/1000));
                    totalGenerales.push(total);
                }
                for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ const t=(parseInt(p.minutos)||0)*60+(parseInt(p.segundos)||0); procesoStats[i-1].push(t);} }
                const tipo=maq.tipoMasa||maq.tipoPan||'Sin tipo';
                const amaNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.id||'').match(/\d+/)?.[0]);
                const ama = (amaNumRaw && ['1','2','3'].includes(String(amaNumRaw))) ? String(amaNumRaw) : (amaNumRaw ? String(amaNumRaw) : '?');
                let totalSimple=0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ totalSimple += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0);} }
                (masaStats[tipo]=masaStats[tipo]||[]).push(totalSimple);
                (amasadoraStats[ama]=amasadoraStats[ama]||[]).push(totalSimple);
                const tm=parseFloat(maq.tempMasa); if(!isNaN(tm)){ (tempMasaStats[tipo]=tempMasaStats[tipo]||[]).push(tm); tempCrossRaw.push({tipo,ama,tm}); }
            });
        });
        // Resumen
        const resumenRows=[];
        if(totalGenerales.length){ const prom=Math.round(totalGenerales.reduce((a,b)=>a+b,0)/totalGenerales.length); const desv=Math.round(std(totalGenerales)); resumenRows.push(['N registros', totalGenerales.length],['Promedio total (s)',prom],['Desv (s)',desv],['%Desv',percent(desv,prom)]);}        
        procesoStats.forEach((arr,i)=>{ if(arr.length){ const prom=Math.round(arr.reduce((a,b)=>a+b,0)/arr.length); const desv=Math.round(std(arr)); resumenRows.push([`Prom ${procesosNombres[i]} (s)`,prom],[`Desv ${procesosNombres[i]} (s)`,desv],[`%Desv ${procesosNombres[i]}`,percent(desv,prom)]);} });
        // Pan rows
        const panRows=Object.keys(masaStats).map(k=>{const a=masaStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        // Amasadora rows
    const amaRows=Object.keys(amasadoraStats).map(k=>{const a=amasadoraStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        // Proceso rows
        const procesosN=['Esponja','Masa','Mantequilla'];
        const procRows=procesoStats.map((a,i)=> a.length? [procesosN[i], a.length, Math.round(a.reduce((x,y)=>x+y,0)/a.length), Math.round(std(a)), percent(Math.round(std(a)), Math.round(a.reduce((x,y)=>x+y,0)/a.length))]: null).filter(Boolean);
        // Temp por tipo
        const tempRows=Object.keys(tempMasaStats).map(k=>{const a=tempMasaStats[k]; const m=a.reduce((x,y)=>x+y,0)/a.length; const d=std(a); return [k,a.length,m.toFixed(1),d.toFixed(1),percent(d,m)];});
        // Cruzada temp
        const tiposOrden = Array.from(new Set(tempCrossRaw.map(r=>r.tipo)));
        const amasOrden = Array.from(new Set(tempCrossRaw.map(r=>r.ama)));
        const cruzHeaders=['Amasadora', ...tiposOrden];
        const cruzRows = amasOrden.map(a=>{
            const c=[a];
            tiposOrden.forEach(t=>{
                const subset = tempCrossRaw.filter(r=>r.ama===a && r.tipo===t).map(r=>r.tm);
                if(subset.length){ const avg=subset.reduce((x,y)=>x+y,0)/subset.length; c.push(avg.toFixed(1)); } else { c.push(''); }
            });
            return c;
        });
        return { resumenRows, panRows, amaRows, procRows, tempRows, cruzHeaders, cruzRows };
    }

    function exportTablasCSV(){
        const datos = getTablasData();
        if(!datos || !datos.length){ alert('No hay datos para exportar.'); return; }
    const { resumenRows, panRows, amaRows, procRows, tempRows, cruzHeaders, cruzRows } = computeTablasStatsFromData(datos);
        const rows=[];
        // Metadatos
    const fuenteCSV = (document.getElementById('tablas-source')?.value)||localStorage.getItem('TABLAS_SOURCE')||'local';
        const modo = localStorage.getItem('TABLAS_FECHA_MODO')||'rango';
        const diaSel = localStorage.getItem('TABLAS_BD_DIA')||'';
        const stamp = new Date().toISOString();
        const totalMaquinas = datos.reduce((a,r)=> a + (r.maquinas? r.maquinas.length:0),0);
    rows.push(['# Fuente', fuenteCSV]);
        rows.push(['# ModoFecha', modo]);
        if(diaSel) rows.push(['# DiaSeleccionado', diaSel]);
        rows.push(['# Registros(fecha)', datos.length]);
        rows.push(['# TotalMaquinas', totalMaquinas]);
        rows.push(['# Generado', stamp]);
        rows.push([]);
        rows.push(['Resumen de tiempos (s)']); rows.push(['Métrica','Valor']); resumenRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Promedios por tipo de masa']); rows.push(['Tipo masa','N','Prom (s)','Desv (s)','%Desv']); panRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Promedios por amasadora']); rows.push(['Amasadora','N','Prom (s)','Desv (s)','%Desv']); amaRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Promedios por proceso']); rows.push(['Proceso','N','Prom (s)','Desv (s)','%Desv']); procRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Temperatura por tipo de masa']); rows.push(['Tipo masa','N','Prom (°C)','Desv (°C)','%Desv']); tempRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Temp. masa (Amasadora vs Tipo de masa)']); rows.push(cruzHeaders); cruzRows.forEach(r=> rows.push(r)); rows.push([]);
        // Personal por día (mín–máx)
        rows.push(['Personal por día (mín–máx)']); rows.push(['Fecha','N máquinas','Personal mín','Personal máx','Midpoint','Rango']);
        (function(){
            const perDay = {};
            datos.forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const bucket = perDay[fecha] = perDay[fecha] || { n:0, mins:[], maxs:[] };
                bucket.n += (reg.maquinas||[]).length;
                (reg.maquinas||[]).forEach(m=>{
                    const vmin = parseInt(m.personalMin); if(!isNaN(vmin)) bucket.mins.push(vmin);
                    const vmax = parseInt(m.personalMax); if(!isNaN(vmax)) bucket.maxs.push(vmax);
                });
                if(bucket.mins.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) bucket.mins.push(v); }
                if(bucket.maxs.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) bucket.maxs.push(v); }
            });
            Object.keys(perDay).sort().forEach(fecha=>{
                const b=perDay[fecha];
                if(!(b.mins.length||b.maxs.length)) return;
                const min = b.mins.length? Math.min(...b.mins): '';
                const max = b.maxs.length? Math.max(...b.maxs): '';
                const midpoint = (typeof min==='number' && typeof max==='number')? Math.round((min + max)/2) : '';
                const rango = (typeof min==='number' && typeof max==='number')? (max - min) : '';
                rows.push([fecha, b.n, min, max, midpoint, rango]);
            });
        })();
        // TA/H por día
        rows.push([]);
        rows.push(['TA y Humedad por día']);
        rows.push(['Fecha','N máquinas','TA prom','H prom']);
        (function(){
            const acc={};
            const datos = getTablasData();
            (datos||[]).forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const b = acc[fecha] = acc[fecha] || { n:0, ta:[], h:[] };
                const maquinas = reg.maquinas||[]; b.n += maquinas.length;
                maquinas.forEach(m=>{
                    const ta = parseFloat(m.tempAmbiente); if(Number.isFinite(ta)) b.ta.push(ta);
                    const h = parseFloat(m.humedad); if(Number.isFinite(h)) b.h.push(h);
                });
                if(b.ta.length===0 && maquinas[0]){ const v=parseFloat(maquinas[0].tempAmbiente); if(Number.isFinite(v)) b.ta.push(v); }
                if(b.h.length===0 && maquinas[0]){ const v=parseFloat(maquinas[0].humedad); if(Number.isFinite(v)) b.h.push(v); }
            });
            Object.keys(acc).sort().forEach(fecha=>{
                const b=acc[fecha];
                if(!(b.ta.length||b.h.length)) return;
                const taProm = b.ta.length? (b.ta.reduce((x,y)=>x+y,0)/b.ta.length).toFixed(1): '';
                const hProm = b.h.length? (b.h.reduce((x,y)=>x+y,0)/b.h.length).toFixed(1): '';
                rows.push([fecha, b.n, taProm, hProm]);
            });
        })();
        // CSV manual
        const csv = rows.map(r=> r.map(v=> '"'+String(v==null?'':v).replace(/"/g,'""')+'"').join(',')).join('\r\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const fuente = (document.getElementById('tablas-source')?.value)||localStorage.getItem('TABLAS_SOURCE')||'local';
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download= fuente==='bd' ? 'tablas_bd.csv' : 'tablas_local.csv'; a.click(); URL.revokeObjectURL(a.href);
    }

    async function exportTablasPDF(){
        const { jsPDF } = window.jspdf || {};
        if(!jsPDF){ alert('jsPDF no cargó'); return; }
        const wrap = document.getElementById('tablas-wrapper') || document.getElementById('view-tablas');
        if(!wrap){ alert('No se encontró el contenedor de Tablas'); return; }
        try{
            const canvas = await html2canvas(wrap, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF('p','pt','a4');
            const pageW=pdf.internal.pageSize.getWidth();
            const pageH=pdf.internal.pageSize.getHeight();
            const imgW = pageW - 40; // margins
            const imgH = canvas.height * imgW / canvas.width;
            let y=20; let x=20;
            if(imgH <= pageH - 40){
                pdf.addImage(imgData, 'PNG', x, y, imgW, imgH);
            }else{
                // Paginar manualmente cortando el canvas en tramos
                const pageCanvas = document.createElement('canvas');
                const pageCtx = pageCanvas.getContext('2d');
                const ratio = imgW / canvas.width; // scale
                const pagePixelH = Math.floor((pageH - 40) / ratio);
                let offsetY = 0; let page=1;
                while(offsetY < canvas.height){
                    pageCanvas.width = canvas.width; pageCanvas.height = Math.min(pagePixelH, canvas.height - offsetY);
                    pageCtx.fillStyle = '#ffffff'; pageCtx.fillRect(0,0,pageCanvas.width,pageCanvas.height);
                    pageCtx.drawImage(canvas, 0, offsetY, pageCanvas.width, pageCanvas.height, 0, 0, pageCanvas.width, pageCanvas.height);
                    const segData = pageCanvas.toDataURL('image/png');
                    if(page>1) pdf.addPage();
                    pdf.addImage(segData, 'PNG', x, y, imgW, pageCanvas.height * ratio);
                    offsetY += pagePixelH; page++;
                }
            }
            const fuente = (document.getElementById('tablas-source')?.value)||localStorage.getItem('TABLAS_SOURCE')||'local';
            pdf.save(fuente==='bd' ? 'tablas_bd.pdf' : 'tablas_local.pdf');
        }catch(e){ alert('Error exportando PDF: '+(e.message||e)); }
    }

    document.getElementById('tablas-export-csv')?.addEventListener('click', exportTablasCSV);
    document.getElementById('tablas-export-pdf')?.addEventListener('click', exportTablasPDF);

    // ================= EXPORT SOLO RESULTADOS =================
    function getResultadosSource(){
        const bdW = document.getElementById('bd-wrapper');
        const isBD = bdW && !bdW.classList.contains('hidden');
        return isBD ? 'bd' : 'local';
    }
    function normalizeMaqForExport(m){
        if(m && !m.proceso1 && Array.isArray(m.procesos)){
            const map = {};
            m.procesos.forEach(p=>{ if(p && p.id!=null){ map['proceso'+p.id] = { minutos: p.minutos||0, segundos: p.segundos||0, startTime: p.startTime||null, endTime: p.endTime||null }; } });
            return { ...m, ...map };
        }
        return m;
    }
    function mapBDToResultados(arr){
        return (arr||[]).map(it=>({
            fecha: it?.data?.fecha || it?.fecha || '',
            maquinas: (it?.data?.amasadoras||[]).map(normalizeMaqForExport)
        }));
    }
    async function exportResultadosTabPDF(){
        const { jsPDF } = window.jspdf || {};
        if(!jsPDF){ alert('jsPDF no cargó'); return; }
        const source = getResultadosSource();
        let resultados = [];
        if(source==='bd'){
            // Usar caché BD si está disponible; de lo contrario, traerlo
            let data = Array.isArray(window.BD_CACHE)? window.BD_CACHE : [];
            if(!data || !data.length){ try{ data = await fetchRegistrosBD(); }catch(_){} }
            resultados = mapBDToResultados(data);
        }else{
            resultados = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        }
        if(!resultados.length){ alert('No hay resultados'); return; }
        const pdf = new jsPDF('p','pt','a4');
        const marginX=32, marginY=40; const pageW=pdf.internal.pageSize.getWidth(); const pageH=pdf.internal.pageSize.getHeight();
        let y=marginY; let page=1;
        function header(){
            pdf.setFontSize(14); pdf.setTextColor(30); pdf.text('Reporte de Resultados (Tabla)', marginX, 28);
            pdf.setFontSize(9); pdf.setTextColor(90); pdf.text(new Date().toLocaleString(), marginX, 40);
        }
        function footer(){
            const total=pdf.internal.getNumberOfPages();
            pdf.setFontSize(9); pdf.setTextColor(110);
            const foot='Página '+page+' / '+total; const w=pdf.getTextWidth(foot);
            pdf.text(foot, pageW - marginX - w, pageH - 12);
        }
        header();
        // Construir filas normalizadas como en CSV
    const diasN=['Dom','Lun','Mar','Mie','Jue','Vie','Sab'];
        // Encabezados (incluye Pers(rango) y Pers(mid))
    const cols=['Fecha','Lote','Dia','TA','H','Pers(rango)','Pers(mid)','Am','Tipo','Hi','TM','Pr','Min','Seg','Ini','Fin','T1','T2','TMT','Tot(s)','Obs'];
        // Nota: estos anchos pueden exceder el ancho de la página, manteniendo el estilo existente
        const colWidths=[55,40,40,25,25,40,28,40,55,35,40,36,24,24,40,40,28,28,36,42,90];
        function drawHeaderRow(){
            pdf.setFontSize(8); pdf.setFont('helvetica','bold'); pdf.setTextColor(20);
            let x=marginX; const h=14; pdf.setDrawColor(200); pdf.setLineWidth(0.25);
            cols.forEach((c,i)=>{ pdf.rect(x,y-10,colWidths[i],h,'S'); pdf.text(c, x+2, y); x+=colWidths[i]; });
            y+=2; pdf.setFont('helvetica','normal');
        }
        y+=20; drawHeaderRow(); y+=6;
        let prevFecha=null;
        resultados.sort((a,b)=>(a.fecha||'').localeCompare(b.fecha||''));
        resultados.forEach(reg=>{
            const fecha=reg.fecha||''; let dia='';
            if(fecha && fecha.length===10){ const [Y,M,D]=fecha.split('-').map(Number); dia=diasN[new Date(Y,M-1,D).getDay()]||''; }
            let dailyTA='', dailyH='';
            if(reg.maquinas && reg.maquinas.length){ const m0=reg.maquinas[0]; dailyTA=m0.tempAmbiente||''; dailyH=m0.humedad||''; }
            // Agregar personas por día (rango y midpoint)
            let pmins=[], pmaxs=[];
            (reg.maquinas||[]).forEach(m=>{ const vmin=parseInt(m.personalMin); if(!isNaN(vmin)) pmins.push(vmin); const vmax=parseInt(m.personalMax); if(!isNaN(vmax)) pmaxs.push(vmax); });
            if(!pmins.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) pmins.push(v); }
            if(!pmaxs.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) pmaxs.push(v); }
            const dailyPersMin = pmins.length? Math.min(...pmins): '';
            const dailyPersMax = pmaxs.length? Math.max(...pmaxs): '';
            const dailyPersMid = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? Math.round((dailyPersMin+dailyPersMax)/2): '';
            const dailyPersRange = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? `${dailyPersMin}-${dailyPersMax}`: '';
            (reg.maquinas||[]).forEach(maq=>{
                let tm1='', tm2='';
                if(maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime){ tm1=Math.max(0,Math.floor((maq.proceso2.startTime-maq.proceso1.endTime)/1000)); }
                if(maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime){ tm2=Math.max(0,Math.floor((maq.proceso3.startTime-maq.proceso2.endTime)/1000)); }
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; let totalSeg=null; if(primerStart&&ultimoEnd) totalSeg=Math.max(0,Math.floor((ultimoEnd-primerStart)/1000));
                const tmTot=(tm1||0)+(tm2||0);
                for(let i=1;i<=3;i++){
                    const proc=maq['proceso'+i]||{}; const min=proc.minutos||0; const seg=proc.segundos||0; const ini=proc.startTime? new Date(proc.startTime).toLocaleTimeString():''; const fin=proc.endTime? new Date(proc.endTime).toLocaleTimeString():'';
                    const row=[
                        i===1? (prevFecha===fecha?'':fecha):'',
                        i===1? (maq.lote||''):'',
                        i===1? (prevFecha===fecha?'':dia):'',
                        i===1? (prevFecha===fecha?'':dailyTA):'',
                        i===1? (prevFecha===fecha?'':dailyH):'',
                        i===1? (prevFecha===fecha?'':dailyPersRange):'',
                        i===1? (prevFecha===fecha?'':dailyPersMid):'',
                        i===1? ( (maq.numeroAmasadora||((maq.nombre||maq.id||'').match(/\d+/)?.[0])||'?') ):'',
                        i===1? (maq.tipoMasa||maq.tipoPan||''):'',
                        i===1? (maq.hielo||''):'',
                        i===1? (maq.tempMasa||''):'',
                        ['Esp','Mas','Mant'][i-1],
                        min, seg, ini, fin,
                        i===1? tm1:'', i===1? tm2:'', i===1? tmTot:'', i===1? (totalSeg??''):'', i===1? (maq.observaciones||''):''
                    ];
                    // Salto de página si necesario
                    if(y+14>pageH-30){ footer(); pdf.addPage(); page++; header(); y=marginY+10; drawHeaderRow(); y+=6; }
                    let x=marginX; const h=12; pdf.setFontSize(7.5); pdf.setDrawColor(225); pdf.setFillColor(255,255,255); pdf.setTextColor(40);
                    row.forEach((cell,ci)=>{
                        let txt=(''+(cell==null?'':cell));
                        if(txt.length>18) txt=txt.slice(0,17)+'…';
                        pdf.rect(x,y-9,colWidths[ci],h,'S');
                        pdf.text(txt, x+2, y);
                        x+=colWidths[ci];
                    });
                    y+=h-2;
                }
                prevFecha=fecha;
            });
        });
        footer();
        const stamp=new Date().toISOString().replace(/[:T]/g,'-').split('.')[0];
        pdf.save(`resultados_${source}_tabla_${stamp}.pdf`);
    }
    // CSV ordenado y compactando factores solo una vez (Locales o BD según subpestaña)
    async function exportResultadosTabCSV(){
        const source = getResultadosSource();
        let resultados = [];
        if(source==='bd'){
            let data = Array.isArray(window.BD_CACHE)? window.BD_CACHE : [];
            if(!data || !data.length){ try{ data = await fetchRegistrosBD(); }catch(_){} }
            resultados = mapBDToResultados(data);
        }else{
            resultados = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        }
        if(!resultados.length){ alert('No hay resultados'); return; }
        // Ordenar por fecha
        resultados.sort((a,b)=> (a.fecha||'').localeCompare(b.fecha||''));
        const rows=[];
        // Encabezados principales
        const headers=[
            'Fecha','Lote','Dia','TA','H','Pers(rango)','Pers(mid)',
            'Am','Tipo','Hi','TM',
            'Pr','Min','Seg','Ini','Fin','T1','T2','TMT','Tot(s)','Obs'
        ];
        rows.push(headers);
    const diasN=['Dom','Lun','Mar','Mie','Jue','Vie','Sab'];
        let fechaPrev=null;
        resultados.forEach(reg=>{
            const fecha=reg.fecha||'';
            let dia='';
            if(fecha && fecha.length===10){ const [y,m,d]=fecha.split('-').map(Number); dia=diasN[new Date(y,m-1,d).getDay()]||''; }
            // Factores diarios (TA,H) y Personas (rango y midpoint)
            let dailyTA=''; let dailyH='';
            if(reg.maquinas && reg.maquinas.length){ const m0=reg.maquinas[0]; dailyTA=m0.tempAmbiente||''; dailyH=m0.humedad||''; }
            // Personal por día (rango y midpoint) agregado en este registro
            let pmins=[], pmaxs=[];
            (reg.maquinas||[]).forEach(m=>{ const vmin=parseInt(m.personalMin); if(!isNaN(vmin)) pmins.push(vmin); const vmax=parseInt(m.personalMax); if(!isNaN(vmax)) pmaxs.push(vmax); });
            if(!pmins.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) pmins.push(v); }
            if(!pmaxs.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) pmaxs.push(v); }
            const dailyPersMin = pmins.length? Math.min(...pmins): '';
            const dailyPersMax = pmaxs.length? Math.max(...pmaxs): '';
            const dailyPersMid = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? Math.round((dailyPersMin+dailyPersMax)/2): '';
            const dailyPersRange = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? `${dailyPersMin}-${dailyPersMax}`: '';
            (reg.maquinas||[]).forEach(maq=>{
                const baseFecha = (fechaPrev===fecha)? '' : fecha; // solo primera vez del día
                const baseDia = (baseFecha? dia : '');
                const baseTA = (baseFecha? dailyTA : '');
                const baseH = (baseFecha? dailyH : '');
                const basePersRange = (baseFecha? dailyPersRange : '');
                const basePersMid = (baseFecha? dailyPersMid : '');
                fechaPrev=fecha; // marcar
                // Calcular tiempos muertos máquina
                let tm1='', tm2='';
                if(maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime){ tm1 = Math.max(0, Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000)); }
                if(maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime){ tm2 = Math.max(0, Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000)); }
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; let totalSeg=null; if(primerStart && ultimoEnd){ totalSeg=Math.max(0, Math.floor((ultimoEnd - primerStart)/1000)); }
                const tmTotal = (tm1||0)+(tm2||0);
                for(let i=1;i<=3;i++){
                    const proc=maq['proceso'+i]||{};
                    const minutos=proc.minutos||0; const segundos=proc.segundos||0;
                    const inicio=proc.startTime? new Date(proc.startTime).toLocaleTimeString():'';
                    const fin=proc.endTime? new Date(proc.endTime).toLocaleTimeString():'';
                    rows.push([
                        i===1? baseFecha:'',
                        i===1? (maq.lote||''):'',
                        i===1? baseDia:'',
                        i===1? baseTA:'',
                        i===1? baseH:'',
                        i===1? basePersRange:'',
                        i===1? basePersMid:'',
                        i===1? ( (maq.numeroAmasadora||((maq.nombre||maq.id||'').match(/\d+/)?.[0])||'?') ):'',
                        i===1? (maq.tipoMasa||maq.tipoPan||''):'',
                        i===1? (maq.hielo||''):'',
                        i===1? (maq.tempMasa||''):'',
                        ['Esp','Mas','Mant'][i-1],
                        minutos, segundos, inicio, fin,
                        i===1? tm1:'', i===1? tm2:'', i===1? tmTotal:'', i===1? (totalSeg??''):'', i===1? (maq.observaciones||''):'']);
                }
            });
        });
        // Convertir a CSV manualmente para evitar dependencias
        const csv = rows.map(r=> r.map(v=>{
            const s = (v===null||v===undefined)? '' : (''+v).replace(/"/g,'""');
            return '"'+s+'"';
        }).join(',')).join('\r\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const stamp = new Date().toISOString().replace(/[:T]/g,'-').split('.')[0];
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`resultados_${source}_ordenado_${stamp}.csv`; a.click(); URL.revokeObjectURL(a.href);
    }
    document.addEventListener('DOMContentLoaded', ()=>{
        initAuthUI();
        guardRoute();
        // Actualizar visibilidad de Ajustes según estado de sesión
        try{ updateAjustesVisibility(); }catch(_){ }
        document.getElementById('btn-export-resultados-pdf')?.addEventListener('click', exportResultadosTabPDF);
        document.getElementById('btn-export-resultados-csv')?.addEventListener('click', exportResultadosTabCSV);
            // Toggle descripciones de gráficas
            document.querySelectorAll('#view-tablas .chart-title').forEach(h=>{
                h.addEventListener('click', ()=>{
                    const desc = h.nextElementSibling;
                    if(desc && desc.classList.contains('chart-desc')){
                        desc.style.display = (desc.style.display==='none'|| !desc.style.display)?'block':'none';
                    }
                });
                // iniciar oculto siempre
                const d=h.nextElementSibling; if(d && d.classList.contains('chart-desc')) d.style.display='none';
            });
        // Inyección de controles BD si aún no existen (sin override de API)
        if(!document.getElementById('sync-status')){
            const filtros = document.querySelector('#view-resultados .flex.flex-wrap.gap-4');
            if(filtros){
                const extra = document.createElement('div');
                extra.className='flex flex-wrap gap-2 items-center';
                extra.innerHTML = `
                    <div class="flex flex-wrap gap-2 items-center">
                        <button id="btn-sync-bd" class="bg-indigo-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-indigo-700">Ver resultados previos</button>
                        <button id="btn-pasar-fecha-bd" class="bg-amber-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-amber-700" title="Guardar todos los registros de la fecha seleccionada en la base de datos">Guardar resultados en la BD</button>
                    </div>
                    <div id="sync-status" class="text-xs text-stone-600 mt-1 w-full"></div>
                `;
                filtros.parentNode.insertBefore(extra, filtros.nextSibling);
            }
        }
        initApiLogic();
    });

    // ================= BACKEND SYNC / API DINÁMICA =================
    function getDefaultApiBase(){
        try{
            // Siempre usar la URL pública del backend
            return 'https://pdt-backend-1.onrender.com';
        }catch(_){ return ''; }
    }
    function resolveApiBase(){
        const override = localStorage.getItem('API_URL_OVERRIDE');
        return (override && override.trim()) || getDefaultApiBase();
    }
    // API auth helpers: read key from session/local and build headers
    function getApiKey(){
        return sessionStorage.getItem('API_KEY') || localStorage.getItem('API_KEY_PERSIST') || '';
    }
    function apiHeaders(withJson){
        const h = {};
        if(withJson) h['Content-Type'] = 'application/json';
        const k = getApiKey();
        if(k) h['x-api-key'] = k;
        return h;
    }
    function setStatus(msg,type='info'){
        const el=document.getElementById('sync-status');
        if(el){ el.textContent = msg; el.className = 'text-xs mt-1 '+(type==='err'?'text-red-600': type==='ok'?'text-green-600':'text-stone-600'); }
    }
    // Toast amigable
    function mostrarToast(msg, tipo='success'){
        let toast = document.getElementById('toast-msg');
        if(!toast){
            toast = document.createElement('div');
            toast.id = 'toast-msg';
            toast.style.position = 'fixed';
            toast.style.bottom = '30px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.zIndex = '9999';
            toast.style.padding = '16px 32px';
            toast.style.borderRadius = '12px';
            toast.style.fontSize = '1.1rem';
            toast.style.fontWeight = 'bold';
            toast.style.boxShadow = '0 2px 12px rgba(0,0,0,0.12)';
            document.body.appendChild(toast);
        }
        toast.textContent = msg;
        toast.style.background = tipo==='success' ? '#22c55e' : '#ef4444';
        toast.style.color = '#fff';
        toast.style.opacity = '1';
        setTimeout(()=>{ toast.style.opacity = '0'; }, 3000);
    }
    function signature(fecha, maq){
        const p1Start = maq?.proceso1?.startTime || ''; // puede ser null
        const tipo = (maq?.tipoMasa||maq?.tipoPan||'').trim().toLowerCase();
        return `${fecha}__${(maq?.nombre||maq?.id||'').trim()}__${tipo}__${p1Start}`;
    }
    // ========= Seguridad simple: clave local =========
    const DEFAULT_PASS = 'pasantias'; // Clave fija para acceso y API
    async function sha256Hex(str){
        const enc = new TextEncoder(); const data = enc.encode(str);
        const hash = await crypto.subtle.digest('SHA-256', data);
        const bytes = Array.from(new Uint8Array(hash));
        return bytes.map(b=> b.toString(16).padStart(2,'0')).join('');
    }
    function showAuthOverlay(){ const ov=document.getElementById('auth-overlay'); if(ov) ov.classList.remove('hidden'); }
    function hideAuthOverlay(){ const ov=document.getElementById('auth-overlay'); if(ov) ov.classList.add('hidden'); }
    function isLocked(){ return localStorage.getItem('APP_LOCKED')==='1'; }
    function lockApp(){ localStorage.setItem('APP_LOCKED','1'); sessionStorage.removeItem('APP_UNLOCKED'); try{ updateAjustesVisibility(); }catch(_){ } showAuthOverlay(); }
    async function tryLogin(pass){
        const saved = localStorage.getItem('APP_PASS_HASH');
        if(!saved) return false;
        const h = await sha256Hex(pass);
        return h===saved;
    }
    async function setNewPass(pass){ /* Deshabilitado: clave fija */ return; }
    function isRemembered(){ return localStorage.getItem('APP_REMEMBER')==='1'; }
    function markRemembered(on){ if(on) localStorage.setItem('APP_REMEMBER','1'); else localStorage.removeItem('APP_REMEMBER'); }
    function isUnlocked(){ return !isLocked() && (sessionStorage.getItem('APP_UNLOCKED')==='1' || isRemembered()); }
    function updateAjustesVisibility(){
        const card = document.getElementById('ajustes-card');
        if(!card) return;
        card.classList.toggle('hidden', !isUnlocked());
    }

    function initAuthUI(){
        const btnLock = document.getElementById('btn-lock-app');
        btnLock?.addEventListener('click', ()=> lockApp());
        const ov = document.getElementById('auth-overlay'); if(!ov) return;
        // Forzar hash de clave fija
    try{ sha256Hex(DEFAULT_PASS).then(h=> localStorage.setItem('APP_PASS_HASH', h)); }catch(_){ }
        // Rate limiting simple
        function authMeta(){
            try{ return JSON.parse(localStorage.getItem('AUTH_META')||'{}'); }catch(_){ return {}; }
        }
        function saveAuthMeta(m){ localStorage.setItem('AUTH_META', JSON.stringify(m)); }
        function canTry(){
            const m=authMeta();
            const now=Date.now();
            if(m.lockUntil && now < m.lockUntil) return false;
            return true;
        }
        function registerFail(){
            const m=authMeta();
            m.failCount = (m.failCount||0)+1;
            if(m.failCount>=5){
                // Bloqueo exponencial suave: 30s * 2^(failCount-5) (máx 10 min)
                const extra = Math.min(600000, 30000 * Math.pow(2, m.failCount-5));
                m.lockUntil = Date.now() + extra;
            }
            saveAuthMeta(m);
        }
        function registerSuccess(){ saveAuthMeta({ failCount:0, lockUntil:0 }); }
        // Cancel estricto: si está bloqueado, no permite cerrar el overlay
        document.getElementById('auth-cancel')?.addEventListener('click', ()=>{
            if(isLocked()){
                // Mantener overlay visible y dar feedback sutil
                const msg = document.getElementById('auth-msg');
                if(msg){ msg.textContent = 'App bloqueada: ingresa la clave o restablécela.'; msg.className='mt-3 text-sm text-red-600'; }
                return;
            }
            hideAuthOverlay();
        });
        document.getElementById('auth-submit')?.addEventListener('click', async ()=>{
            const msgEl = document.getElementById('auth-msg'); msgEl.textContent=''; msgEl.className='mt-3 text-sm';
            if(!canTry()){
                const m=authMeta();
                const wait = Math.max(0, Math.floor(((m.lockUntil||0)-Date.now())/1000));
                msgEl.textContent='Demasiados intentos. Espera '+wait+'s.'; msgEl.classList.add('text-red-600');
                return;
            }
            const pass = document.getElementById('auth-pass').value;
            if(pass!==DEFAULT_PASS){ msgEl.textContent='Clave incorrecta.'; msgEl.classList.add('text-red-600'); try{ registerFail(); }catch(_){ } return; }
            sessionStorage.setItem('APP_UNLOCKED','1');
            const remember = document.getElementById('auth-recordar').checked; markRemembered(remember);
            if(remember) localStorage.removeItem('APP_LOCKED');
            try{ updateAjustesVisibility(); }catch(_){ }
            hideAuthOverlay();
            registerSuccess();
        });
        showAuthOverlay();
    }
    function guardRoute(){
        const hasPass = !!localStorage.getItem('APP_PASS_HASH');
        const unlockedSession = sessionStorage.getItem('APP_UNLOCKED')==='1';
        const remembered = isRemembered();
        if(!hasPass){ return; } // sin clave, no bloquear
    if(isLocked()) { showAuthOverlay(); return; }
        if(remembered){ hideAuthOverlay(); return; }
        if(!unlockedSession){ showAuthOverlay(); }
    }
    function mergeLocalRemote(localRegs, remoteRegs){
        const sigSet = new Set();
        localRegs.forEach(r=> (r.maquinas||[]).forEach(m=> sigSet.add(signature(r.fecha,m))));
        let nuevos=0;
        remoteRegs.forEach(r=>{
            (r.maquinas||[]).forEach(m=>{
                const sig = signature(r.fecha,m);
                if(!sigSet.has(sig)){
                    // Normalizar objeto remoto a formato local (quitar campos adicionales)
                    const mLoc = {
                        id: m.id || m.nombre || '',
                        nombre: m.nombre || m.id || '',
                        tipoMasa: m.tipoMasa || m.tipoPan || '',
                        hielo: m.hielo || '',
                        personal: m.personal || '',
                        tempAmbiente: m.tempAmbiente || r.tempAmbiente || '',
                        humedad: m.humedad || r.humedad || '',
                        tempMasa: m.tempMasa || '',
                        observaciones: m.observaciones || '',
                        proceso1: m.proceso1 ? { minutos: m.proceso1.minutos||0, segundos: m.proceso1.segundos||0, startTime: m.proceso1.startTime||null, endTime: m.proceso1.endTime||null } : undefined,
                        proceso2: m.proceso2 ? { minutos: m.proceso2.minutos||0, segundos: m.proceso2.segundos||0, startTime: m.proceso2.startTime||null, endTime: m.proceso2.endTime||null } : undefined,
                        proceso3: m.proceso3 ? { minutos: m.proceso3.minutos||0, segundos: m.proceso3.segundos||0, startTime: m.proceso3.startTime||null, endTime: m.proceso3.endTime||null } : undefined
                    };
                    // Insertar en local
                    let target = localRegs.find(x=>x.fecha===r.fecha);
                    if(!target){ target = { fecha: r.fecha, maquinas: [] }; localRegs.push(target); }
                    target.maquinas.push(mLoc); nuevos++;
                    sigSet.add(sig);
                }
            });
        });
        return { merged: localRegs, nuevos };
    }
    async function fetchRegistrosBD(){
    const base = resolveApiBase();
    // Siempre usar /registros directo, sin /api
    const url = base + '/registros';
    const r = await fetch(url, { headers: apiHeaders(false) });
        if(!r.ok) throw new Error('Error HTTP '+r.status);
        return await r.json();
    }
    async function syncDesdeBD(){
        try{
            setStatus('Sincronizando...');
            const rem = await fetchRegistrosBD();
            let local = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            const { merged, nuevos } = mergeLocalRemote(local, rem);
            if(nuevos){
                localStorage.setItem('resultadosMezclado', JSON.stringify(merged));
                setStatus(`Sync completado. Nuevos registros: ${nuevos}`, 'ok');
            } else {
                setStatus('Sync completado. No había nuevos registros.', 'info');
            }
            // Refrescar vistas si están visibles
            if(!document.getElementById('view-resultados')?.classList.contains('hidden')){ if(typeof cargarResultados==='function') cargarResultados(); }
            if(!document.getElementById('view-tablas')?.classList.contains('hidden')){ if(typeof buildTablasVista==='function') buildTablasVista(); }
        }catch(e){ setStatus('Error sync: '+(e.message||e),'err'); }
    }
    function construirPayloadFecha(fecha){
        const todos = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        const registrosFecha = todos.filter(r=>r.fecha===fecha);
        if(!registrosFecha.length) return null;
        const amasadoras=[];
        // Acumuladores para resumen del día
        let cantidadAmasadoras = 0;
        let tm1SegDia = 0, tm2SegDia = 0, muertosSegDia = 0, totalRealSegDia = 0, totalProcesosSegDia = 0;
        let sumTempMasa = 0, countTempMasa = 0;
        const tiposMasaConteo = {}; const hieloConteo = {};
        registrosFecha.forEach(r=> (r.maquinas||[]).forEach(m=>{
            const procesos=[];
            for(let i=1;i<=3;i++){
                const p=m['proceso'+i];
                if(p){ procesos.push({ id:i, minutos: parseInt(p.minutos)||0, segundos: parseInt(p.segundos)||0, startTime: p.startTime||null, endTime: p.endTime||null }); }
            }
            // Derivados por máquina
            const p1 = m.proceso1||{}; const p2 = m.proceso2||{}; const p3 = m.proceso3||{};
            const toSecs = (pp)=> (parseInt(pp?.minutos)||0)*60 + (parseInt(pp?.segundos)||0);
            const sumProcesosSeg = toSecs(p1)+toSecs(p2)+toSecs(p3);
            const tm1Seg = (p1?.endTime && p2?.startTime) ? Math.max(0, Math.floor((p2.startTime - p1.endTime)/1000)) : null;
            const tm2Seg = (p2?.endTime && p3?.startTime) ? Math.max(0, Math.floor((p3.startTime - p2.endTime)/1000)) : null;
            const muertosSeg = (tm1Seg||0) + (tm2Seg||0);
            const totalRealSeg = (p1?.startTime && p3?.endTime) ? Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)) : null;
            const nombreMaq = m.nombre||m.id||'';
            const numeroAmasadora = (nombreMaq.match(/\d+/)?.[0]) || '';
            // Acumular para resumen de día
            cantidadAmasadoras += 1;
            if (tm1Seg!=null) tm1SegDia += tm1Seg;
            if (tm2Seg!=null) tm2SegDia += tm2Seg;
            muertosSegDia += muertosSeg;
            if (totalRealSeg!=null) totalRealSegDia += totalRealSeg;
            totalProcesosSegDia += sumProcesosSeg;
            const tMasa = parseFloat(m.tempMasa);
            if (Number.isFinite(tMasa)) { sumTempMasa += tMasa; countTempMasa += 1; }
            const tipo = (m.tipoMasa||m.tipoPan||'').trim(); if(tipo){ tiposMasaConteo[tipo] = (tiposMasaConteo[tipo]||0)+1; }
            const hielo = (m.hielo||'').trim(); if(hielo){ hieloConteo[hielo] = (hieloConteo[hielo]||0)+1; }
            amasadoras.push({
                id: m.id||numeroAmasadora||'',
                nombre: nombreMaq,
                numeroAmasadora,
                tipoMasa: m.tipoMasa||m.tipoPan||'',
                hielo: m.hielo||'',
                lote: m.lote||'',
                tempMasa: m.tempMasa||'',
                observaciones: m.observaciones||'',
                // factores por máquina (duplicados aquí para conservar contexto por equipo)
                personalMin: m.personalMin||r.maquinas?.[0]?.personalMin||'',
                personalMax: m.personalMax||r.maquinas?.[0]?.personalMax||'',
                tempAmbiente: m.tempAmbiente||r.tempAmbiente||'',
                humedad: m.humedad||r.humedad||'',
                // métricas derivadas
                tm1Seg, tm2Seg, muertosSeg, totalRealSeg, totalProcesosSeg: sumProcesosSeg,
                procesos,
                firma: (fecha+'|'+(numeroAmasadora||'')+'|'+(m.lote||'')+'|'+((p1 && p1.startTime) || '')+'|'+((p3 && p3.endTime) || '')),
            });
        }));
        if(!amasadoras.length) return null;
    // Tomar factores generales de la primera máquina
    const ref = registrosFecha[0].maquinas[0];
        const payloadBase = {
            fecha,
            tempAmbiente: ref.tempAmbiente||'',
            humedad: ref.humedad||'',
            personalMin: ref.personalMin||'',
            personalMax: ref.personalMax||'',
            resumenDia: {
                fecha,
                cantidadAmasadoras,
                tm1SegDia,
                tm2SegDia,
                muertosSegDia,
                totalRealSegDia,
                totalProcesosSegDia,
                promedioTempMasaDia: countTempMasa ? (sumTempMasa / countTempMasa) : null,
                tiposMasaConteo,
                hieloConteo
            },
            amasadoras
        };
        // Hash idempotente simple (no criptográfico fuerte, suficiente para dedupe)
        try{
            const raw = JSON.stringify(payloadBase.amasadoras.map(a=>a.firma).sort());
            let h=0; for(let i=0;i<raw.length;i++){ h = Math.imul(31,h) + raw.charCodeAt(i) | 0; }
            payloadBase.idempotencyKey = 'FECHA_'+fecha+'_'+(h>>>0).toString(16);
        }catch(_){ }
        return payloadBase;
    }
    async function pasarFechaABD(){
        const fecha = document.getElementById('fecha')?.value;
        if(!fecha){ setStatus('Selecciona una fecha en el campo superior para enviar.', 'err'); return; }
        const payload = construirPayloadFecha(fecha);
        if(!payload){
            setStatus('No hay datos guardados para la fecha seleccionada. Primero guarda al menos una máquina antes de enviar.', 'info');
            return;
        }
        try{
            setStatus('Enviando a BD...');
            const base=resolveApiBase();
            // Siempre usar /registros directo, sin /api
            const url = base + '/registros';
            const r = await fetch(url,{ method:'POST', headers: apiHeaders(true), body: JSON.stringify(payload) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            setStatus('¡Resultados guardados exitosamente en la base de datos!', 'ok');
            mostrarToast('¡Resultados guardados exitosamente en la base de datos!', 'success');
        }catch(e){ setStatus('Error enviando: '+(e.message||e),'err'); mostrarToast('Error enviando: '+(e.message||e),'error'); }
    }
    function initApiLogic(){
        document.getElementById('btn-sync-bd')?.addEventListener('click', syncDesdeBD);
        const btnPasarFecha = document.getElementById('btn-pasar-fecha-bd');
        if(btnPasarFecha){
            // Mantener siempre clickeable y dar feedback dentro de pasarFechaABD()
            btnPasarFecha.addEventListener('click', pasarFechaABD);
            // Mostrar una pista informativa si no hay datos guardados para la fecha
            const fechaInput = document.getElementById('fecha');
            function hintDatosParaFecha(){
                const fecha = fechaInput?.value;
                const todos = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
                const hayDatos = fecha && todos.some(r=>r.fecha===fecha);
                if(!fecha){ setStatus('Selecciona una fecha para enviar.', 'info'); return; }
                if(!hayDatos){ setStatus('No hay datos guardados para esa fecha. Guarda al menos una máquina en Medición.', 'info'); }
                else { setStatus('Listo para enviar a la BD.', 'info'); }
            }
            fechaInput?.addEventListener('input', hintDatosParaFecha);
            window.addEventListener('storage', hintDatosParaFecha);
            hintDatosParaFecha();
        }
        // Auto sync inicial (suave)
        setTimeout(()=>{ if(!localStorage.getItem('SYNC_INICIAL_REALIZADA')){ syncDesdeBD().finally(()=> localStorage.setItem('SYNC_INICIAL_REALIZADA','1')); } }, 1200);
    }
</script>
</html>