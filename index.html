<!-- ======================= HTML STRUCTURE ======================= -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Producción de Pan</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { font-family: 'Inter', system-ui, sans-serif; }
      .tab-btn { padding:0.5rem 1rem; font-size:.875rem; font-weight:600; border-radius:.75rem; border:1px solid #d6d3d1; background:#fff; color:#57534e; transition:all .18s; }
      .tab-btn:hover { background:#f5f5f4; color:#111827; }
      .tab-btn-active { background:#2563eb; color:#fff; border-color:#2563eb; box-shadow:0 1px 2px rgba(0,0,0,.08); }
            /* Main tabs larger without affecting sub-tabs */
            .tab-btn.main-tab { padding:0.625rem 1.25rem; font-size:1rem; border-radius:1rem; }
      .metric-badge { display:inline-block; padding:2px 6px; border-radius:6px; font-size:.625rem; font-weight:600; background:#e7e5e4; color:#44403c; }
      .metric-badge.warn { background:#fee2e2; color:#dc2626; }
    .chart-desc { display:none; font-size:.75rem; line-height:1.1rem; color:#475569; font-style:italic; margin-top:-6px; margin-bottom:10px; padding-left:.75rem; border-left:3px solid #2563eb20; }
    .chart-title { cursor:pointer; }
    .chart-title:hover .info-hint { text-decoration:underline; }
    </style>
</head>
<body class="bg-stone-50 text-stone-800 min-h-screen">
    <!-- Auth overlay (clave de acceso) -->
    <div id="auth-overlay" class="fixed inset-0 bg-white/95 backdrop-blur-sm z-[10000] hidden">
        <div class="w-full h-full flex items-center justify-center p-4">
            <div class="bg-white border border-stone-300 rounded-2xl shadow-xl p-6 w-full max-w-md">
                <h2 id="auth-title" class="text-2xl font-extrabold text-stone-900 mb-1">Clave de acceso</h2>
                <p id="auth-sub" class="text-sm text-stone-600 mb-4">Ingresa la clave fija para usar la app.</p>
                <div id="auth-login-fields">
                    <label class="block text-sm font-medium text-stone-700 mb-1">Clave (fija)</label>
                    <input id="auth-pass" type="password" class="w-full border rounded px-3 py-2" placeholder="••••••" />
                    <label class="inline-flex items-center gap-2 text-sm text-stone-700 mt-3">
                        <input id="auth-recordar" type="checkbox" class="border rounded" /> Recordar en este navegador
                    </label>
                </div>
                <div class="mt-5 flex flex-wrap gap-2 justify-end">
                    <div class="flex-1"></div>
                    <button id="auth-cancel" class="px-3 py-2 text-sm rounded border border-stone-300">Cerrar</button>
                    <button id="auth-submit" class="px-4 py-2 text-sm rounded bg-blue-600 text-white font-semibold">Continuar</button>
                </div>
                <div id="auth-msg" class="mt-3 text-sm"></div>
            </div>
        </div>
    </div>
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
    <!-- Main app tabs: Menu | Amasadoras | Fermentadora | Hornos -->
    <div class="flex flex-wrap justify-center gap-4 mb-8">
        <button id="tab-main-menu" class="tab-btn main-tab tab-btn-active">Menú</button>
        <button id="tab-main-amasadoras" class="tab-btn main-tab">Amasadoras</button>
        <button id="tab-main-fermentadora" class="tab-btn main-tab">Fermentadora</button>
        <button id="tab-main-hornos" class="tab-btn main-tab">Hornos</button>
    </div>
    <!-- Menú view (about + ajustes) -->
    <div id="view-main-menu" class="block">
        <div class="mb-10 text-center max-w-4xl mx-auto">
            <h1 class="text-4xl md:text-5xl font-extrabold mb-3 text-stone-900 tracking-tight">Curvas de control para producción de pan</h1>
            <p class="text-stone-700 text-lg leading-relaxed">Aplicación para medir y analizar la producción de pan en el área de Producción de la empresa <strong>Pan de Tata</strong>, creada como parte de un proyecto de <strong>pasantías</strong>.</p>
            <p class="text-stone-700 text-lg mt-3">Desarrollada por <strong>Gerardo Siblesz</strong>, estudiante de <strong>Ingeniería en Producción y Mecánica</strong> de la <strong>Universidad Metropolitana</strong>.</p>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-5xl mx-auto">
            <div class="bg-white border border-stone-200 rounded-xl p-6 shadow-sm">
                <h2 class="text-2xl font-extrabold text-stone-900 mb-3">Cómo funciona</h2>
                <ul class="list-disc ml-6 text-base text-stone-700 space-y-1.5">
                    <li>Registra variables generales y tiempos por máquina.</li>
                    <li>Guarda resultados locales y envíalos a la Base de Datos.</li>
                    <li>Consulta desde cualquier dispositivo usando la misma API y clave.</li>
                    <li>Explora Resultados y Tablas para análisis y exporta en CSV/PDF.</li>
                </ul>
            </div>
            <div id="ajustes-card" class="bg-white border border-stone-200 rounded-xl p-6 shadow-sm hidden">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-2xl font-extrabold text-stone-900">Ajustes</h2>
                    <button id="toggle-ajustes" class="text-sm text-stone-600 underline">Mostrar ajustes</button>
                </div>
                <div id="ajustes-content" class="space-y-4 text-base hidden">
                    <div>
                        <label class="block font-semibold text-stone-700">URL de la API</label>
                        <input id="settings-api-url" class="w-full border rounded px-3 py-2 text-base" placeholder="https://tu-backend" />
                        <button id="settings-save-api" class="mt-2 bg-stone-700 text-white px-4 py-2 rounded">Guardar URL</button>
                    </div>
                    <div>
                        <label class="block font-semibold text-stone-700">Clave de API</label>
                        <div class="relative flex items-center gap-2">
                            <input id="settings-api-key" type="password" class="w-full border rounded px-3 py-2 text-base pr-16" placeholder="••••••" />
                            <button type="button" id="settings-api-toggle" class="absolute right-2 top-1/2 -translate-y-1/2 text-xs px-2 py-1 rounded border border-stone-300 bg-stone-100 hover:bg-stone-200">Mostrar</button>
                        </div>
                        <label class="inline-flex items-center gap-2 mt-2"><input id="settings-remember-key" type="checkbox" class="scale-110" /> Recordar en este dispositivo</label>
                        <button id="settings-save-key" class="ml-2 bg-blue-600 text-white px-4 py-2 rounded">Guardar clave</button>
                        <div id="settings-key-status" class="mt-2 text-sm text-stone-600"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fermentadora (placeholder) - sección de nivel superior -->
    <div id="section-fermentadora" class="hidden">
        <div class="bg-white border border-stone-200 rounded-xl p-8 shadow-sm text-center text-stone-600 max-w-3xl mx-auto">
            Próximamente: módulo de Fermentadora.
        </div>
    </div>

    <!-- Hornos (placeholder) - sección de nivel superior -->
    <div id="section-hornos" class="hidden">
        <div class="bg-white border border-stone-200 rounded-xl p-8 shadow-sm text-center text-stone-600 max-w-3xl mx-auto">
            Próximamente: módulo de Hornos.
        </div>
    </div>
    <!-- Amasadoras section (existing app) -->
    <div id="section-amasadoras" class="hidden">
        <div class="flex flex-wrap justify-center gap-3 mb-6">
            <button id="tab-medicion" class="tab-btn tab-btn-active">Medición</button>
            <button id="tab-resultados" class="tab-btn">Resultados</button>
            <button id="tab-tablas" class="tab-btn">Tablas</button>
        </div>
        <div id="view-tablas" class="hidden">
            <div class="mb-6 text-center">
                <h2 class="text-3xl font-extrabold mb-2 text-stone-900 tracking-tight">Tablas y Gráficas</h2>
                <p class="text-stone-600 max-w-2xl mx-auto">Promedios, desviaciones y distribución visual por tipo de masa, amasadora y procesos.</p>
            </div>
                <div class="mb-4 flex flex-wrap gap-3 justify-center items-center">
                    <label for="tablas-source" class="text-sm text-stone-700">Fuente:</label>
                    <select id="tablas-source" class="border rounded px-2 py-1 text-sm">
                        <option value="local">Locales</option>
                        <option value="bd">Base de datos</option>
                    </select>
                    <div id="tablas-bd-controls" class="hidden flex flex-wrap items-center gap-2">
                        <label class="text-sm text-stone-700">Desde:</label>
                        <input id="tablas-bd-desde" type="date" class="border rounded px-2 py-1 text-sm" />
                        <label class="text-sm text-stone-700">Hasta:</label>
                        <input id="tablas-bd-hasta" type="date" class="border rounded px-2 py-1 text-sm" />
                        <input id="tablas-bd-lote" placeholder="Lote" class="border rounded px-2 py-1 text-sm w-28" />
                        <input id="tablas-bd-tipo" placeholder="Tipo de masa" class="border rounded px-2 py-1 text-sm w-36" />
                        <button id="tablas-bd-clear" class="text-sm text-stone-600 hover:text-stone-900 underline">Quitar filtros</button>
                    </div>
                    <div id="tablas-export-controls" class="flex flex-wrap items-center gap-2">
                        <span class="mx-2 text-stone-300">|</span>
                        <button id="tablas-export-pdf" class="bg-blue-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-blue-700">Exportar (PDF)</button>
                        <button id="tablas-export-csv" class="bg-emerald-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-emerald-700">Exportar (CSV)</button>
                    </div>
                    <span id="tablas-status" class="text-xs text-stone-600"></span>
                </div>
            <div class="mb-8 max-w-3xl mx-auto">
                <!-- NUEVO: Lista de fechas registradas -->
                <div class="mb-10" id="tablas-fechas-wrapper">
                    <h3 class="text-xl font-bold mb-3 text-stone-800 flex items-center gap-2">Fechas registradas <span id="tablas-fechas-total" class="text-sm font-normal text-stone-500"></span></h3>
                    <div id="tablas-fechas-list" class="flex flex-wrap gap-2"></div>
                    <div id="tablas-fechas-detalle" class="mt-4 hidden"></div>
                </div>
                <details open class="bg-white border border-stone-300 rounded-xl p-4 shadow-sm">
                    <summary class="cursor-pointer select-none font-semibold text-stone-800 text-lg">Mapeo de gráficas y propósito analítico</summary>
                    <div class="mt-3 text-sm space-y-3 text-stone-700">
                        <ul class="list-disc ml-5 space-y-1">
                            <li><span class="font-medium">Punto de partida (1)</span>: Resumen de tiempos.</li>
                            <li><span class="font-medium">Benchmark entre recetas (2 y 5)</span>: Promedios por tipo de masa (tiempos) y Temperatura de masa por tipo.</li>
                            <li><span class="font-medium">Detecta dónde optimizar (3, 4 y 9)</span>: Promedios por amasadora, Promedios por proceso, Tiempos productivos vs muertos.</li>
                            <li><span class="font-medium">Control de consistencia (5, 6 y 8)</span>: Temperatura de masa (general), Temp. masa (Amasadora vs Tipo), Distribución por tipo (boxplot).</li>
                            <li><span class="font-medium">Contexto y factores (7 y 11)</span>: TA y Humedad por día, Personal por día (mín–máx).</li>
                            <li><span class="font-medium">Hipótesis de proceso (10)</span>: Relación temperatura de masa vs tiempo total (scatter).</li>
                        </ul>
                        <p class="text-xs text-stone-500">Los números refieren al orden visual de las secciones inferiores.</p>
                    </div>
                </details>
            </div>
            <div id="tablas-wrapper" class="space-y-10">
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Resumen de tiempos (s) <span class="info-hint text-blue-600 cursor-help align-middle" title="Indicadores globales: registros, promedio total y variabilidad.">ℹ️</span></h3>
                    <p class="chart-desc">Muestra KPIs globales: número de registros, promedio total y dispersión (desviación y %). Punto de partida para ver si el proceso se estabiliza.</p>
                    <div id="tabla-resumen" class="overflow-x-auto text-sm"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Promedios por tipo de masa <span class="info-hint text-blue-600 cursor-help align-middle" title="Tiempo total promedio por receta.">ℹ️</span></h3>
                    <p class="chart-desc">Compara recetas y ayuda a detectar cuáles requieren más tiempo total. Útil para priorizar mejoras o ajustar programación.</p>
                    <div id="tabla-pan" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-pan" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Promedios por amasadora <span class="info-hint text-blue-600 cursor-help align-middle" title="Comparación entre equipos.">ℹ️</span></h3>
                    <p class="chart-desc">Identifica máquinas más lentas o con tiempos fuera de rango para redistribuir cargas o revisar mantenimiento.</p>
                    <div id="tabla-amasadora" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-amasadora" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Promedios por proceso <span class="info-hint text-blue-600 cursor-help align-middle" title="Duración típica de cada etapa.">ℹ️</span></h3>
                    <p class="chart-desc">Revela cuál de las 3 etapas domina el ciclo y dónde un ajuste reduciría más el tiempo total.</p>
                    <div id="tabla-proceso" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-proceso" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Temperatura de masa <span class="info-hint text-blue-600 cursor-help align-middle" title="Temperatura promedio por tipo de masa.">ℹ️</span></h3>
                    <p class="chart-desc">Controla la consistencia térmica: variaciones grandes pueden afectar fermentación o calidad final.</p>
                    <div id="tabla-temp" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-temp-pan" height="140" class="mb-8"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Temp. masa (Amasadora vs Tipo de masa) <span class="info-hint text-blue-600 cursor-help align-middle" title="Cruce equipo vs receta.">ℹ️</span></h3>
                    <p class="chart-desc">Detecta si ciertas máquinas generan sistemáticamente temperaturas distintas para la misma receta.</p>
                    <div id="tabla-temp-cruzada" class="overflow-x-auto text-sm"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">TA y Humedad por día <span class="info-hint text-blue-600 cursor-help align-middle" title="Promedio diario de temperatura ambiente y humedad.">ℹ️</span></h3>
                    <p class="chart-desc">Para cada fecha, se resume la Temperatura Ambiente (TA) y la Humedad (H) promedio basadas en las máquinas registradas ese día.</p>
                    <div id="tabla-ta-h-dia" class="overflow-x-auto text-sm mb-4"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Distribución tiempos por tipo de masa (Boxplot) <span class="info-hint text-blue-600 cursor-help align-middle" title="Variabilidad por receta.">ℹ️</span></h3>
                    <p class="chart-desc">Mide estabilidad operativa: IQR reducido indica proceso controlado; valores altos sugieren inconsistencia.</p>
                    <canvas id="chart-boxplot-tipo" height="220" class="mb-2"></canvas>
                    <div id="boxplot-explicacion" class="text-xs text-stone-600 leading-snug hidden"></div>
                    <div id="boxplot-stats" class="overflow-x-auto text-xs mt-2"></div>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Tiempos productivos vs muertos por amasadora <span class="info-hint text-blue-600 cursor-help align-middle" title="Proporción de inactividad.">ℹ️</span></h3>
                    <p class="chart-desc">Cuantifica ineficiencia: mayor porcentaje de tiempo muerto = oportunidad directa de optimización.</p>
                    <canvas id="chart-stacked-muertos" height="140"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Relación temperatura de masa vs tiempo total <span class="info-hint text-blue-600 cursor-help align-middle" title="Correlación tiempo vs calor.">ℹ️</span></h3>
                    <p class="chart-desc">Evalúa si la temperatura final se asocia a mayor o menor duración (r cercano a 0 indica poca relación).</p>
                    <canvas id="chart-scatter-temp-tiempo" height="160"></canvas>
                </section>
                <section>
                    <h3 class="chart-title text-xl font-bold mb-1 text-stone-800">Personal por día (mín–máx) <span class="info-hint text-blue-600 cursor-help align-middle" title="Resumen diario de dotación (límite inferior y superior).">ℹ️</span></h3>
                    <p class="chart-desc">Para cada fecha se muestra el mínimo y máximo de personal (agregado por día), su midpoint y el rango. Debajo se compara visualmente por día.</p>
                    <div id="tabla-personal-dia" class="overflow-x-auto text-sm mb-4"></div>
                    <canvas id="chart-personal-dia" height="140"></canvas>
                </section>
            </div>
        </div>
        <div id="view-medicion" class="hidden">
                <div class="mb-8">
                    <h1 class="text-3xl font-extrabold text-stone-900 tracking-tight mb-2">Cálculo de Amasadoras</h1>
                    <p class="text-stone-600 text-sm md:text-base">Cómo operar el programa: registra primero las variables generales (fecha, TA, H, personal). Luego en cada tarjeta de amasadora define el tipo de masa y controla los tres procesos secuencialmente. Guarda cada máquina al terminar para formar un conjunto que luego podrás analizar y exportar.</p>
                </div>
                <!-- Instrucciones (migradas desde Resultados) -->
                <div id="instrucciones-medicion" class="mb-8">
                    <details open class="bg-white border border-stone-300 rounded-xl p-4 shadow-sm">
                        <summary class="cursor-pointer select-none font-semibold text-stone-800 text-lg flex items-center gap-2">
                            <span>Instrucciones (crear conjunto, analizar y exportar)</span>
                        </summary>
                        <div class="mt-3 space-y-3 text-sm leading-relaxed text-stone-700">
                            <p><span class="font-semibold">¿Qué es un conjunto?</span> Es un registro de una <strong>fecha</strong> con una o varias <strong>amasadoras</strong> y sus 3 procesos: <strong>Esponja</strong>, <strong>Masa</strong> y <strong>Mantequilla</strong> (tiempos reales, inicios, fines), más variables: <strong>Lote</strong>, <strong>Tipo de masa</strong>, <strong>Hielo</strong>, <strong>TM/TA/H</strong>, <strong>Personal</strong> y <strong>Observaciones</strong>.</p>
                            <ol class="list-decimal ml-5 space-y-1">
                                <li>Completa <strong>Fecha</strong>, <strong>TA</strong>, <strong>H</strong> y <strong>Personal (mín–máx)</strong>.</li>
                                <li>En cada amasadora define <strong>Tipo de masa</strong>, marca <strong>Hielo</strong> si aplica y al finalizar registra <strong>Temp. de masa</strong> y <strong>Observaciones</strong>.</li>
                                <li>Ejecuta los procesos en orden (Iniciar / Detener). Sólo puede estar activo uno por máquina; iniciar otro detiene el previo.</li>
                                <li>Se guardan inicio, fin y duración. El <strong>Total máquina</strong> va desde el inicio del primer proceso al fin del tercero. <strong>TM1 / TM2</strong> son los huecos entre procesos.</li>
                                <li>Pulsa <strong>Guardar resultados</strong> al terminar los 3 procesos de la máquina. Repite para otras.</li>
                                <li>Pasa a la pestaña <strong>Resultados</strong> para ver, filtrar y revisar. Desde <strong>Base de datos</strong> puedes: <em>Refrescar</em>, <em>Ver JSON</em> (abre un modal con Copiar), <em>Borrar</em> y ver <em>Detalles</em> por amasadora (TM1/TM2/Total real/Total procesos/Obs y tiempos por proceso).</li>
                                <li>En <strong>Resultados → Locales</strong> puedes enviar una tarjeta con <em>Enviar a BD</em> o toda la fecha con <em>Enviar todo a la BD</em>. Evitamos clics múltiples para no duplicar.</li>
                                <li>En <strong>Tablas</strong> elige la <em>Fuente</em>: <strong>Locales</strong> o <strong>Base de datos</strong> (con filtro por <em>Fecha</em>). Las tablas y gráficas se adaptan al origen.</li>
                                <li><strong>Borrar todo</strong> elimina definitivamente todos los registros guardados.</li>
                                <li><strong>Exportar PDF</strong>: reporte visual de la vista de resultados (sin botones).</li>
                                <li><strong>Exportar CSV</strong>: filas compactadas (una por proceso) con factores diarios y de máquina sólo en la primera fila de cada máquina. Incluye TM1, TM2, TM.Total y Total(s).</li>
                                <li>Si el total supera 45 min (>2700 s) aparece un ícono de advertencia.</li>
                            </ol>
                            <p class="text-stone-600">Consejo: Usa CSV para análisis (Excel / Power BI) y PDF para difusión rápida.</p>
                            <div class="pt-3 border-t border-stone-200"></div>
                            <h4 class="font-semibold text-stone-800">Mapeo de gráficas y propósito analítico</h4>
                            <ul class="list-disc ml-5 space-y-1">
                                <li><span class="font-medium">Punto de partida (1)</span>: Resumen de tiempos.</li>
                                <li><span class="font-medium">Benchmark entre recetas (2 y 5)</span>: Promedios por tipo de masa (tiempos) y Temperatura de masa por tipo.</li>
                                <li><span class="font-medium">Detecta dónde optimizar (3, 4 y 9)</span>: Promedios por amasadora, Promedios por proceso, Tiempos productivos vs muertos.</li>
                                <li><span class="font-medium">Control de consistencia (5, 6 y 8)</span>: Temperatura de masa (general), Temp. masa (Amasadora vs Tipo), Distribución por tipo (boxplot).</li>
                                <li><span class="font-medium">Contexto y factores (7 y 11)</span>: TA y Humedad por día, Personal por día (mín–máx).</li>
                                <li><span class="font-medium">Hipótesis de proceso (10)</span>: Relación temperatura de masa vs tiempo total (scatter).</li>
                            </ul>
                            <p class="text-xs text-stone-500">Tip: Usa BD como fuente para analizar históricos y evita perder datos al cambiar de dispositivo.</p>
                        </div>
                    </details>
                </div>
            <div class="mb-6 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-5">
                <div>
                    <label for="fecha" class="block mb-1 text-sm font-semibold text-stone-700">Fecha</label>
                    <input type="date" id="fecha" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" />
                </div>
                <div>
                    <label for="ta" class="block mb-1 text-sm font-semibold text-stone-700">Temp. ambiente (°C)</label>
                    <input type="number" id="ta" step="0.1" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="TA" />
                </div>
                <div>
                    <label for="h" class="block mb-1 text-sm font-semibold text-stone-700">Humedad (%)</label>
                    <input type="number" id="h" step="0.1" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="H" />
                </div>
                <div>
                    <label for="personal-min" class="block mb-1 text-sm font-semibold text-stone-700">Personal (mín)</label>
                    <input type="number" min="0" id="personal-min" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="Mínimo" />
                </div>
                <div>
                    <label for="personal-max" class="block mb-1 text-sm font-semibold text-stone-700">Personal (máx)</label>
                    <input type="number" min="0" id="personal-max" class="w-full px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white" placeholder="Máximo" />
                </div>
                
            </div>
            <main id="machine-cards" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-7 mb-10"></main>
            <div id="msg-guardar" class="mt-2 text-center text-sm"></div>
        </div>
        <!-- Vista de resultados (única) -->
        <div id="view-resultados" class="hidden">
                <div class="mb-4 flex flex-wrap gap-3 justify-end">
                    <button id="btn-export-resultados-pdf" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow hover:bg-blue-700 transition-colors">Exportar Resultados de Amasadoras (PDF)</button>
                    <button id="btn-export-resultados-csv" class="bg-emerald-600 text-white px-4 py-2 rounded-lg font-semibold shadow hover:bg-emerald-700 transition-colors">Exportar Resultados de Amasadoras (CSV)</button>
                </div>
                <!-- Subpestañas: Locales | Base de datos -->
                <div class="flex justify-center gap-2 mb-4">
                    <button id="subtab-local" class="tab-btn tab-btn-active">Locales</button>
                    <button id="subtab-bd" class="tab-btn">Base de datos</button>
                </div>
                <!-- Subvista: Resultados locales -->
                <div id="resultados-local-wrapper">
                    <!-- Filtros para resultados locales -->
                    <div class="flex flex-wrap gap-4 justify-center mb-3">
                        <input id="filtro-fecha" type="date" class="border rounded px-3 py-1" placeholder="Filtrar por fecha" />
                        <input id="filtro-tipo" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por tipo de masa" />
                        <input id="filtro-maquina" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por amasadora" />
                        <button id="btn-enviar-todo-bd" class="bg-amber-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-amber-700" title="Enviar todos los resultados locales a la BD">Enviar todo a la BD</button>
                        <button id="btn-clear-resultados" class="bg-red-500 text-white px-3 py-1 rounded">Borrar todo</button>
                    </div>
                    <div id="local-bd-status" class="text-xs text-stone-600 mt-1 text-center"></div>
                    <div id="promedios" class="text-sm text-stone-600 text-center mb-4"></div>
                    <div id="resultados-lista"></div>
                </div>
                <!-- Subvista: Base de datos remota -->
                <div id="bd-wrapper" class="hidden">
        <div class="flex flex-wrap gap-2 justify-center items-center mb-2">
            <input id="bd-filtro-fecha" type="date" class="border rounded px-3 py-1" placeholder="Filtrar por fecha" />
            <input id="bd-filtro-tipo" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por tipo de masa" />
            <input id="bd-filtro-maquina" type="text" class="border rounded px-3 py-1" placeholder="Filtrar por amasadora" />
            <button id="bd-refresh" class="bg-indigo-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-indigo-700">Refrescar</button>
            <button id="bd-delete-all" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-red-700" title="Borrar todos los registros en la BD (si la API lo permite)">Borrar todo BD</button>
                    <button id="bd-select-mode" class="bg-stone-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-stone-700" title="Seleccionar múltiples para borrar">Seleccionar</button>
                    <button id="bd-delete-selected" class="hidden bg-red-700 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-red-800" title="Eliminar seleccionados">Eliminar seleccionados (<span id="bd-selected-count">0</span>)</button>
        </div>
                    <div id="sync-status" class="text-xs text-stone-600 mt-1 text-center"></div>
                    <div id="bd-lista" class="max-w-4xl mx-auto mt-3"></div>
                </div>
            </div>
        </div>
    </div>
</body>
<!-- JSON Modal for viewing record details -->
<div id="json-modal" class="hidden fixed inset-0 bg-black/40 items-center justify-center p-4 z-50">
    <div class="bg-white rounded-xl shadow-xl w-full max-w-3xl max-h-[80vh] flex flex-col">
        <div class="px-4 py-2 border-b border-stone-200 flex items-center justify-between">
            <h3 class="font-semibold text-stone-800">Vista JSON del registro</h3>
            <div class="flex gap-2">
                <button id="json-modal-copy" class="bg-stone-700 text-white text-xs px-2 py-1 rounded">Copiar JSON</button>
                <button id="json-modal-close" class="bg-stone-500 text-white text-xs px-2 py-1 rounded">Cerrar</button>
            </div>
        </div>
        <pre id="json-modal-content" class="flex-1 overflow-auto text-xs p-4 bg-stone-50 text-stone-800"></pre>
    </div>
  
</div>
<script>
// Cargar libs si faltan
window.html2canvas || document.write('<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"><\/script>');
window.jspdf || document.write('<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"><\/script>');
// CDN Chart.js
window.Chart || document.write('<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"><\/script>');
// Ocultar/mostrar tarjeta de Ajustes (persistente)
document.addEventListener('DOMContentLoaded', () => {
    const toggleBtn = document.getElementById('toggle-ajustes');
    const ajustesContent = document.getElementById('ajustes-content');
    if (!toggleBtn || !ajustesContent) return;
    // Leer preferencia
    const saved = localStorage.getItem('ajustesVisible');
    let visible = saved === '1';
    if (saved === null) visible = false; // por defecto oculto
    ajustesContent.classList.toggle('hidden', !visible);
    toggleBtn.textContent = visible ? 'Ocultar ajustes' : 'Mostrar ajustes';
    toggleBtn.addEventListener('click', () => {
        visible = !visible;
        ajustesContent.classList.toggle('hidden', !visible);
        toggleBtn.textContent = visible ? 'Ocultar ajustes' : 'Mostrar ajustes';
        localStorage.setItem('ajustesVisible', visible ? '1' : '0');
    });
});
// ======================= GLOBAL VARIABLES AND DATA =======================
    // Datos de amasadoras
    const machineData = [
        {
            id: '3',
            name: 'Amasadora 3',
            processes: [
                { id: '1', name: 'Esponja' },
                { id: '2', name: 'Masa' },
                { id: '3', name: 'Mantequilla' }
            ]
        },
        {
            id: '1',
            name: 'Amasadora 1',
            processes: [
                { id: '1', name: 'Esponja' },
                { id: '2', name: 'Masa' },
                { id: '3', name: 'Mantequilla' }
            ]
        },
        {
            id: '2',
            name: 'Amasadora 2',
            processes: [
                { id: '1', name: 'Esponja' },
                { id: '2', name: 'Masa' },
                { id: '3', name: 'Mantequilla' }
            ]
        }
    ];

    const machineCardsContainer = document.getElementById('machine-cards');
    let timers = {};
    let machineTotals = {};
    let completedProcessTimes = {};

    function formatTime(seconds) {
        if (isNaN(seconds) || seconds === null) return '00:00:00';
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function createMachineCards() {
    // Restaurar datos temporales si existen
    let tempData = {};
    try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
    machineCardsContainer.innerHTML = '';
        let sortedMachines = [...machineData];
        const ordenIds = ['3', '1', '2'];
        sortedMachines.sort((a, b) => ordenIds.indexOf(a.id) - ordenIds.indexOf(b.id));
        sortedMachines.forEach(machine => {
            const temp = tempData[machine.id] || {};
            // Calcular el total restando el inicio del primer proceso y el fin del último proceso
            let primerStart = completedProcessTimes[`m${machine.id}-p1`]?.startTime || null;
            let ultimoEnd = completedProcessTimes[`m${machine.id}-p3`]?.endTime || null;
            let totalTime = null;
            if (primerStart && ultimoEnd) {
                totalTime = Math.max(0, Math.floor((ultimoEnd - primerStart)/1000));
            }
            // Calcular tiempos muertos
            let t1End = completedProcessTimes[`m${machine.id}-p1`]?.endTime || null;
            let t2Start = completedProcessTimes[`m${machine.id}-p2`]?.startTime || null;
            let t2End = completedProcessTimes[`m${machine.id}-p2`]?.endTime || null;
            let t3Start = completedProcessTimes[`m${machine.id}-p3`]?.startTime || null;
            let tiempoMuerto1 = (t1End && t2Start) ? Math.max(0, Math.floor((t2Start - t1End)/1000)) : null;
            let tiempoMuerto2 = (t2End && t3Start) ? Math.max(0, Math.floor((t3Start - t2End)/1000)) : null;
            let sumaMuertos = (tiempoMuerto1 || 0) + (tiempoMuerto2 || 0);
            const isOverThreshold = totalTime !== null && totalTime > 2700;
            const totalColorClass = isOverThreshold ? 'text-red-600' : 'text-stone-800';
            let processesHtml = '';
            machine.processes.forEach(process => {
                const timerId = `m${machine.id}-p${process.id}`;
                const processTime = completedProcessTimes[timerId] || { time: 0, startTime: null, endTime: null };
                const isRunning = timers[timerId] !== undefined;
                processesHtml += `
                    <div class="p-4 bg-stone-50 rounded-lg border border-stone-200">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold text-stone-800">${process.name}</h4>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-sm mb-4">
                            <div class="text-stone-600">Inicio: <span id="start-${timerId}" class="font-mono font-medium text-stone-800">${processTime.startTime ? new Date(processTime.startTime).toLocaleTimeString() : '--:--:--'}</span></div>
                            <div class="text-stone-600">Fin: <span id="end-${timerId}" class="font-mono font-medium text-stone-800">${processTime.endTime ? new Date(processTime.endTime).toLocaleTimeString() : '--:--:--'}</span></div>
                            <div class="text-stone-600 col-span-2">T. Real: <span id="real-${timerId}" class="font-mono font-medium text-stone-800">${formatTime(processTime.time)}</span></div>
                        </div>
                        <div class="grid grid-cols-3 gap-2">
                            <button data-action="start" data-timer-id="${timerId}" class="col-span-1 text-sm bg-emerald-500 text-white py-2 px-3 rounded-md hover:bg-emerald-600 transition-colors ${isRunning ? 'disabled:bg-stone-300' : ''}" ${isRunning ? 'disabled' : ''}>Iniciar</button>
                            <button data-action="stop" data-timer-id="${timerId}" class="col-span-1 text-sm bg-red-500 text-white py-2 px-3 rounded-md hover:bg-red-600 transition-colors ${!isRunning ? 'disabled:bg-stone-300' : ''}" ${!isRunning ? 'disabled' : ''}>Detener</button>
                            <button data-action="reset" data-timer-id="${timerId}" class="col-span-1 text-sm bg-stone-500 text-white py-2 px-3 rounded-md hover:bg-stone-600 transition-colors">Reset</button>
                        </div>
                    </div>
                `;
            });
            const cardHtml = `
                <div class="relative bg-white p-6 rounded-2xl shadow-sm border border-stone-200 flex flex-col hover:shadow-md transition-shadow">
                    <h3 class="text-xl font-bold mb-4 text-stone-900 tracking-tight">${machine.name}</h3>
                    <div class="mb-4 flex flex-col items-center">
                        <label for="lote-${machine.id}" class="block mb-2 text-base font-semibold text-stone-800">Lote:</label>
                        <input type="text" id="lote-${machine.id}" class="mb-4 px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48" placeholder="Ingrese el número de lote" value="${temp.lote||''}" />
                        <label for="tipoMasa-${machine.id}" class="block mb-2 text-base font-semibold text-stone-800">Tipo de masa:</label>
                        <select id="tipoMasa-${machine.id}" data-machine="${machine.id}" class="px-4 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48 tipo-masa-select">
                            <option value="">-- Seleccionar --</option>
                            <option value="Tradicional" ${temp.tipoMasa==='Tradicional'?'selected':''}>Tradicional</option>
                            <option value="Brioche" ${temp.tipoMasa==='Brioche'?'selected':''}>Brioche</option>
                            <option value="Bs." ${temp.tipoMasa==='Bs.'?'selected':''}>Bs.</option>
                            <option value="__OTRO__" ${temp.tipoMasa==='__OTRO__'?'selected':''}>Otro...</option>
                        </select>
                        <input type="text" id="tipoMasaOtro-${machine.id}" placeholder="Especificar otro" class="mt-2 px-3 py-2 rounded-lg border border-dashed border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500 w-48 tipo-masa-otro${temp.tipoMasa==='__OTRO__'?'':' hidden'}" value="${temp.tipoMasaOtro||''}" />
                        <div class="flex items-center gap-4 mt-4 mb-2">
                            <span class="text-base font-semibold text-stone-800">Hielo:</span>
                            <label class="inline-flex items-center">
                                <input type="radio" name="hielo-${machine.id}" id="hielo-si-${machine.id}" value="Si" class="form-radio text-blue-600" ${temp.hielo==='Si'?'checked':''} />
                                <span class="ml-2">Si</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="hielo-${machine.id}" id="hielo-no-${machine.id}" value="No" class="form-radio text-blue-600" ${temp.hielo==='No'?'checked':''} />
                                <span class="ml-2">No</span>
                            </label>
                        </div>
                        <div class="flex flex-col items-center mt-2 w-48">
                            <!-- Campo de personal eliminado, ahora está arriba -->
                        </div>
                    </div>
                    <div class="space-y-4 mb-4">
                        ${processesHtml}
                    </div>
                    <div class="mb-4 p-3 rounded-xl bg-gradient-to-br from-blue-50 to-stone-50 border border-blue-200/70 text-blue-900 text-xs flex flex-col gap-1 shadow-inner">
                        <div class="flex justify-between"><span class="font-semibold">T. Muerto 1</span><span id="tm1-${machine.id}" class="font-mono">${tiempoMuerto1 !== null ? formatTime(tiempoMuerto1) : '--:--:--'}</span></div>
                        <div class="flex justify-between"><span class="font-semibold">T. Muerto 2</span><span id="tm2-${machine.id}" class="font-mono">${tiempoMuerto2 !== null ? formatTime(tiempoMuerto2) : '--:--:--'}</span></div>
                        <div class="flex justify-between"><span class="font-semibold">Muertos Total</span><span id="tmT-${machine.id}" class="font-mono">${(tiempoMuerto1 !== null || tiempoMuerto2 !== null) ? formatTime(sumaMuertos) : '--:--:--'}</span></div>
                        <div class="flex justify-between text-blue-700 font-bold"><span>Total máquina</span><span id="ttot-${machine.id}" class="font-mono">${totalTime !== null ? formatTime(totalTime) : '--:--:--'}</span></div>
                    </div>
                    <div class="flex flex-col gap-2 mb-4 w-48 mx-auto">
                        <label class="text-base font-semibold text-stone-800">Temperatura de la masa (C):</label>
                        <input type="number" step="0.1" id="tempMasa-${machine.id}" class="px-3 py-2 rounded-lg border border-stone-300 focus:outline-none focus:ring-2 focus:ring-blue-500" value="${temp.tempMasa||''}" />
                    </div>
                    <div class="mb-4">
                        <label for="obs-${machine.id}" class="block mb-2 text-base font-semibold text-stone-800">Observaciones:</label>
                        <textarea id="obs-${machine.id}" rows="2" class="w-full px-3 py-2 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y">${temp.observaciones||''}</textarea>
                    </div>
                                        <div class="text-center mt-auto pt-4 border-t border-stone-200">
                                                <p class="text-base font-bold text-stone-900">Total amasadora: <span id="total-m${machine.id}" class="${totalColorClass} font-mono text-lg">${totalTime !== null ? formatTime(totalTime) : '--:--:--'}</span></p>
                                                <div class="flex flex-col gap-2 mt-3">
                                                    <button class="guardar-maquina bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors font-semibold shadow-sm" data-machine-id="${machine.id}">Guardar resultados</button>
                                                    <button class="clear-maquina bg-stone-400 text-white px-4 py-2 rounded-lg hover:bg-stone-500 transition-colors font-semibold" data-machine-id="${machine.id}">Limpiar</button>
                                                </div>
                        <div id="msg-guardar-${machine.id}" class="mt-2 text-center"></div>
                            </div>
                        </div>
            `;
            machineCardsContainer.innerHTML += cardHtml;
        });
    }
    // Actualizar dinámicamente los tiempos muertos y total al detener procesos
    function updateMuertosYTotal(machineId) {
        let t1End = completedProcessTimes[`m${machineId}-p1`]?.endTime || null;
        let t2Start = completedProcessTimes[`m${machineId}-p2`]?.startTime || null;
        let t2End = completedProcessTimes[`m${machineId}-p2`]?.endTime || null;
        let t3Start = completedProcessTimes[`m${machineId}-p3`]?.startTime || null;
        let primerStart = completedProcessTimes[`m${machineId}-p1`]?.startTime || null;
        let ultimoEnd = completedProcessTimes[`m${machineId}-p3`]?.endTime || null;
        let tiempoMuerto1 = (t1End && t2Start) ? Math.max(0, Math.floor((t2Start - t1End)/1000)) : null;
        let tiempoMuerto2 = (t2End && t3Start) ? Math.max(0, Math.floor((t3Start - t2End)/1000)) : null;
        let sumaMuertos = (tiempoMuerto1 || 0) + (tiempoMuerto2 || 0);
        let totalTime = (primerStart && ultimoEnd) ? Math.max(0, Math.floor((ultimoEnd - primerStart)/1000)) : null;
        if(document.getElementById(`tm1-${machineId}`)) document.getElementById(`tm1-${machineId}`).textContent = tiempoMuerto1 !== null ? formatTime(tiempoMuerto1) : '--:--:--';
        if(document.getElementById(`tm2-${machineId}`)) document.getElementById(`tm2-${machineId}`).textContent = tiempoMuerto2 !== null ? formatTime(tiempoMuerto2) : '--:--:--';
        if(document.getElementById(`tmT-${machineId}`)) document.getElementById(`tmT-${machineId}`).textContent = (tiempoMuerto1 !== null || tiempoMuerto2 !== null) ? formatTime(sumaMuertos) : '--:--:--';
        if(document.getElementById(`ttot-${machineId}`)) document.getElementById(`ttot-${machineId}`).textContent = totalTime !== null ? formatTime(totalTime) : '--:--:--';
    }

    // Evento para botón Clear de cada amasadora
    machineCardsContainer.addEventListener('click', function(e) {
        const btn = e.target.closest('.clear-maquina');
        if (!btn) return;
        const machineId = btn.getAttribute('data-machine-id');
        if (!machineId) return;
        // Limpiar campos de la tarjeta
    const tipoMasaSelect = document.getElementById(`tipoMasa-${machineId}`); if(tipoMasaSelect) tipoMasaSelect.value = '';
    const tipoMasaOtro = document.getElementById(`tipoMasaOtro-${machineId}`); if(tipoMasaOtro){ tipoMasaOtro.value=''; tipoMasaOtro.classList.add('hidden'); }
        document.getElementById(`tempMasa-${machineId}`).value = '';
        document.getElementById(`obs-${machineId}`).value = '';
        if (document.getElementById(`hielo-si-${machineId}`)) document.getElementById(`hielo-si-${machineId}`).checked = false;
        if (document.getElementById(`hielo-no-${machineId}`)) document.getElementById(`hielo-no-${machineId}`).checked = false;
        // Limpiar tiempos de procesos
        for (let i = 1; i <= 3; i++) {
            const timerId = `m${machineId}-p${i}`;
            if (timers[timerId] && timers[timerId].interval) {
                clearInterval(timers[timerId].interval);
                delete timers[timerId];
            }
            delete completedProcessTimes[timerId];
            document.getElementById(`start-${timerId}`).textContent = '--:--:--';
            document.getElementById(`end-${timerId}`).textContent = '--:--:--';
            document.getElementById(`real-${timerId}`).textContent = '00:00:00';
            document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = false;
            document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = true;
    }
        // Resetear total
        const totalSpan = document.getElementById(`total-m${machineId}`);
        if (totalSpan) {
            totalSpan.textContent = '00:00:00';
            totalSpan.classList.remove('text-red-600');
            totalSpan.classList.add('text-stone-800');
        }
    });

    function updateTimerDisplay(timerId) {
        const realTimeEl = document.getElementById(`real-${timerId}`);
        if (timers[timerId] && timers[timerId].interval) {
            const elapsedCurrent = Math.floor((Date.now() - timers[timerId].startTime) / 1000);
            const baseElapsed = timers[timerId].baseElapsed || 0;
            realTimeEl.textContent = formatTime(baseElapsed + elapsedCurrent);
        }
    }

    function stopProcess(timerId, skipTotalUpdate = false) {
        if (!timers[timerId] || !timers[timerId].interval) return;

        clearInterval(timers[timerId].interval);

    const endTime = Date.now();
    const startTimeRun = timers[timerId].startTime;
    const runSeconds = Math.floor((endTime - startTimeRun) / 1000);
    const baseElapsed = timers[timerId].baseElapsed || 0;
    const realTimeSeconds = baseElapsed + runSeconds;

        const startEl = document.getElementById(`start-${timerId}`);
        const endEl = document.getElementById(`end-${timerId}`);
        const realEl = document.getElementById(`real-${timerId}`);

        endEl.textContent = new Date(endTime).toLocaleTimeString();
    realEl.textContent = formatTime(realTimeSeconds);

        const [machineId, processId] = timerId.replace('m', '').replace('p', '').split('-');

        if (!skipTotalUpdate) {
            const prevTime = (completedProcessTimes[timerId] && typeof completedProcessTimes[timerId].time === 'number' ? completedProcessTimes[timerId].time : 0);
            if (!machineTotals[machineId]) {
                machineTotals[machineId] = 0;
            }
            machineTotals[machineId] = machineTotals[machineId] - prevTime + realTimeSeconds;
            const firstStart = completedProcessTimes[timerId]?.firstStartTime || startTimeRun;
            completedProcessTimes[timerId] = { time: realTimeSeconds, startTime: firstStart, firstStartTime: firstStart, endTime: endTime };
            // Actualizar solo el total de la máquina en el DOM (solo suma los tiempos detenidos)
            let totalTime = 0;
            for (let i = 1; i <= 3; i++) {
                const tId = `m${machineId}-p${i}`;
                const t = completedProcessTimes[tId];
                if (t && typeof t.time === 'number' && !isNaN(t.time)) {
                    totalTime += t.time;
                }
            }
            // Actualizar el span del total de la máquina usando el id único
            const totalSpan = document.getElementById(`total-m${machineId}`);
            if (totalSpan) {
                totalSpan.textContent = formatTime(totalTime);
                if (totalTime > 2700) {
                    totalSpan.classList.add('text-red-600');
                    totalSpan.classList.remove('text-stone-800');
                } else {
                    totalSpan.classList.remove('text-red-600');
                    totalSpan.classList.add('text-stone-800');
                }
            }
            // Actualizar tiempos muertos y total dinámicamente
            updateMuertosYTotal(machineId);
        }

        delete timers[timerId];
        document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = false;
        document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = true;
    }

    function handleButtonClick(e) {
        const target = e.target.closest('button');
        if (!target) return;

        const { action, timerId } = target.dataset;
        if (!action || !timerId) return;

        const [machineId, processId] = timerId.replace('m', '').replace('p', '').split('-');

        if (action === 'start') {
            // Detener y guardar cualquier proceso corriendo en la misma máquina
            machineData.find(m => m.id === machineId).processes.forEach(process => {
                const existingTimerId = `m${machineId}-p${process.id}`;
                if (existingTimerId !== timerId && timers[existingTimerId]) {
                    stopProcess(existingTimerId, false); // Guardar el tiempo
                }
            });

            if (timers[timerId] && timers[timerId].interval) return;
            const prev = completedProcessTimes[timerId];
            const now = Date.now();
            const baseElapsed = prev && typeof prev.time === 'number' ? prev.time : 0;
            timers[timerId] = {
                startTime: now,
                baseElapsed,
                interval: setInterval(() => updateTimerDisplay(timerId), 1000)
            };
            if(!prev || !prev.firstStartTime){
                completedProcessTimes[timerId] = { ...(prev||{}), firstStartTime: now, startTime: now, endTime: null, time: baseElapsed };
            }
            const startEl = document.getElementById(`start-${timerId}`);
            if(startEl){
                if(prev && prev.firstStartTime){
                    startEl.textContent = new Date(prev.firstStartTime).toLocaleTimeString();
                } else {
                    startEl.textContent = new Date(now).toLocaleTimeString();
                }
            }
            document.getElementById(`end-${timerId}`).textContent = '--:--:--';
            const realEl = document.getElementById(`real-${timerId}`);
            if(realEl) realEl.textContent = formatTime(baseElapsed);
            document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = true;
            document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = false;
        } else if (action === 'stop') {
            stopProcess(timerId);
        } else if (action === 'reset') {
            if (timers[timerId] && timers[timerId].interval) {
                clearInterval(timers[timerId].interval);
                delete timers[timerId];
            }
            completedProcessTimes[timerId] = { time: 0, startTime: null, firstStartTime: null, endTime: null };
            document.getElementById(`start-${timerId}`).textContent = '--:--:--';
            document.getElementById(`end-${timerId}`).textContent = '--:--:--';
            document.getElementById(`real-${timerId}`).textContent = '00:00:00';
            document.querySelector(`button[data-action="start"][data-timer-id="${timerId}"]`).disabled = false;
            document.querySelector(`button[data-action="stop"][data-timer-id="${timerId}"]`).disabled = true;
        }
    }

    // Delegación global de botones de procesos
    document.addEventListener('click', function(e){
        if (e.target.closest('button[data-action]')) {
            handleButtonClick(e);
        }
    });

    // Cambio de tipo de masa (select) para mostrar campo "Otro"
    document.addEventListener('change', function(e){
        const sel = e.target.closest('select.tipo-masa-select');
        if(!sel) return;
        const machineId = sel.getAttribute('data-machine');
        if(!machineId) return;
        const otroInput = document.getElementById(`tipoMasaOtro-${machineId}`);
        if(!otroInput) return;
        if(sel.value === '__OTRO__'){
            otroInput.classList.remove('hidden');
            otroInput.focus();
        } else {
            otroInput.classList.add('hidden');
            otroInput.value='';
        }
    });

    // Bloque eliminado: código huérfano de guardado general (sustituido por guardarResultadosPorMaquina)

    // Guardar resultados por máquina
    // Guardar campos temporales al cambiar cualquier input relevante
    machineCardsContainer.addEventListener('input', function(e) {
        const target = e.target;
        const idMatch = target.id && target.id.match(/^(lote|tipoMasa|tipoMasaOtro|tempMasa|obs)-(\d)$/);
        if (idMatch) {
            const field = idMatch[1];
            const machineId = idMatch[2];
            let tempData = {};
            try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
            tempData[machineId] = tempData[machineId] || {};
            if(field==='obs') tempData[machineId].observaciones = target.value;
            else tempData[machineId][field] = target.value;
            localStorage.setItem('tempAmasadoras', JSON.stringify(tempData));
        }
        // Radios de hielo
        if(target.name && target.name.startsWith('hielo-')){
            const machineId = target.name.split('-')[1];
            let tempData = {};
            try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
            tempData[machineId] = tempData[machineId] || {};
            tempData[machineId].hielo = target.value;
            localStorage.setItem('tempAmasadoras', JSON.stringify(tempData));
        }
    });
    // Limpiar datos temporales al guardar resultados
    machineCardsContainer.addEventListener('click', function(e) {
        const btn = e.target.closest('.guardar-maquina');
        if (!btn) return;
        const machineId = btn.getAttribute('data-machine-id');
        if (!machineId) return;
        // Limpiar datos temporales de esa máquina
        let tempData = {};
        try { tempData = JSON.parse(localStorage.getItem('tempAmasadoras')||'{}'); } catch(_){}
        delete tempData[machineId];
        localStorage.setItem('tempAmasadoras', JSON.stringify(tempData));
        guardarResultadosPorMaquina(machineId, btn);
    });

    function guardarResultadosPorMaquina(machineId, btn) {
        const fecha = document.getElementById('fecha').value;
        if (!fecha) {
            mostrarMsgMaquina(machineId, 'Selecciona una fecha para guardar.', false);
            return;
        }
        const machine = machineData.find(m => m.id === machineId);
        if (!machine) return;
        const procesos = {};
        machine.processes.forEach(process => {
            const timerId = `m${machine.id}-p${process.id}`;
            // Si está corriendo, tomar su startTime actual y tiempo transcurrido; si no, usar el completado
            let tiempo = 0, startTime = null, endTime = null;
            const tRun = timers[timerId];
            if (tRun && tRun.startTime) {
                startTime = completedProcessTimes[timerId]?.firstStartTime || tRun.startTime;
                const base = tRun.baseElapsed || 0;
                const current = Math.max(0, Math.floor((Date.now() - tRun.startTime) / 1000));
                tiempo = base + current;
                endTime = null; // aún en curso
            } else {
                const comp = completedProcessTimes[timerId] || { time: 0, startTime: null, endTime: null };
                tiempo = comp.time || 0;
                startTime = comp.firstStartTime || comp.startTime || null;
                endTime = comp.endTime || null;
            }
            const minutos = Math.floor((tiempo||0) / 60);
            const segundos = (tiempo||0) % 60;
            procesos[`proceso${process.id}`] = { minutos, segundos, startTime, endTime };
        });
    const tipoMasa = document.getElementById(`tipoMasa-${machine.id}`)?.value || '';
    let tipoMasaFinal = tipoMasa;
    if(tipoMasa === '__OTRO__'){
        const otroVal = document.getElementById(`tipoMasaOtro-${machine.id}`)?.value.trim();
        tipoMasaFinal = otroVal || '';
    }
        // Obtener valor de hielo
        let hielo = '';
        if (document.getElementById(`hielo-si-${machine.id}`).checked) hielo = 'Si';
        else if (document.getElementById(`hielo-no-${machine.id}`).checked) hielo = 'No';
        // Obtener número de personal
    const personalMin = document.getElementById('personal-min')?.value || '';
    const personalMax = document.getElementById('personal-max')?.value || '';
        // Obtener observaciones
        const observaciones = document.getElementById(`obs-${machine.id}`).value || '';
        // Obtener variables nuevas
        const tempAmbiente = document.getElementById('ta').value || '';
        const humedad = document.getElementById('h').value || '';
        const tempMasa = document.getElementById(`tempMasa-${machine.id}`).value || '';
        const lote = document.getElementById(`lote-${machine.id}`)?.value || '';
        const maquinaObj = {
            id: machine.id,
            nombre: machine.name,
            numeroAmasadora: machine.id,
            lote,
            tipoMasa: tipoMasaFinal,
            hielo,
            personalMin,
            personalMax,
            tempAmbiente,
            humedad,
            tempMasa,
            observaciones,
            ...procesos
        };
        // Validación: procesos completos (tiempo > 0 y con start & end)
        const incompletos = [];
        machine.processes.forEach(p=>{
            const o = maquinaObj['proceso'+p.id];
            const totalSeg = ((o?.minutos||0)*60) + (o?.segundos||0);
            if(!o || totalSeg===0 || !o.startTime || !o.endTime){ incompletos.push(p.name); }
        });
        if(incompletos.length){
            mostrarMsgMaquina(machineId, 'Completa procesos: '+incompletos.join(', '), false);
            return;
        }
    let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
    resultados.push({ fecha, maquinas: [maquinaObj] });
    localStorage.setItem('resultadosMezclado', JSON.stringify(resultados));
    mostrarMsgMaquina(machineId, '¡Resultados guardados correctamente!', true);
    }

    function mostrarMsgMaquina(machineId, msg, ok) {
        const msgDiv = document.getElementById('msg-guardar-' + machineId);
        if (msgDiv) {
            msgDiv.textContent = msg;
            msgDiv.className = 'mt-2 text-center ' + (ok ? 'text-green-700 bg-green-100 border border-green-300 rounded p-2' : 'text-red-700 bg-red-100 border border-red-300 rounded p-2');
            setTimeout(() => { msgDiv.textContent = ''; }, 3000);
        }
    }

    function cargarResultados() {
    // Botón Clear para borrar todos los resultados
    document.getElementById('btn-clear-resultados')?.addEventListener('click', function() {
        if (confirm('¿Seguro que deseas borrar TODOS los resultados de mezclado?')) {
            localStorage.removeItem('resultadosMezclado');
            cargarResultados();
            document.getElementById('promedios').innerHTML = '';
        }
    });
    // Obtener el contenedor de la lista de resultados
    const resultadosLista = document.getElementById('resultados-lista');
    if (!resultadosLista) return;
    resultadosLista.innerHTML = '<div class="text-stone-500 text-center">Cargando...</div>';
    let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
    if (!resultados.length) {
        resultadosLista.innerHTML = '<div class="text-stone-500 text-center">No hay resultados registrados.</div>';
        return;
    }
    resultadosLista.innerHTML = '';
    // Filtros
    const filtroFecha = document.getElementById('filtro-fecha')?.value;
    const filtroTipo = document.getElementById('filtro-tipo')?.value?.toLowerCase() || '';
    const filtroMaquina = document.getElementById('filtro-maquina')?.value?.toLowerCase() || '';
    let sumaTotales = 0, cuentaTotales = 0, sumaProc = [0,0,0], cuentaProc = [0,0,0];
    let totalesArr = [], procArr = [[],[],[]];
        resultados.forEach((res, idx) => {
            const fecha = res.fecha || '--';
            if (filtroFecha && fecha !== filtroFecha) return;
            // Mostrar rango de Personal general si existe (mín–máx)
            let personalGeneralMin = '';
            let personalGeneralMax = '';
            if (res.maquinas && res.maquinas.length > 0) {
                personalGeneralMin = res.maquinas[0].personalMin || '';
                personalGeneralMax = res.maquinas[0].personalMax || '';
            }
            const maquinas = res.maquinas || [];
            maquinas.forEach((maq, maqIdx) => {
                const tipoPan = maq.tipoMasa || maq.tipoPan || '--';
                const nombre = maq.nombre || maq.id || '--';
                const lote = maq.lote || '--';
                if (filtroTipo && !tipoPan.toLowerCase().includes(filtroTipo)) return;
                if (filtroMaquina && !nombre.toLowerCase().includes(filtroMaquina)) return;
                let procesosHtml = '';
                let tiempoMuerto1 = 0, tiempoMuerto2 = 0;
                // Calcular tiempos muertos
                if (maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime) {
                    tiempoMuerto1 = Math.max(0, Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000));
                }
                if (maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime) {
                    tiempoMuerto2 = Math.max(0, Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000));
                }
                let primerStart = maq.proceso1 && maq.proceso1.startTime ? maq.proceso1.startTime : null;
                let ultimoEnd = maq.proceso3 && maq.proceso3.endTime ? maq.proceso3.endTime : null;
                let totalSeg = null;
                if (primerStart && ultimoEnd) {
                    totalSeg = Math.max(0, Math.floor((ultimoEnd - primerStart)/1000));
                }
                // Sumar a promedios solo si hay total válido
                if (totalSeg !== null) {
                    sumaTotales += totalSeg;
                    cuentaTotales++;
                    totalesArr.push(totalSeg);
                }
                // Procesos individuales y promedios
                for (let i = 1; i <= 3; i++) {
                    const proc = maq[`proceso${i}`] || {};
                    const t = (parseInt(proc.minutos) || 0) * 60 + (parseInt(proc.segundos) || 0);
                    sumaProc[i-1] += t;
                    cuentaProc[i-1]++;
                    procArr[i-1].push(t);
                    let inicio = proc.startTime ? new Date(proc.startTime).toLocaleTimeString() : '--:--:--';
                    let fin = proc.endTime ? new Date(proc.endTime).toLocaleTimeString() : '--:--:--';
                    procesosHtml += `
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700 tooltip'>${['Esponja','Masa','Mantequilla'][i-1]}:
                                    <span class="tooltiptext">Tiempo de proceso ${['Esponja','Masa','Mantequilla'][i-1]}</span>
                                </span>
                                <span class='font-mono text-lg text-stone-900'>${(proc.minutos+'').padStart(2,'0')}:${(proc.segundos+'').padStart(2,'0')}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${inicio}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin}</span></div>
                        </div>
                        `;
                }
                // Calcular total de tiempos muertos
                let totalMuertos = tiempoMuerto1 + tiempoMuerto2;
                // Día de la semana
                let diaSemana = '--';
                if (fecha && fecha.length === 10) {
                    const dias = ['Domingo','Lunes','Martes','Miercoles','Jueves','Viernes','Sábado'];
                    // Ajustar para zona local y evitar desfase por UTC
                    const [anio, mes, dia] = fecha.split('-').map(Number);
                    const fechaLocal = new Date(anio, mes - 1, dia);
                    diaSemana = dias[fechaLocal.getDay()];
                }
                // Alternar color de fondo
                const bgAlt = (idx+maqIdx)%2===0 ? 'bg-white' : 'bg-stone-100';
                // Icono advertencia si pasa de 45 min
                const advertencia = totalSeg > 2700 ? `<span title="Supera 45 minutos" class="ml-2 text-red-600 text-2xl align-middle">&#9888;</span>` : '';
                // Mostrar hielo
                const hielo = maq.hielo ? maq.hielo : '--';
                // Dedupe badge (si ya fue enviada esta amasadora a la BD)
                let _sent = false; let _sentBadge='';
                try { _sent = __wasSent(__sig(fecha, maq)); if(_sent){ _sentBadge = '<span class="ml-2 inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-semibold bg-emerald-600 text-white">Enviado</span>'; } } catch(_){ }
                const enviarBtnHtml = _sent
                    ? `<button class="enviar-bd bg-stone-400 text-white px-6 py-3 rounded-lg font-bold text-lg shadow cursor-not-allowed" data-idx="${idx}" data-maqidx="${maqIdx}" disabled>Ya enviado</button>`
                    : `<button class="enviar-bd bg-amber-600 text-white px-6 py-3 rounded-lg hover:bg-amber-700 transition-colors font-bold text-lg shadow" data-idx="${idx}" data-maqidx="${maqIdx}">Enviar a BD</button>`;
                resultadosLista.innerHTML += `
                <div class="${bgAlt} rounded-2xl shadow-lg p-8 border border-stone-200 mb-6 fade-in">
                    <div class="mb-6 flex flex-wrap gap-8 justify-between items-center">
                        <span class="text-stone-800 font-bold text-xl">Fecha: <span class="font-mono text-lg">${fecha}</span> <span class="text-base text-stone-500">(${diaSemana})</span> ${_sentBadge}</span>
                        <span class="text-stone-800 font-bold text-xl">Lote: <span class="font-mono text-lg">${lote}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Tipo de masa: <span class="font-mono text-lg">${tipoPan}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Amasadora: <span class="font-mono text-lg">${(maq.numeroAmasadora || (nombre.match(/\d+/)?.[0]) || '?')}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Hielo: <span class="font-mono text-lg">${hielo}</span></span>
                        <span class="text-stone-800 font-bold text-xl">H: <span class="font-mono text-lg">${maq.humedad || '--'}%</span></span>
                        <span class="text-stone-800 font-bold text-xl">TM: <span class="font-mono text-lg">${maq.tempMasa || '--'}C</span></span>
                        <span class="text-stone-800 font-bold text-xl">TA: <span class="font-mono text-lg">${maq.tempAmbiente || '--'}C</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 1: <span class="font-mono text-lg">${formatTime(tiempoMuerto1)}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 2: <span class="font-mono text-lg">${formatTime(tiempoMuerto2)}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muertos Total: <span class="font-mono text-lg">${formatTime(totalMuertos)}</span></span>
                        ${maqIdx === 0 && (personalGeneralMin || personalGeneralMax) ? `<span class='text-stone-800 font-bold text-xl'>Personal: <span class='font-mono text-lg'>${personalGeneralMin||'?'}–${personalGeneralMax||'?'}</span></span>` : ''}
                    </div>
                    <div class="mb-4 divide-y divide-stone-200">
                        ${procesosHtml}
                    </div>
                    <div class="mb-4">
                        <span class="block text-base font-semibold text-stone-800">Obs:</span>
                        <div class="bg-stone-100 rounded p-2 min-h-[2rem]">${maq.observaciones ? maq.observaciones : '<span class=\"text-stone-400\">(Sin observaciones)</span>'}</div>
                    </div>
                    <div class="mt-4 font-extrabold text-2xl text-blue-700 text-right">Total: ${totalSeg !== null ? formatTime(totalSeg) : '--:--:--'} ${advertencia}</div>
                    <div class="mt-6 flex flex-wrap gap-3 justify-center">
                        ${enviarBtnHtml}
                        <button class="borrar-resultado bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition-colors font-bold text-lg shadow" data-idx="${idx}" data-maqidx="${maqIdx}">Borrar</button>
                    </div>
                </div>
                `;
            });
        });
    // Mostrar promedios generales y por tipo de masa
        let promediosHtml = '';
        function stddev(arr) {
            if (!arr.length) return 0;
            const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
            return Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-mean,2),0)/arr.length);
        }
        function relStddev(std, mean) {
            if (!mean) return '0%';
            return ((std/mean)*100).toFixed(1) + '%';
        }
        // Promedios generales
        if (cuentaTotales > 0) {
            const prom = Math.round(sumaTotales/cuentaTotales);
            const std = Math.round(stddev(totalesArr));
            const rel = relStddev(std, prom);
            promediosHtml += `<span>Promedio total: <span class=\"font-mono\">${formatTime(prom)}</span> (±${formatTime(std)}, ${rel})</span> &nbsp;`;
            for (let i=0; i<3; i++) {
                if (cuentaProc[i]) {
                    const promP = Math.round(sumaProc[i]/cuentaProc[i]);
                    const stdP = Math.round(stddev(procArr[i]));
                    const relP = relStddev(stdP, promP);
                    promediosHtml += `<span>${['Esponja','Masa','Mantequilla'][i]}: <span class=\"font-mono\">${formatTime(promP)}</span> (±${formatTime(stdP)}, ${relP})</span> &nbsp;`;
                }
            }
        }
    // (Tabla de promedios por tipo de masa movida solo a gráficas)
        document.getElementById('promedios').innerHTML = promediosHtml;
    // Evento para borrar resultado
    resultadosLista.addEventListener('click', function(e) {
        const btn = e.target.closest('.borrar-resultado');
        if (!btn) return;
        if (!confirm('¿Seguro que deseas borrar este resultado?')) return;
        const card = btn.closest('div.rounded-2xl');
        if (card) {
            card.classList.remove('fade-in');
            card.classList.add('fade-out');
            setTimeout(() => {
                const idx = parseInt(btn.getAttribute('data-idx'));
                const maqIdx = parseInt(btn.getAttribute('data-maqidx'));
                let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
                if (resultados[idx] && resultados[idx].maquinas && resultados[idx].maquinas[maqIdx]) {
                    resultados[idx].maquinas.splice(maqIdx, 1);
                    if (resultados[idx].maquinas.length === 0) {
                        resultados.splice(idx, 1);
                    }
                    localStorage.setItem('resultadosMezclado', JSON.stringify(resultados));
                    cargarResultados();
                }
            }, 500);
        }
    });
    // Subpestañas Local/BD
    (function(){
        const localW = document.getElementById('resultados-local-wrapper');
        const bdW = document.getElementById('bd-wrapper');
        const subLocal = document.getElementById('subtab-local');
        const subBD = document.getElementById('subtab-bd');
        function showLocal(){ localStorage.setItem('RESULTADOS_SUBTAB','local'); localW?.classList.remove('hidden'); bdW?.classList.add('hidden'); subLocal?.classList.add('tab-btn-active'); subBD?.classList.remove('tab-btn-active'); }
        function showBD(){ localStorage.setItem('RESULTADOS_SUBTAB','bd'); bdW?.classList.remove('hidden'); localW?.classList.add('hidden'); subBD?.classList.add('tab-btn-active'); subLocal?.classList.remove('tab-btn-active'); loadBDView(); }
        subLocal?.addEventListener('click', e=>{ e.preventDefault(); showLocal(); });
        subBD?.addEventListener('click', e=>{ e.preventDefault(); showBD(); });
        const preferred = localStorage.getItem('RESULTADOS_SUBTAB');
        const apiUrl = localStorage.getItem('API_URL_OVERRIDE')||'';
        const apiKey = sessionStorage.getItem('API_KEY') || localStorage.getItem('API_KEY_PERSIST') || '';
        if(preferred==='bd' && (apiUrl||apiKey)) { showBD(); return; }
        if(apiUrl || apiKey){
            // Si no hay preferencia pero usuario tiene credenciales, mostrar BD directamente
            showBD();
        } else {
            showLocal();
        }
    })();

    // Enviar todo a la BD (local)
    let _sendingAllInFlight = false;
    document.getElementById('btn-enviar-todo-bd')?.addEventListener('click', async function(){
        const fecha = document.getElementById('filtro-fecha')?.value || document.getElementById('fecha')?.value;
        const status = document.getElementById('local-bd-status');
        try{
            if(_sendingAllInFlight){ return; }
            _sendingAllInFlight = true;
            if(!fecha){ status.textContent = 'Selecciona una fecha o filtra una fecha para enviar.'; status.className='text-xs text-red-600 text-center'; return; }
            const payload = construirPayloadFecha(fecha);
            if(!payload){ status.textContent = 'No hay datos locales para esa fecha.'; status.className='text-xs text-stone-600 text-center'; return; }
            // --- DEDUPE (filtrar amasadoras ya enviadas) ---
            try {
                const original = payload.amasadoras || [];
                let skipped = 0;
                payload.amasadoras = original.filter(m=>{ const s=__sig(payload.fecha, m); if(__wasSent(s)){ skipped++; return false;} return true; });
                if(payload.amasadoras.length===0){ status.textContent = 'Todos los registros de esa fecha ya habían sido enviados (0 nuevos).'; status.className='text-xs text-amber-600 text-center'; return; }
                if(skipped>0){ status.textContent = `Filtrados ${skipped} duplicados. Enviando ${payload.amasadoras.length} nuevos...`; status.className='text-xs text-stone-600 text-center'; }
            }catch(_){ /* ignore dedupe errors */ }
            const base=resolveApiBase();
            const url = base + '/registros';
            const r = await fetch(url,{ method:'POST', headers: apiHeaders(true), body: JSON.stringify(payload) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            const n = payload.amasadoras?.length || 0;
            status.textContent = `¡Enviado a BD correctamente! (${n} amasadora${n===1?'':'s'})`; status.className='text-xs text-green-600 text-center';
            // Marcar firmas enviadas
            try { (payload.amasadoras||[]).forEach(m=> __markSent(__sig(payload.fecha,m))); } catch(_){ }
        }catch(e){ status.textContent = 'Error enviando: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
        finally{ _sendingAllInFlight = false; }
    });

    // Manejar click en "Enviar a BD" por tarjeta
    let _sendingCardInFlight = false;
    document.getElementById('resultados-lista')?.addEventListener('click', async function(e){
        const btn = e.target.closest('.enviar-bd');
        if(!btn) return;
        const idx = parseInt(btn.getAttribute('data-idx'));
        const maqIdx = parseInt(btn.getAttribute('data-maqidx'));
        const status = document.getElementById('local-bd-status');
        try{
            if(_sendingCardInFlight){ return; }
            _sendingCardInFlight = true;
            const resultados = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            const reg = resultados[idx];
            if(!reg){ throw new Error('Registro no encontrado'); }
            const maq = reg.maquinas?.[maqIdx];
            if(!maq){ throw new Error('Amasadora no encontrada'); }
            // Construir payload solo con esa máquina
            const procesos=[]; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ procesos.push({ id:i, minutos: parseInt(p.minutos)||0, segundos: parseInt(p.segundos)||0, startTime: p.startTime||null, endTime: p.endTime||null }); } }
            // Derivados: TM1, TM2, muertos total, total real (primer inicio a último fin) y total procesos
            const p1 = maq.proceso1||{}; const p2 = maq.proceso2||{}; const p3 = maq.proceso3||{};
            const toSecs = (pp)=> (parseInt(pp?.minutos)||0)*60 + (parseInt(pp?.segundos)||0);
            const sumProcesosSeg = toSecs(p1)+toSecs(p2)+toSecs(p3);
            const tm1Seg = (p1?.endTime && p2?.startTime) ? Math.max(0, Math.floor((p2.startTime - p1.endTime)/1000)) : null;
            const tm2Seg = (p2?.endTime && p3?.startTime) ? Math.max(0, Math.floor((p3.startTime - p2.endTime)/1000)) : null;
            const muertosSeg = (tm1Seg||0) + (tm2Seg||0);
            const totalRealSeg = (p1?.startTime && p3?.endTime) ? Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)) : null;
            const nombreMaq = maq.nombre||maq.id||'';
            const numeroAmasadora = maq.numeroAmasadora || (nombreMaq.match(/\d+/)?.[0]) || '';
            const payload = {
                fecha: reg.fecha,
                tempAmbiente: maq.tempAmbiente||reg.maquinas?.[0]?.tempAmbiente||'',
                humedad: maq.humedad||reg.maquinas?.[0]?.humedad||'',
                personalMin: reg.maquinas?.[0]?.personalMin||'',
                personalMax: reg.maquinas?.[0]?.personalMax||'',
                // Resumen/agrupados a nivel de registro (un solo equipo en este caso)
                resumenDia: (function(){
                    const tMasa = parseFloat(maq.tempMasa);
                    const tipo = (maq.tipoMasa||maq.tipoPan||'').trim();
                    const hielo = (maq.hielo||'').trim();
                    return {
                        fecha: reg.fecha,
                        cantidadAmasadoras: 1,
                        tm1SegDia: tm1Seg||0,
                        tm2SegDia: tm2Seg||0,
                        muertosSegDia: muertosSeg,
                        totalRealSegDia: totalRealSeg||0,
                        totalProcesosSegDia: sumProcesosSeg,
                        promedioTempMasaDia: Number.isFinite(tMasa) ? tMasa : null,
                        tiposMasaConteo: tipo ? { [tipo]: 1 } : {},
                        hieloConteo: hielo ? { [hielo]: 1 } : {}
                    };
                })(),
                amasadoras: [{
                    id: maq.id||numeroAmasadora||'',
                    nombre: nombreMaq,
                    numeroAmasadora,
                    tipoMasa: maq.tipoMasa||maq.tipoPan||'',
                    hielo: maq.hielo||'',
                    lote: maq.lote||'',
                    tempMasa: maq.tempMasa||'',
                    observaciones: maq.observaciones||'',
                    // factores por máquina (también en raíz, pero se duplican aquí para auditoría por máquina)
                    personalMin: maq.personalMin||reg.maquinas?.[0]?.personalMin||'',
                    personalMax: maq.personalMax||reg.maquinas?.[0]?.personalMax||'',
                    tempAmbiente: maq.tempAmbiente||reg.maquinas?.[0]?.tempAmbiente||'',
                    humedad: maq.humedad||reg.maquinas?.[0]?.humedad||'',
                    // métricas derivadas
                    tm1Seg, tm2Seg, muertosSeg, totalRealSeg, totalProcesosSeg: sumProcesosSeg,
                    procesos
                }]
            };
            const base=resolveApiBase();
            const url = base + '/registros';
            // DEDUPE single tarjeta
            try {
                const sig = __sig(payload.fecha, payload.amasadoras?.[0]||{});
                if(__wasSent(sig)){
                    status.textContent = 'Esta amasadora ya fue enviada antes. (Omitida)'; status.className='text-xs text-amber-600 text-center';
                    return;
                }
            }catch(_){ /* ignore */ }
            const r = await fetch(url,{ method:'POST', headers: apiHeaders(true), body: JSON.stringify(payload) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            status.textContent = '¡Tarjeta enviada a BD correctamente!'; status.className='text-xs text-green-600 text-center';
            try { const sig = __sig(payload.fecha, payload.amasadoras?.[0]||{}); __markSent(sig); }catch(_){ }
        }catch(err){ status.textContent = 'Error enviando tarjeta: '+(err.message||err); status.className='text-xs text-red-600 text-center'; }
        finally{ _sendingCardInFlight = false; }
    });

    // ============ Vista BD remota ============
    let BD_CACHE = [];
    async function loadBDView(){
        const base = resolveApiBase();
        const url = base + '/registros';
        const cont = document.getElementById('bd-lista');
        const status = document.getElementById('sync-status');
        if(!cont) return;
        cont.innerHTML = '<div class="text-stone-500 text-center">Cargando...</div>';
        try{
            const r = await fetch(url, { headers: apiHeaders(false) });
            if(!r.ok) throw new Error('HTTP '+r.status);
            const arr = await r.json();
            BD_CACHE = Array.isArray(arr) ? arr : [];
            renderBDList();
            status.textContent = `Cargados ${arr.length} registros de la BD.`; status.className='text-xs text-green-600 text-center';
        }catch(e){ cont.innerHTML = '<div class="text-red-600 text-center">Error cargando BD: '+(e.message||e)+'</div>'; status.textContent=''; }
    }
    function getBDFiltered(){
        const fFecha = document.getElementById('bd-filtro-fecha')?.value || '';
        const fTipo = (document.getElementById('bd-filtro-tipo')?.value || '').toLowerCase();
        const fMaq = (document.getElementById('bd-filtro-maquina')?.value || '').toLowerCase();
        if(!Array.isArray(BD_CACHE) || !BD_CACHE.length) return [];
        // Filtrado: fecha en el registro; tipo/amasadora en cada máquina
        const out = [];
        BD_CACHE.forEach(rec=>{
            const fecha = rec.data?.fecha || rec.fecha || '';
            if(fFecha && fecha !== fFecha) return;
            const amas = Array.isArray(rec.data?.amasadoras) ? rec.data.amasadoras : [];
            const amasFiltradas = amas.filter(m=>{
                const tipo = (m.tipoMasa || m.tipoPan || '').toLowerCase();
                const nombre = (m.nombre || m.id || '').toLowerCase();
                const amNum = (m.numeroAmasadora || (String(m.nombre||m.id||'').match(/\d+/)?.[0]||'')).toString();
                const maqStr = (nombre + ' ' + amNum).toLowerCase();
                if(fTipo && !tipo.includes(fTipo)) return false;
                if(fMaq && !maqStr.includes(fMaq)) return false;
                return true;
            });
            if(amasFiltradas.length){
                out.push({ ...rec, data: { ...(rec.data||{}), amasadoras: amasFiltradas } });
            }
        });
        return out;
    }
    function renderBDList(){
        const cont = document.getElementById('bd-lista');
        if(!cont) return;
        const items = getBDFiltered();
        if(!Array.isArray(items) || !items.length){ cont.innerHTML = '<div class="text-stone-500 text-center">No hay registros en la BD.</div>'; return; }
        cont.innerHTML = '';
        // Helper: normaliza procesos[] a proceso1..3 si faltan
        function normalizeMaq(m){
            if(m && !m.proceso1 && Array.isArray(m.procesos)){
                const map = {}; m.procesos.forEach(p=>{ if(p && p.id!=null){ map['proceso'+p.id] = { minutos: p.minutos||0, segundos: p.segundos||0, startTime: p.startTime||null, endTime: p.endTime||null }; } });
                return { ...m, ...map };
            }
            return m;
        }
        // Aplanar: una tarjeta por amasadora
        items.forEach(it=>{
            const fecha = it.data?.fecha || it.fecha || '';
            const id = it.id;
            const creado = it.createdAt ? new Date(it.createdAt).toLocaleString() : '';
            const amas = (it.data?.amasadoras || []).map(normalizeMaq);
            (amas||[]).forEach((m,i)=>{
                const amNumRaw = m.numeroAmasadora || ((m.nombre||m.id||'').match(/\d+/)?.[0]);
                const amNum = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                const nombreAma = 'Amasadora ' + amNum;
                const tipo = (m.tipoMasa||m.tipoPan||'')||'--';
                const lote = m.lote||'--';
                const hielo = m.hielo||'--';
                const tm = (m.tempMasa!=null && m.tempMasa!=='')? `${m.tempMasa}`:'--';
                const ta = (m.tempAmbiente!=null && m.tempAmbiente!=='')? `${m.tempAmbiente}`:'--';
                const h = (m.humedad!=null && m.humedad!=='')? `${m.humedad}`:'--';
                const perMin = m.personalMin||'';
                const perMax = m.personalMax||'';
                // Derivados si faltan
                const p1 = m.proceso1||{}; const p2 = m.proceso2||{}; const p3 = m.proceso3||{};
                const tm1Seg = (m.tm1Seg!=null)? m.tm1Seg : ((p1?.endTime && p2?.startTime)? Math.max(0, Math.floor((p2.startTime - p1.endTime)/1000)) : null);
                const tm2Seg = (m.tm2Seg!=null)? m.tm2Seg : ((p2?.endTime && p3?.startTime)? Math.max(0, Math.floor((p3.startTime - p2.endTime)/1000)) : null);
                const muertosSeg = (tm1Seg||0) + (tm2Seg||0);
                const totalRealSeg = (m.totalRealSeg!=null)? m.totalRealSeg : ((p1?.startTime && p3?.endTime)? Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)) : null);
                // Helpers
                const pFmt = (p)=> p? `${String(p.minutos||0).padStart(2,'0')}:${String(p.segundos||0).padStart(2,'0')}` : '--:--';
                const ini = (x)=> x? new Date(x).toLocaleTimeString() : '--:--:--';
                const fin = (x)=> x? new Date(x).toLocaleTimeString() : '--:--:--';
                const advertencia = (totalRealSeg!=null && totalRealSeg>2700) ? `<span title="Supera 45 minutos" class="ml-2 text-red-600 text-2xl align-middle">&#9888;</span>` : '';
                const card = document.createElement('div');
                const _selKey = id+':'+i;
                const checked = __BD_SELECTED.some(s=> s.key===_selKey) ? 'checked' : '';
                card.className = 'relative bg-white rounded-2xl shadow-lg p-6 border border-stone-200 mb-6';
                card.setAttribute('data-id', id);
                card.setAttribute('data-ama-index', i);
                card.innerHTML = `
                    ${__BD_SELECT_MODE ? `<div class='absolute top-2 left-2'><input type="checkbox" class="bd-select-chk w-5 h-5" data-key="${_selKey}" ${checked} /></div>`:''}
                    <div class="mb-4 flex flex-wrap gap-6 justify-between items-center">
                        <span class="text-stone-800 font-bold text-xl">Fecha: <span class="font-mono text-lg">${fecha}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Lote: <span class="font-mono text-lg">${lote}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Tipo de masa: <span class="font-mono text-lg">${tipo}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Amasadora: <span class="font-mono text-lg">${amNum}</span></span>
                        <span class="text-stone-800 font-bold text-xl">Hielo: <span class="font-mono text-lg">${hielo}</span></span>
                        <span class="text-stone-800 font-bold text-xl">H: <span class="font-mono text-lg">${h}%</span></span>
                        <span class="text-stone-800 font-bold text-xl">TM: <span class="font-mono text-lg">${tm}C</span></span>
                        <span class="text-stone-800 font-bold text-xl">TA: <span class="font-mono text-lg">${ta}C</span></span>
                        ${(perMin||perMax)? `<span class="text-stone-800 font-bold text-xl">Personal: <span class="font-mono text-lg">${perMin||'?'}–${perMax||'?'}</span></span>`:''}
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 1: <span class="font-mono text-lg">${tm1Seg!=null? formatTime(tm1Seg):'--:--:--'}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muerto 2: <span class="font-mono text-lg">${tm2Seg!=null? formatTime(tm2Seg):'--:--:--'}</span></span>
                        <span class="text-stone-800 font-bold text-xl">T. Muertos Total: <span class="font-mono text-lg">${formatTime(muertosSeg)}</span></span>
                    </div>
                    <div class="mb-4 divide-y divide-stone-200">
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700'>Esponja:</span>
                                <span class='font-mono text-lg text-stone-900'>${pFmt(p1)}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${ini(p1.startTime)}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin(p1.endTime)}</span></div>
                        </div>
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700'>Masa:</span>
                                <span class='font-mono text-lg text-stone-900'>${pFmt(p2)}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${ini(p2.startTime)}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin(p2.endTime)}</span></div>
                        </div>
                        <div class='flex flex-col py-3'>
                            <div class='flex justify-between items-center mb-1'>
                                <span class='font-bold text-lg text-stone-700'>Mantequilla:</span>
                                <span class='font-mono text-lg text-stone-900'>${pFmt(p3)}</span>
                            </div>
                            <div class='flex justify-between text-sm text-stone-500 mb-0.5'><span>Inicio:</span> <span>${ini(p3.startTime)}</span></div>
                            <div class='flex justify-between text-sm text-stone-500'><span>Fin:</span> <span>${fin(p3.endTime)}</span></div>
                        </div>
                    </div>
                    <div class="mb-4">
                        <span class="block text-base font-semibold text-stone-800">Obs:</span>
                        <div class="bg-stone-100 rounded p-2 min-h-[2rem]">${m.observaciones ? m.observaciones : '<span class=\"text-stone-400\">(Sin observaciones)</span>'}</div>
                    </div>
                    <div class="mt-2 font-extrabold text-2xl text-blue-700 text-right">Total: ${totalRealSeg!=null? formatTime(totalRealSeg):'--:--:--'} ${advertencia}</div>
                    <div class="mt-6 flex flex-wrap gap-2 justify-end text-xs text-stone-500">
                        <span>Registro ID: ${id}</span>
                        <span>Creado: ${creado}</span>
                    </div>
                    <div class="mt-3 flex flex-wrap gap-3 justify-center">
                        <button class="bd-view-json-ama bg-stone-600 text-white px-3 py-1 rounded text-sm" data-id="${id}" data-ama-index="${i}">Ver JSON (amasadora)</button>
                        ${__BD_SELECT_MODE? '' : `<button class="bd-delete bg-red-600 text-white px-3 py-1 rounded text-sm" data-id="${id}" title="Borra todo el registro (todas las amasadoras)">Borrar registro</button>`}
                    </div>
                `;
                cont.appendChild(card);
            });
        });
    }
    document.getElementById('bd-refresh')?.addEventListener('click', loadBDView);
    // Refiltrar al escribir
    ['bd-filtro-fecha','bd-filtro-tipo','bd-filtro-maquina'].forEach(id=>{
        document.getElementById(id)?.addEventListener('input', ()=> renderBDList());
    });
    document.getElementById('bd-delete-all')?.addEventListener('click', async function(){
        if(!confirm('¿Seguro que deseas borrar TODOS los registros en la BD?')) return;
        const base=resolveApiBase();
        const url = base + '/registros';
        const status = document.getElementById('sync-status');
        try{
            const r = await fetch(url,{ method:'DELETE', headers: apiHeaders(false) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            status.textContent = 'Registros eliminados.'; status.className='text-xs text-green-600 text-center';
            loadBDView();
        }catch(e){ status.textContent='Error al borrar: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
    });
    document.getElementById('bd-lista')?.addEventListener('click', async function(e){
        // Selección múltiple (checkbox)
        const chk = e.target.closest('.bd-select-chk');
        if(chk){
            const key = chk.getAttribute('data-key');
            const card = chk.closest('div[data-id]');
            const id = card?.getAttribute('data-id');
            const amaIndex = card?.getAttribute('data-ama-index');
            if(chk.checked){
                if(!__BD_SELECTED.some(s=>s.key===key)) __BD_SELECTED.push({ key, id, amaIndex: parseInt(amaIndex) });
            } else {
                __BD_SELECTED = __BD_SELECTED.filter(s=> s.key!==key);
            }
            updateBDSelectedUI();
            return;
        }
        // Ver JSON de la amasadora individual
        const viewAmaBtn = e.target.closest('.bd-view-json-ama');
        if(viewAmaBtn){
            const id = viewAmaBtn.getAttribute('data-id');
            const idx = parseInt(viewAmaBtn.getAttribute('data-ama-index'));
            const rec = (BD_CACHE||[]).find(x=> String(x.id)===String(id));
            const ama = rec?.data?.amasadoras?.[idx];
            const modal = document.getElementById('json-modal');
            const pre = document.getElementById('json-modal-content');
            if(modal && pre){
                const payload = ama ? { registroId: rec.id, fecha: rec.data?.fecha||rec.fecha||'', ...ama } : (rec?.data ?? rec ?? {});
                pre.textContent = JSON.stringify(payload, null, 2);
                modal.classList.remove('hidden');
                modal.classList.add('flex');
            }
            return;
        }
        const btn = e.target.closest('.bd-delete');
        if(!btn) return;
        const id = btn.getAttribute('data-id');
        if(!id) return;
        if(!confirm('¿Borrar registro '+id+'? (Se eliminarán todas las amasadoras de ese registro)')) return;
        const base=resolveApiBase();
        const url = base + '/registros/'+id;
        const status = document.getElementById('sync-status');
        try{
            const r = await fetch(url,{ method:'DELETE', headers: apiHeaders(false) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            status.textContent = 'Registro eliminado.'; status.className='text-xs text-green-600 text-center';
            loadBDView();
        }catch(e){ status.textContent = 'Error al borrar: '+(e.message||e); status.className='text-xs text-red-600 text-center'; }
    });

    // --------- MULTI-SELECT BD STATE & HELPERS ---------
    let __BD_SELECT_MODE = false;
    let __BD_SELECTED = [];
    function updateBDSelectedUI(){
        const countEl = document.getElementById('bd-selected-count');
        if(countEl) countEl.textContent = __BD_SELECTED.length;
        const delBtn = document.getElementById('bd-delete-selected');
        if(delBtn) delBtn.classList.toggle('hidden', __BD_SELECTED.length===0 || !__BD_SELECT_MODE);
    }
    function toggleBDSelectMode(){
        __BD_SELECT_MODE = !__BD_SELECT_MODE;
        if(!__BD_SELECT_MODE){ __BD_SELECTED = []; }
        const btn = document.getElementById('bd-select-mode');
        if(btn) btn.textContent = __BD_SELECT_MODE ? 'Cancelar selección' : 'Seleccionar';
        updateBDSelectedUI();
        renderBDList();
    }
    document.getElementById('bd-select-mode')?.addEventListener('click', toggleBDSelectMode);
    document.getElementById('bd-delete-selected')?.addEventListener('click', async function(){
        if(!__BD_SELECTED.length) return;
        if(!confirm('¿Eliminar '+__BD_SELECTED.length+' elemento(s) seleccionados?')) return;
        const status = document.getElementById('sync-status');
        const base = resolveApiBase();
        let ok=0, fail=0;
        for(const sel of __BD_SELECTED){
            try{
                // Determinar si eliminamos una sola amasadora o registro completo (si sólo 1 en data)
                const rec = (BD_CACHE||[]).find(r=> String(r.id)===String(sel.id));
                const amas = Array.isArray(rec?.data?.amasadoras)? rec.data.amasadoras: [];
                let url='';
                if(amas.length>1){ // borrar solo la amasadora
                    url = base + '/registros/'+sel.id+'/amasadoras/'+sel.amaIndex;
                } else {
                    url = base + '/registros/'+sel.id;
                }
                const r = await fetch(url,{ method:'DELETE', headers: apiHeaders(false) });
                if(!r.ok) throw new Error('HTTP '+r.status);
                ok++;
            }catch(_){ fail++; }
        }
        status.textContent = `Eliminación múltiple: OK ${ok}, Fallidos ${fail}`; status.className='text-xs '+(fail? 'text-amber-600':'text-green-600')+' text-center';
        __BD_SELECTED=[]; updateBDSelectedUI(); loadBDView();
    });

    // --------- FRONTEND DEDUPE (FIRMAS ENVIADAS) ---------
    const __ENVIADAS_KEY = 'ENVIADAS_BD';
    function __loadSent(){ try { return JSON.parse(localStorage.getItem(__ENVIADAS_KEY)||'{}'); } catch(_){ return {}; } }
    let __ENVIADAS_MAP = __loadSent();
    function __saveSent(){ try { localStorage.setItem(__ENVIADAS_KEY, JSON.stringify(__ENVIADAS_MAP)); }catch(_){ } }
    function __sig(fecha, m){
        try {
            const tipo = (m?.tipoMasa||m?.tipoPan||'').toString().trim().toLowerCase();
            const nombre = (m?.nombre||m?.id||'').toString().trim().toLowerCase();
            const p1Start = m?.proceso1?.startTime || (Array.isArray(m?.procesos)? m.procesos[0]?.startTime: '') || '';
            return [fecha||'', nombre, tipo, p1Start||''].join('__');
        }catch(_){ return fecha+'__err'; }
    }
    function __wasSent(sig){ return !!__ENVIADAS_MAP[sig]; }
    function __markSent(sig){ __ENVIADAS_MAP[sig]=Date.now(); __saveSent(); }
    // (Opcional) limpiar entradas muy antiguas >30 días para no crecer indefinidamente
    (function(){
        const THIRTY = 30*24*3600*1000; const now=Date.now(); let changed=false;
        for(const k in __ENVIADAS_MAP){ if(now - (__ENVIADAS_MAP[k]||0) > THIRTY){ delete __ENVIADAS_MAP[k]; changed=true; } }
        if(changed) __saveSent();
    })();

    // Cierre del modal JSON
    document.getElementById('json-modal-close')?.addEventListener('click', ()=>{
        const modal=document.getElementById('json-modal'); if(!modal) return; modal.classList.add('hidden'); modal.classList.remove('flex');
    });
    document.getElementById('json-modal')?.addEventListener('click', (e)=>{
        if(e.target.id==='json-modal'){
            const modal=document.getElementById('json-modal'); if(!modal) return; modal.classList.add('hidden'); modal.classList.remove('flex');
        }
    });

    // Cambio de fuente de datos en Tablas
    document.getElementById('tablas-source')?.addEventListener('change', function(){
        localStorage.setItem('TABLAS_SOURCE', this.value);
        const btnPdf=document.getElementById('tablas-export-pdf');
        const btnCsv=document.getElementById('tablas-export-csv');
        if(btnPdf) btnPdf.textContent = `Exportar (${this.value==='bd'?'BD':'Locales'}) PDF`;
        if(btnCsv) btnCsv.textContent = `Exportar (${this.value==='bd'?'BD':'Locales'}) CSV`;
        buildTablasVista();
    });
    // Filtros BD para Tablas
    const bdDesdeEl = document.getElementById('tablas-bd-desde');
    const bdHastaEl = document.getElementById('tablas-bd-hasta');
    const bdLoteEl = document.getElementById('tablas-bd-lote');
    const bdTipoEl = document.getElementById('tablas-bd-tipo');
    function persistFilters(){
        if(bdDesdeEl) localStorage.setItem('TABLAS_BD_DESDE', bdDesdeEl.value||'');
        if(bdHastaEl) localStorage.setItem('TABLAS_BD_HASTA', bdHastaEl.value||'');
        if(bdLoteEl) localStorage.setItem('TABLAS_BD_LOTE', bdLoteEl.value||'');
        if(bdTipoEl) localStorage.setItem('TABLAS_BD_TIPO', bdTipoEl.value||'');
    }
    [bdDesdeEl, bdHastaEl, bdLoteEl, bdTipoEl].forEach(el=> el?.addEventListener('change', ()=>{ persistFilters(); buildTablasVista(); }));
    document.getElementById('tablas-bd-clear')?.addEventListener('click', function(){
        if(bdDesdeEl) bdDesdeEl.value=''; if(bdHastaEl) bdHastaEl.value=''; if(bdLoteEl) bdLoteEl.value=''; if(bdTipoEl) bdTipoEl.value='';
        ['TABLAS_BD_DESDE','TABLAS_BD_HASTA','TABLAS_BD_LOTE','TABLAS_BD_TIPO'].forEach(k=> localStorage.removeItem(k));
        buildTablasVista();
    });

    // Copiar JSON del modal
    document.getElementById('json-modal-copy')?.addEventListener('click', async function(){
        const pre = document.getElementById('json-modal-content');
        const btn = this;
        const text = pre?.textContent || '';
        try{
            if(navigator.clipboard?.writeText){ await navigator.clipboard.writeText(text); }
            else { const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); }
            const prev=btn.textContent; btn.textContent='Copiado'; setTimeout(()=>btn.textContent=prev,1200);
        }catch(_){ const prev=btn.textContent; btn.textContent='Error'; setTimeout(()=>btn.textContent=prev,1200); }
    });
    // Exportar CSV
    document.getElementById('btn-exportar-csv')?.addEventListener('click', function() {
        let resultados = JSON.parse(localStorage.getItem('resultadosMezclado') || '[]');
        let rows = [];
        let sumaTiemposMuertos = 0;
        let sumaTotalGeneral = 0;
        // Utilidad para limpiar caracteres raros
        function limpiarTexto(txt) {
            if (!txt) return '';
            // Eliminar caracteres no imprimibles, tildes, símbolos y todo lo no ASCII
            return String(txt)
                .replace(/[\uFFFD\uFEFF\u200B\u00A0]/g, '') // invisibles
                .replace(/[±]/g, '+/-')
                .replace(/[°]/g, ' deg')
                .replace(/[ÁÀÂÃÄáàâãä]/g, 'a')
                .replace(/[ÉÈÊËéèêë]/g, 'e')
                .replace(/[ÍÌÎÏíìîï]/g, 'i')
                .replace(/[ÓÒÔÕÖóòôõö]/g, 'o')
                .replace(/[ÚÙÛÜúùûü]/g, 'u')
                .replace(/[Ññ]/g, 'n')
                .replace(/[^A-Za-z0-9 %.,;:_\-\(\)\[\]\{\}/\\+\/=<>\?\!\|\'\"]+/g, '') // solo ASCII seguro
                .normalize('NFC');
        }
        resultados.forEach(res => {
            const fecha = limpiarTexto(res.fecha || '');
            (res.maquinas||[]).forEach(maq => {
                let totalSegundos = 0;
                let firstRow = true;
                // Calcular tiempos muertos entre procesos
                let tiempoMuerto1 = '';
                let tiempoMuerto2 = '';
                if (maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime) {
                    tiempoMuerto1 = Math.max(0, Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000));
                }
                if (maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime) {
                    tiempoMuerto2 = Math.max(0, Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000));
                }
                let totalMuertos = (tiempoMuerto1 || 0) + (tiempoMuerto2 || 0);
                sumaTiemposMuertos += totalMuertos;
                for (let i=1; i<=3; i++) {
                    const proc = maq[`proceso${i}`] || {};
                    const t = (parseInt(proc.minutos)||0)*60 + (parseInt(proc.segundos)||0);
                    totalSegundos += t;
                    // Día de la semana limpio
                    let diaSemana = '';
                    if (firstRow && fecha && fecha.length===10) {
                        const dias = ['Domingo','Lunes','Martes','Miércoles','Jueves','Viernes','Sábado'];
                        const [anio, mes, dia] = fecha.split('-').map(Number);
                        const fechaLocal = new Date(anio, mes - 1, dia);
                        diaSemana = dias[fechaLocal.getDay()];
                        diaSemana = limpiarTexto(diaSemana);
                    }
                    rows.push({
                        Fecha: firstRow ? fecha : '',
                        Dia: firstRow ? diaSemana : '',
                        Maquina: firstRow ? limpiarTexto(maq.nombre||maq.id||'') : '',
                        TipoMasa: firstRow ? limpiarTexto(maq.tipoMasa||maq.tipoPan||'') : '',
                        Hielo: firstRow ? limpiarTexto(maq.hielo||'') : '',
                        'TA': firstRow ? limpiarTexto(maq.tempAmbiente||'') : '',
                        'H': firstRow ? limpiarTexto(maq.humedad||'') : '',
                        'TM': firstRow ? limpiarTexto(maq.tempMasa||'') : '',
                        PersonalMin: firstRow ? limpiarTexto(maq.personalMin||'') : '',
                        PersonalMax: firstRow ? limpiarTexto(maq.personalMax||'') : '',
                        Proceso: ['Esponja','Masa','Mantequilla'][i-1],
                        Minutos: proc.minutos||0,
                        Segundos: proc.segundos||0,
                        Inicio: proc.startTime ? new Date(proc.startTime).toLocaleTimeString() : '',
                        Fin: proc.endTime ? new Date(proc.endTime).toLocaleTimeString() : '',
                        SegT: '',
                        TM1: firstRow ? tiempoMuerto1 : '',
                        TM2: firstRow ? tiempoMuerto2 : '',
                        'TTot (s)': firstRow ? (totalSegundos + totalMuertos) : '',
                        'TTot (m)': firstRow ? ((totalSegundos + totalMuertos) ? formatTime(totalSegundos + totalMuertos) : '') : '',
                        Obs: firstRow ? limpiarTexto(maq.observaciones||'') : ''
                    });
                    firstRow = false;
                }
                // Agregar fila de total
                sumaTotalGeneral += totalSegundos + totalMuertos;
                rows.push({
                    Fecha: '',
                    Dia: '',
                    Maquina: '',
                    TipoMasa: '',
                    Hielo: '',
                    'TA': '',
                    'H': '',
                    'TM': '',
                    Proceso: 'TOTAL',
                    Minutos: Math.floor(totalSegundos/60),
                    Segundos: totalSegundos%60,
                    Inicio: '',
                    Fin: '',
                    SegT: totalSegundos,
                    TM1: tiempoMuerto1,
                    TM2: tiempoMuerto2,
                    TMTot: totalMuertos,
                    TTot: totalSegundos + totalMuertos,
                    Obs: ''
                });
            });
        });
        // Agregar bloque resumen de tiempos muertos y total general
        rows.push({});
        rows.push({Pro: 'RESUMEN TIEMPOS MUERTOS'});
        rows.push({Pro: 'Suma total de tiempos muertos (s)', Valor: sumaTiemposMuertos});
        rows.push({Pro: 'Suma total general (incluye tiempos muertos) (s)', Valor: sumaTotalGeneral});
        // Utilidades
        function stddev(arr) {
            if (!arr.length) return 0;
            const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
            return Math.sqrt(arr.reduce((a,b)=>a+Math.pow(b-mean,2),0)/arr.length);
        }
        function relStddev(std, mean) {
            if (!mean) return '0%';
            return ((std/mean)*100).toFixed(1) + '%';
        }
    // Promedios por tipo de masa (tiempo)
        let panStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const tipo = maq.tipoMasa || maq.tipoPan || 'Sin especificar';
                let total = 0;
                for (let i=1; i<=3; i++) {
                    const proc = maq[`proceso${i}`];
                    if (proc) total += (parseInt(proc.minutos)||0)*60 + (parseInt(proc.segundos)||0);
                }
                if (!panStats[tipo]) panStats[tipo] = [];
                panStats[tipo].push(total);
            });
        });
        rows.push({});
        rows.push({TipoMasa: 'Promedios por tipo de masa (tiempo)', Minutos: 'Promedio', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({TipoMasa: 'Promedios por tipo de masa (tiempo)', Minutos: 'Promedio (s)', Segundos: '+/-Desv (s)', Inicio: '%Desv'});
        for (const tipo in panStats) {
            const arr = panStats[tipo];
            if (!arr.length) continue;
            const prom = Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
            const std = Math.round(stddev(arr));
            const rel = relStddev(std, prom);
            rows.push({TipoMasa: tipo, Minutos: prom, Segundos: std, Inicio: rel});
        }

        // Promedios por amasadora (tiempo)
        let amasadoraStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const amNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.nombreMaquina||'').match(/\d+/)?.[0]);
                const amasadora = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                let total = 0;
                for (let i=1; i<=3; i++) {
                    const proc = maq[`proceso${i}`];
                    if (proc) total += (parseInt(proc.minutos)||0)*60 + (parseInt(proc.segundos)||0);
                }
                if (!amasadoraStats[amasadora]) amasadoraStats[amasadora] = [];
                amasadoraStats[amasadora].push(total);
            });
        });
        rows.push({});
        rows.push({Maquina: 'Promedios por amasadora (tiempo)', Minutos: 'Promedio', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({Maquina: 'Promedios por amasadora (tiempo)', Minutos: 'Promedio (s)', Segundos: '+/-Desv (s)', Inicio: '%Desv'});
        for (const amasadora in amasadoraStats) {
            const arr = amasadoraStats[amasadora];
            if (!arr.length) continue;
            const prom = Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
            const std = Math.round(stddev(arr));
            const rel = relStddev(std, prom);
            rows.push({Maquina: amasadora, Minutos: prom, Segundos: std, Inicio: rel});
        }

        // Temperatura por amasadora
        let tempAmasadoraStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const amNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.nombreMaquina||'').match(/\d+/)?.[0]);
                const amasadora = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                const temp = parseFloat(maq.tempMasa);
                if (!isNaN(temp)) {
                    if (!tempAmasadoraStats[amasadora]) tempAmasadoraStats[amasadora] = [];
                    tempAmasadoraStats[amasadora].push(temp);
                }
            });
        });
        rows.push({});
        rows.push({Maquina: 'Temperatura de masa por amasadora', Minutos: 'Promedio (°C)', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({Maquina: 'Temperatura de masa por amasadora', Minutos: 'Promedio (grados C)', Segundos: '+/-Desv (grados C)', Inicio: '%Desv'});
        for (const amasadora in tempAmasadoraStats) {
            const arr = tempAmasadoraStats[amasadora];
            if (!arr.length) continue;
            const prom = arr.reduce((a,b)=>a+b,0)/arr.length;
            const std = stddev(arr);
            const rel = relStddev(std, prom);
            rows.push({Maquina: amasadora, Minutos: prom.toFixed(1), Segundos: std.toFixed(1), Inicio: rel});
        }

    // Temperatura por tipo de masa
        let tempPanStats = {};
        resultados.forEach(res => {
            (res.maquinas||[]).forEach(maq => {
                const tipo = maq.tipoMasa || maq.tipoPan || 'Sin especificar';
                const temp = parseFloat(maq.tempMasa);
                if (!isNaN(temp)) {
                    if (!tempPanStats[tipo]) tempPanStats[tipo] = [];
                    tempPanStats[tipo].push(temp);
                }
            });
        });
        rows.push({});
        rows.push({TipoMasa: 'Temperatura de masa por tipo de masa', Minutos: 'Promedio (°C)', Segundos: '±Desv', Inicio: '%Desv'});
    rows.push({TipoMasa: 'Temperatura de masa por tipo de masa', Minutos: 'Promedio (grados C)', Segundos: '+/-Desv (grados C)', Inicio: '%Desv'});
        for (const tipo in tempPanStats) {
            const arr = tempPanStats[tipo];
            if (!arr.length) continue;
            const prom = arr.reduce((a,b)=>a+b,0)/arr.length;
            const std = stddev(arr);
            const rel = relStddev(std, prom);
            rows.push({TipoMasa: tipo, Minutos: prom.toFixed(1), Segundos: std.toFixed(1), Inicio: rel});
        }

    // Tabla cruzada: amasadora vs tipo de masa (temperatura)
        let tempAmasadoraLabels = Object.keys(tempAmasadoraStats);
        let tempPanLabels = Object.keys(tempPanStats);
        rows.push({});
    let cruzadaHeader = {Maquina: 'Temp. masa por amasadora y tipo de masa'};
        tempPanLabels.forEach(tipo => cruzadaHeader[tipo] = tipo);
        rows.push(cruzadaHeader);
        tempAmasadoraLabels.forEach(amasadora => {
            let row = {Maquina: amasadora};
            tempPanLabels.forEach(tipo => {
                let arr = [];
                resultados.forEach(res => {
                    (res.maquinas||[]).forEach(maq => {
                        const amNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.nombreMaquina||'').match(/\d+/)?.[0]);
                        const amaKey = (amNumRaw && ['1','2','3'].includes(String(amNumRaw))) ? String(amNumRaw) : '?';
                        if (amaKey === amasadora && ((maq.tipoMasa||maq.tipoPan)||'Sin especificar') === tipo) {
                            const temp = parseFloat(maq.tempMasa);
                            if (!isNaN(temp)) arr.push(temp);
                        }
                    });
                });
                row[tipo] = arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(1) : '';
            });
            rows.push(row);
        });

    // (Tabla cruzada tipo de masa vs amasadora eliminada)
        // Ordenar columnas para que Obs quede al extremo derecho despues de SegundosTotales
        if (rows.length > 0) {
            let cols = Object.keys(rows[0]);
            // Quitar Obs y TTot si existen
            const idxObs = cols.indexOf('Obs');
            if (idxObs !== -1) cols.splice(idxObs, 1);
            // Quitar TTot (s) y TTot (m) si existen
            const idxTTotS = cols.indexOf('TTot (s)');
            if (idxTTotS !== -1) cols.splice(idxTTotS, 1);
            const idxTTotM = cols.indexOf('TTot (m)');
            if (idxTTotM !== -1) cols.splice(idxTTotM, 1);
            // Mover Personal antes de Proceso
            const idxPersonal = cols.indexOf('Personal');
            if (idxPersonal !== -1) cols.splice(idxPersonal, 1);
            const idxProceso = cols.indexOf('Proceso');
            if (idxProceso !== -1) cols.splice(idxProceso, 0, 'Personal');
            // Insertar TTot (s) y TTot (m) antes de Obs
            cols.push('TTot (s)');
            cols.push('TTot (m)');
            cols.push('Obs');
            // Limpiar todos los encabezados y valores
            cols = cols.map(c => limpiarTexto(c));
            rows = rows.map(r => {
                const nuevo = {};
                cols.forEach(c => {
                    // Buscar la clave original (sin limpiar) que corresponde a este encabezado limpio
                    let claveOriginal = Object.keys(r).find(k => limpiarTexto(k) === c);
                    nuevo[c] = limpiarTexto(claveOriginal ? r[claveOriginal] : '');
                });
                return nuevo;
            });
        }
        const csv = Papa.unparse(rows);
        const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
        saveAs(blob, 'resultados_mezclado.csv');
    });
    }

    // Si necesitas cargar resultados de amasadoras automáticamente al iniciar:
    document.addEventListener('DOMContentLoaded', function() {
        // Migración de datos legacy: copiar tipoPan -> tipoMasa si falta
        try {
            let legacy = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            let mod=false;
            legacy.forEach(r=> (r.maquinas||[]).forEach(m=>{ if(!m.tipoMasa && m.tipoPan){ m.tipoMasa = m.tipoPan; mod=true; } }));
            if(mod) localStorage.setItem('resultadosMezclado', JSON.stringify(legacy));
        } catch(_){}
    const viewMain = document.getElementById('view-main-menu');
    const viewMedicion = document.getElementById('view-medicion');
        const viewResultados = document.getElementById('view-resultados');
        const viewTablas = document.getElementById('view-tablas');
    const sectionAmas = document.getElementById('section-amasadoras');
    const sectionFerm = document.getElementById('section-fermentadora');
    const sectionHornos = document.getElementById('section-hornos');
    const tabMainMenu = document.getElementById('tab-main-menu');
    const tabMainAmas = document.getElementById('tab-main-amasadoras');
    const tabMainFerm = document.getElementById('tab-main-fermentadora');
    const tabMainHornos = document.getElementById('tab-main-hornos');
        const tabMedicion = document.getElementById('tab-medicion');
        const tabResultados = document.getElementById('tab-resultados');
        const tabTablas = document.getElementById('tab-tablas');

        // Estado inicial
        // Initial: show Menu and ensure sub-vistas de Amasadoras no se "cuelen"
        if (viewMain) viewMain.classList.remove('hidden');
        if (sectionAmas) sectionAmas.classList.add('hidden');
        // Asegurar todo oculto por defecto fuera de Amasadoras
        viewMedicion?.classList.add('hidden');
        viewResultados?.classList.add('hidden');
        viewTablas?.classList.add('hidden');
        sectionFerm?.classList.add('hidden');
        sectionHornos?.classList.add('hidden');

        function hideAmasadorasSubviews(){
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.add('hidden');
            tabMedicion?.classList.remove('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
        }

        function showMedicionDefault(){
            // Mostrar Medición como subpestaña por defecto
            viewMedicion?.classList.remove('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.add('hidden');
            tabMedicion?.classList.add('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
        }

        function activateMainTab(which){
            // Reset classes
            [tabMainMenu, tabMainAmas, tabMainFerm, tabMainHornos].forEach(b=> b?.classList.remove('tab-btn-active'));
            // Hide all main sections by default
            viewMain?.classList.add('hidden');
            sectionAmas?.classList.add('hidden');
            // Siempre ocultar sub-vistas de Amasadoras cuando cambiamos de módulo
            hideAmasadorasSubviews();
            // Ocultar placeholders
            sectionFerm?.classList.add('hidden');
            sectionHornos?.classList.add('hidden');

            if(which==='menu'){
                tabMainMenu?.classList.add('tab-btn-active');
                viewMain?.classList.remove('hidden');
                return;
            }
            if(which==='amas'){
                tabMainAmas?.classList.add('tab-btn-active');
                sectionAmas?.classList.remove('hidden');
                showMedicionDefault();
                return;
            }
            if(which==='ferm'){
                tabMainFerm?.classList.add('tab-btn-active');
                // Mostrar sólo la sección de Fermentadora (top-level)
                sectionFerm?.classList.remove('hidden');
                return;
            }
            if(which==='horn'){
                tabMainHornos?.classList.add('tab-btn-active');
                // Mostrar sólo la sección de Hornos (top-level)
                sectionHornos?.classList.remove('hidden');
                return;
            }
        }
        tabMainMenu?.addEventListener('click', ()=> activateMainTab('menu'));
        tabMainAmas?.addEventListener('click', ()=> activateMainTab('amas'));
        tabMainFerm?.addEventListener('click', ()=> activateMainTab('ferm'));
        tabMainHornos?.addEventListener('click', ()=> activateMainTab('horn'));
        // Force start on Menu to avoid Amasadoras content appearing under Menu
        activateMainTab('menu');

        // Settings bindings
        const settingsApiUrl = document.getElementById('settings-api-url');
        const settingsSaveApi = document.getElementById('settings-save-api');
    const settingsApiKey = document.getElementById('settings-api-key');
    const settingsRememberKey = document.getElementById('settings-remember-key');
    const settingsSaveKey = document.getElementById('settings-save-key');
        if(settingsApiUrl){ settingsApiUrl.value = localStorage.getItem('API_URL_OVERRIDE')||''; }
        settingsSaveApi?.addEventListener('click', ()=>{
            const v = (settingsApiUrl?.value||'').trim();
            if(v){ localStorage.setItem('API_URL_OVERRIDE', v); mostrarToast('URL API guardada'); }
            else { localStorage.removeItem('API_URL_OVERRIDE'); mostrarToast('URL API borrada'); }
        });
        settingsSaveKey?.addEventListener('click', async ()=>{
            const k = settingsApiKey?.value||'';
            const remember = !!settingsRememberKey?.checked;
            const statusEl = document.getElementById('settings-key-status');
            if(statusEl) statusEl.textContent='';
            if(k){ sessionStorage.setItem('API_KEY', k); if(remember) localStorage.setItem('API_KEY_PERSIST', k); else localStorage.removeItem('API_KEY_PERSIST'); mostrarToast('Clave API guardada'); }
            else { sessionStorage.removeItem('API_KEY'); localStorage.removeItem('API_KEY_PERSIST'); mostrarToast('Clave API borrada'); }
            try{
                const base=resolveApiBase();
                const r=await fetch(base + '/registros?limit=1',{ headers: apiHeaders(false) });
                if(r.ok){ if(statusEl){statusEl.textContent='Clave verificada ✅'; statusEl.className='mt-2 text-sm text-emerald-700';} }
                else { const msg = (r.status===401||r.status===403)?'Clave inválida ❌':'Error: HTTP '+r.status; if(statusEl){statusEl.textContent=msg; statusEl.className='mt-2 text-sm text-red-600';} }
            }catch(e){ if(statusEl){ statusEl.textContent='Error de red al verificar clave'; statusEl.className='mt-2 text-sm text-red-600'; } }
        });
        // Toggle mostrar/ocultar API key
        const toggleBtn = document.getElementById('settings-api-toggle');
        if(toggleBtn && settingsApiKey){
            toggleBtn.addEventListener('click', ()=>{
                const isPwd = settingsApiKey.type === 'password';
                settingsApiKey.type = isPwd ? 'text' : 'password';
                toggleBtn.textContent = isPwd ? 'Ocultar' : 'Mostrar';
            });
        }
        if (typeof createMachineCards === 'function') createMachineCards();

        // Listeners de pestañas seguros
        if (tabMedicion) tabMedicion.addEventListener('click', () => {
            sectionAmas?.classList.remove('hidden');
            if (!viewMedicion) return;
            viewMedicion.classList.remove('hidden');
            viewResultados.classList.add('hidden');
            viewTablas.classList.add('hidden');
            tabMedicion.classList.add('tab-btn-active');
            tabResultados.classList.remove('tab-btn-active');
            tabTablas.classList.remove('tab-btn-active');
            try{ document.getElementById('section-amasadoras')?.scrollIntoView({behavior:'smooth', block:'start'});}catch(_){ }
            if (typeof createMachineCards === 'function') createMachineCards();
        });
        if (tabResultados) tabResultados.addEventListener('click', () => {
            sectionAmas?.classList.remove('hidden');
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.remove('hidden');
            viewTablas?.classList.add('hidden');
            tabResultados.classList.add('tab-btn-active');
            tabMedicion?.classList.remove('tab-btn-active');
            tabTablas?.classList.remove('tab-btn-active');
            try{ document.getElementById('view-resultados')?.scrollIntoView({behavior:'smooth', block:'start'});}catch(_){ }
            if (typeof cargarResultados === 'function') cargarResultados();
        });
        if (tabTablas) tabTablas.addEventListener('click', () => {
            sectionAmas?.classList.remove('hidden');
            viewMedicion?.classList.add('hidden');
            viewResultados?.classList.add('hidden');
            viewTablas?.classList.remove('hidden');
            tabTablas.classList.add('tab-btn-active');
            tabMedicion?.classList.remove('tab-btn-active');
            tabResultados?.classList.remove('tab-btn-active');
            try{ document.getElementById('view-tablas')?.scrollIntoView({behavior:'smooth', block:'start'});}catch(_){ }
            if (typeof buildTablasVista === 'function') buildTablasVista();
        });
    });

    // ================= TABLAS Y GRAFICOS =================
    let chartsCache = [];
    function destroyCharts(){ chartsCache.forEach(c=>{try{c.destroy();}catch(_){}}); chartsCache=[]; }
    function fmt(n){return typeof n==='number'&&!isNaN(n)?n:0;}
    function std(arr){ if(!arr.length) return 0; const m=arr.reduce((a,b)=>a+b,0)/arr.length; return Math.sqrt(arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length);} 
    function percent(a,b){ return b? (a*100/b).toFixed(1)+'%':'0%'; }
    function tableFromRows(headers, rows){
        return `<table class='min-w-full border border-stone-300 text-xs md:text-sm bg-white rounded-lg overflow-hidden'><thead class='bg-stone-100 text-stone-700'><tr>${headers.map(h=>`<th class='px-3 py-2 border-b border-stone-300 text-left font-semibold'>${h}</th>`).join('')}</tr></thead><tbody>${rows.map((r,i)=>`<tr class='${i%2?'bg-stone-50':''}'>${r.map(c=>`<td class='px-3 py-1 border-b border-stone-200 font-mono'>${c}</td>`).join('')}</tr>`).join('')}</tbody></table>`;
    }
    let _TABLAS_DATA_LAST = [];
    function getTablasData(){ return _TABLAS_DATA_LAST; }
    async function buildTablasVista(){
        destroyCharts();
        const fuenteSel = document.getElementById('tablas-source');
        const statusEl = document.getElementById('tablas-status');
        const bdCtrls = document.getElementById('tablas-bd-controls');
        const desdeInput = document.getElementById('tablas-bd-desde');
        const hastaInput = document.getElementById('tablas-bd-hasta');
        const loteInput = document.getElementById('tablas-bd-lote');
        const tipoInput = document.getElementById('tablas-bd-tipo');
        let fuente = (localStorage.getItem('TABLAS_SOURCE')||'local');
        if(fuenteSel){
            if(!fuenteSel.value) fuenteSel.value = fuente; else fuente = fuenteSel.value;
        }
        localStorage.setItem('TABLAS_SOURCE', fuente);
    if(bdCtrls){ bdCtrls.classList.toggle('hidden', fuente !== 'bd'); }
    // Ajustar etiquetas de export segun fuente
    const btnPdf=document.getElementById('tablas-export-pdf');
    const btnCsv=document.getElementById('tablas-export-csv');
    if(btnPdf) btnPdf.textContent = `Exportar (${fuente==='bd'?'BD':'Locales'}) PDF`;
    if(btnCsv) btnCsv.textContent = `Exportar (${fuente==='bd'?'BD':'Locales'}) CSV`;
    // Leer filtros persistidos
    let fDesde = localStorage.getItem('TABLAS_BD_DESDE')||'';
    let fHasta = localStorage.getItem('TABLAS_BD_HASTA')||'';
    let fLote = localStorage.getItem('TABLAS_BD_LOTE')||'';
    let fTipo = localStorage.getItem('TABLAS_BD_TIPO')||'';
    if(desdeInput){ if(!desdeInput.value && fDesde) desdeInput.value=fDesde; else fDesde=desdeInput.value||''; }
    if(hastaInput){ if(!hastaInput.value && fHasta) hastaInput.value=fHasta; else fHasta=hastaInput.value||''; }
    if(loteInput){ if(!loteInput.value && fLote) loteInput.value=fLote; else fLote=loteInput.value||''; }
    if(tipoInput){ if(!tipoInput.value && fTipo) tipoInput.value=fTipo; else fTipo=tipoInput.value||''; }
        let datos = [];
        if(statusEl) statusEl.textContent = '';
        if(fuente === 'local'){
            try { datos = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]') || []; } catch(_) { datos = []; }
            if(statusEl) statusEl.textContent = `Fuente: Locales · ${datos.length} registros.`;
        } else {
            const base = resolveApiBase();
            if(statusEl) statusEl.textContent = 'Cargando datos de la BD...';
            try{
                // Prefer server-side filters when available: desde/hasta
                let q = [];
                if(fDesde) q.push('desde='+encodeURIComponent(fDesde));
                if(fHasta) q.push('hasta='+encodeURIComponent(fHasta));
                const url = base + '/registros' + (q.length? ('?'+q.join('&')) : '');
                const r = await fetch(url, { headers: apiHeaders(false) });
                if(!r.ok) throw new Error('HTTP '+r.status);
                const arr = await r.json();
                const total = Array.isArray(arr)? arr.length: 0;
                let arrFiltrado = Array.isArray(arr)? arr: [];
                    // Mantener filtros extra en cliente (lote/tipo) y como respaldo si API no filtra fecha
                    if(fDesde){ arrFiltrado = arrFiltrado.filter(it=> (it.data?.fecha||it.fecha||'') >= fDesde); }
                    if(fHasta){ arrFiltrado = arrFiltrado.filter(it=> (it.data?.fecha||it.fecha||'') <= fHasta); }
                if(fLote){ arrFiltrado = arrFiltrado.filter(it=> (it.data?.amasadoras||[]).some(m=> (m.lote||'').toString().includes(fLote))); }
                if(fTipo){ const fx=fTipo.toLowerCase(); arrFiltrado = arrFiltrado.filter(it=> (it.data?.amasadoras||[]).some(m=> ((m.tipoMasa||m.tipoPan||'').toLowerCase().includes(fx)))); }
                // Normalizar cada amasadora: si viene como 'procesos'[] mapear a proceso1..3
                function normalizeMaq(m){
                    if(!m) return m;
                    const n = { ...m };
                    if(Array.isArray(m.procesos) && (!m.proceso1 || !m.proceso2 || !m.proceso3)){
                        const p1 = m.procesos.find(p=> String(p.id)==='1');
                        const p2 = m.procesos.find(p=> String(p.id)==='2');
                        const p3 = m.procesos.find(p=> String(p.id)==='3');
                        const mk = (p)=> p? ({
                            minutos: parseInt(p.minutos)||0,
                            segundos: parseInt(p.segundos)||0,
                            startTime: p.startTime||null,
                            endTime: p.endTime||null
                        }): undefined;
                        if(p1) n.proceso1 = mk(p1);
                        if(p2) n.proceso2 = mk(p2);
                        if(p3) n.proceso3 = mk(p3);
                    }
                    return n;
                }
                datos = (arrFiltrado||[]).map(it=>({
                    fecha: it.data?.fecha || it.fecha,
                    maquinas: Array.isArray(it.data?.amasadoras)? it.data.amasadoras.map(normalizeMaq) : []
                }));
                const filtrosAct = [fDesde?`Desde ${fDesde}`:'', fHasta?`Hasta ${fHasta}`:'', fLote?`Lote ${fLote}`:'', fTipo?`Tipo ${fTipo}`:''].filter(Boolean).join(' · ');
                if(statusEl) statusEl.textContent = `Fuente: BD · ${datos.length} registros${filtrosAct?` (filtros: ${filtrosAct})`:''}. Total disponibles: ${total}.`;
            }catch(e){
                const msg = 'Error cargando BD: ' + (e.message||e);
                if(statusEl) statusEl.textContent = msg;
                ['tabla-resumen','tabla-pan','tabla-amasadora','tabla-proceso','tabla-temp','tabla-temp-cruzada','tabla-personal-dia','tabla-ta-h-dia'].forEach(id=>{const el=document.getElementById(id); if(el) el.innerHTML='<div class="text-red-600">'+msg+'</div>';});
                return;
            }
        }
    // Aplicar filtro día si está activado (para que tablas y gráficas reflejen la selección de la lista de fechas)
    const _modoFechaSel = localStorage.getItem('TABLAS_FECHA_MODO');
    const _diaSel = localStorage.getItem('TABLAS_BD_DIA');
    let datosParaMostrar = datos;
    if(_modoFechaSel==='dia' && _diaSel){ datosParaMostrar = datos.filter(r=> r.fecha === _diaSel); }
    _TABLAS_DATA_LAST = datosParaMostrar;
    // Construir lista de fechas (si existe contenedor)
        try{
            const fechasList = document.getElementById('tablas-fechas-list');
            const fechasDetalle = document.getElementById('tablas-fechas-detalle');
            const fechasTotal = document.getElementById('tablas-fechas-total');
            if(fechasList){
                const mapa={};
                datos.forEach(r=>{ if(r.fecha){ mapa[r.fecha] = (mapa[r.fecha]||0) + (r.maquinas? r.maquinas.length:0); } });
                const fechas = Object.keys(mapa).sort();
                fechasList.innerHTML = fechas.map(f=>{
                    const activo = (_modoFechaSel==='dia' && _diaSel===f);
                    return `<button data-fecha="${f}" class="px-3 py-1 text-xs rounded-full border ${activo?'bg-blue-600 text-white border-blue-600 shadow':'border-stone-300 bg-white hover:bg-blue-50 hover:border-blue-400'} transition flex items-center gap-1">${f}<span class='inline-block text-[10px] px-1 rounded ${activo?'bg-white/20 text-white':'bg-stone-200 text-stone-700'}'>${mapa[f]}</span></button>`;
                }).join('');
                if(fechasTotal) fechasTotal.textContent = `(${fechas.length})`;
                // Botón para limpiar filtro de día
                if((_modoFechaSel==='dia' && _diaSel) && !document.getElementById('tablas-fechas-clear')){
                    const clearBtn = document.createElement('button');
                    clearBtn.id='tablas-fechas-clear';
                    clearBtn.className='mt-3 text-[11px] underline text-blue-700';
                    clearBtn.textContent='Quitar filtro de día';
                    clearBtn.addEventListener('click', ()=>{ localStorage.setItem('TABLAS_FECHA_MODO','rango'); localStorage.removeItem('TABLAS_BD_DIA'); buildTablasVista(); });
                    fechasList.parentNode.appendChild(clearBtn);
                } else if(!(_modoFechaSel==='dia' && _diaSel)){
                    const existing=document.getElementById('tablas-fechas-clear'); if(existing) existing.remove();
                }
                fechasList.querySelectorAll('button[data-fecha]').forEach(btn=>{
                    btn.addEventListener('click', ()=>{
                        const f = btn.getAttribute('data-fecha');
                        localStorage.setItem('TABLAS_FECHA_MODO','dia');
                        localStorage.setItem('TABLAS_BD_DIA', f);
                        const modoSelEl=document.getElementById('tablas-fecha-modo'); if(modoSelEl) modoSelEl.value='dia';
                        const diaInputEl=document.getElementById('tablas-dia'); if(diaInputEl) diaInputEl.value=f;
                        buildTablasVista();
                    });
                });
                if(fechasDetalle){
                    const modoActual = localStorage.getItem('TABLAS_FECHA_MODO')||'rango';
                    const fechaDia = localStorage.getItem('TABLAS_BD_DIA')||'';
                    if(modoActual==='dia' && fechaDia){
                        const registrosDia = datos.filter(r=> r.fecha===fechaDia);
                        const totalMaq = registrosDia.reduce((a,r)=> a + (r.maquinas? r.maquinas.length:0), 0);
                        const tipos={}; registrosDia.forEach(r=> (r.maquinas||[]).forEach(m=>{ const t=m.tipoMasa||m.tipoPan||'Sin tipo'; tipos[t]=(tipos[t]||0)+1; }));
                        fechasDetalle.classList.remove('hidden');
                        fechasDetalle.innerHTML = `<div class='p-3 border border-blue-200 bg-blue-50 rounded-lg text-xs'><div class='font-semibold mb-1'>Detalle ${fechaDia}</div><div>Total registros: <strong>${registrosDia.length}</strong> · Total máquinas: <strong>${totalMaq}</strong></div><div class='mt-1 flex flex-wrap gap-2'>${Object.keys(tipos).map(t=>`<span class='px-2 py-0.5 rounded bg-white border border-stone-300'>${t}: ${tipos[t]}</span>`).join('')||'<em>Sin tipos</em>'}</div><button id='tablas-fechas-volver' class='mt-2 text-[11px] underline text-blue-700'>Ver todas las fechas</button></div>`;
                        fechasDetalle.querySelector('#tablas-fechas-volver')?.addEventListener('click', ()=>{
                            localStorage.setItem('TABLAS_FECHA_MODO','rango');
                            localStorage.removeItem('TABLAS_BD_DIA');
                            const modoSelEl2=document.getElementById('tablas-fecha-modo'); if(modoSelEl2) modoSelEl2.value='rango';
                            buildTablasVista();
                        });
                    } else { fechasDetalle.classList.add('hidden'); fechasDetalle.innerHTML=''; }
                }
            }
        }catch(_){ }
        if(!_TABLAS_DATA_LAST.length){
            ['tabla-resumen','tabla-pan','tabla-amasadora','tabla-proceso','tabla-temp','tabla-temp-cruzada','tabla-personal-dia','tabla-ta-h-dia'].forEach(id=>{const el=document.getElementById(id); if(el) el.innerHTML='<div class="text-stone-500">Sin datos</div>';});
            return;
        }
        // Estructuras
        const procesosNombres=['Esponja','Masa','Mantequilla'];
        let totalGenerales=[]; let procesoStats=[[],[],[]];
    let masaStats={}, amasadoraStats={}, tempMasaStats={}, tempCrossRaw=[];
    let globalRealSum=0, globalProdSum=0, globalMuertoSum=0;
    _TABLAS_DATA_LAST.forEach(reg=>{
            (reg.maquinas||[]).forEach(maq=>{
                // total máquina (primer start a último end)
                const p1=maq.proceso1, p3=maq.proceso3;
                if(p1&&p1.startTime && p3 && p3.endTime){
                    const total = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
                    totalGenerales.push(total);
                }
                for(let i=1;i<=3;i++){
                    const p=maq['proceso'+i];
                    if(p){ const t=(parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0); procesoStats[i-1].push(t); }
                }
                const tipo=maq.tipoMasa||maq.tipoPan||'Sin tipo';
                // Normalizar clave de amasadora: usar numeroAmasadora o dígitos de nombre/id; limitar a '1','2','3' o '?' si desconocido
                const amaNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.id||'').match(/\d+/)?.[0]);
                const ama = (amaNumRaw && ['1','2','3'].includes(String(amaNumRaw))) ? String(amaNumRaw) : (amaNumRaw ? String(amaNumRaw) : '?');
                let totalSimple = 0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ totalSimple += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0);} }
                (masaStats[tipo]=masaStats[tipo]||[]).push(totalSimple);
                (amasadoraStats[ama]=amasadoraStats[ama]||[]).push(totalSimple);
                const tm = parseFloat(maq.tempMasa); if(!isNaN(tm)) { (tempMasaStats[tipo]=tempMasaStats[tipo]||[]).push(tm); tempCrossRaw.push({tipo, ama, tm}); }
                if(p1&&p1.startTime && p3 && p3.endTime){
                    const real = Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000));
                    globalRealSum += real;
                    globalProdSum += totalSimple;
                    globalMuertoSum += Math.max(0, real - totalSimple);
                }
            });
        });
        // Resumen tabla
        const resumenHeaders=['Métrica','Valor'];
        const resumenRows=[];
        if(totalGenerales.length){
            const prom=Math.round(totalGenerales.reduce((a,b)=>a+b,0)/totalGenerales.length);
            const desv=Math.round(std(totalGenerales));
            resumenRows.push(['N registros', totalGenerales.length]);
            resumenRows.push(['Promedio total (s)', prom]);
            resumenRows.push(['Desv (s)', desv]);
            resumenRows.push(['%Desv', percent(desv,prom)]);
        }
        procesoStats.forEach((arr,i)=>{
            if(arr.length){
                const prom=Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
                const desv=Math.round(std(arr));
                resumenRows.push([`Prom ${procesosNombres[i]} (s)`, prom]);
                resumenRows.push([`Desv ${procesosNombres[i]} (s)`, desv]);
                resumenRows.push([`%Desv ${procesosNombres[i]}`, percent(desv,prom)]);
            }
        });
        if(globalRealSum>0){
            const tiempoMuerto = globalMuertoSum;
            resumenRows.push(['Tiempo productivo (s)', globalProdSum]);
            resumenRows.push(['Tiempo muerto (s)', tiempoMuerto]);
            resumenRows.push(['%Muerto', percent(tiempoMuerto, globalRealSum)]);
            resumenRows.push(['OEE (%)', percent(globalProdSum, globalRealSum)]);
        }
        const tblResumen=document.getElementById('tabla-resumen'); if(tblResumen) tblResumen.innerHTML=tableFromRows(resumenHeaders,resumenRows);
        // Pan table
    const panHeaders=['Tipo masa','N','Prom (s)','Desv (s)','%Desv'];
    const panRows=Object.keys(masaStats).map(k=>{const a=masaStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        document.getElementById('tabla-pan').innerHTML = tableFromRows(panHeaders, panRows);
        // Amasadora table
    const amaHeaders=['Amasadora','N','Prom (s)','Desv (s)','%Desv'];
    const amaRows=Object.keys(amasadoraStats).map(k=>{const a=amasadoraStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        document.getElementById('tabla-amasadora').innerHTML = tableFromRows(amaHeaders, amaRows);
        // Proceso table
        const procHeaders=['Proceso','N','Prom (s)','Desv (s)','%Desv'];
        const procRows=procesoStats.map((a,i)=> a.length? [procesosNombres[i], a.length, Math.round(a.reduce((x,y)=>x+y,0)/a.length), Math.round(std(a)), percent(Math.round(std(a)), Math.round(a.reduce((x,y)=>x+y,0)/a.length))]: null).filter(Boolean);
        document.getElementById('tabla-proceso').innerHTML = tableFromRows(procHeaders, procRows);
    // Temp masa por tipo de masa
    const tempHeaders=['Tipo masa','N','Prom (°C)','Desv (°C)','%Desv'];
    const tempRows=Object.keys(tempMasaStats).map(k=>{const a=tempMasaStats[k]; const m=a.reduce((x,y)=>x+y,0)/a.length; const d=std(a); return [k,a.length,m.toFixed(1),d.toFixed(1),percent(d,m)];});
        document.getElementById('tabla-temp').innerHTML = tableFromRows(tempHeaders, tempRows);
    // Tabla cruzada temp masa (amasadora vs tipo de masa)
        const tiposOrden = Array.from(new Set(tempCrossRaw.map(r=>r.tipo)));
        const amasOrden = Array.from(new Set(tempCrossRaw.map(r=>r.ama)));
        const cruzHeaders=['Amasadora', ...tiposOrden];
        const cruzRows = amasOrden.map(a=>{
            const c=[a];
            tiposOrden.forEach(t=>{
                const subset = tempCrossRaw.filter(r=>r.ama===a && r.tipo===t).map(r=>r.tm);
                if(subset.length){ const avg = subset.reduce((x,y)=>x+y,0)/subset.length; c.push(avg.toFixed(1)); } else { c.push(''); }
            });
            return c;
        });
        const cruzEl=document.getElementById('tabla-temp-cruzada'); if(cruzEl) cruzEl.innerHTML= tableFromRows(cruzHeaders, cruzRows);

        // Personal por día (mín–máx) agregado por fecha (una fila por día) + gráfico
        (function(){
            const cont = document.getElementById('tabla-personal-dia');
            if(!cont) return;
            const headers = ['Fecha','N máquinas','Personal mín','Personal máx','Midpoint','Rango'];
            const perDay = {}; // fecha -> {n, mins:[], maxs:[]}
            datos.forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const bucket = perDay[fecha] = perDay[fecha] || { n:0, mins:[], maxs:[] };
                bucket.n += (reg.maquinas||[]).length;
                (reg.maquinas||[]).forEach(m=>{
                    const vmin = parseInt(m.personalMin); if(!isNaN(vmin)) bucket.mins.push(vmin);
                    const vmax = parseInt(m.personalMax); if(!isNaN(vmax)) bucket.maxs.push(vmax);
                });
                // fallback con primera máquina si no hubo datos válidos
                if(bucket.mins.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) bucket.mins.push(v); }
                if(bucket.maxs.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) bucket.maxs.push(v); }
            });
            const rows = Object.keys(perDay).map(fecha=>{
                const b = perDay[fecha];
                if(!(b.mins.length||b.maxs.length)) return null;
                const min = b.mins.length? Math.min(...b.mins): '';
                const max = b.maxs.length? Math.max(...b.maxs): '';
                const midpoint = (typeof min==='number' && typeof max==='number')? Math.round((min+max)/2) : '';
                const rango = (typeof min==='number' && typeof max==='number')? (max-min) : '';
                return [fecha, b.n, min, max, midpoint, rango];
            }).filter(Boolean).sort((a,b)=> String(a[0]||'').localeCompare(String(b[0]||'')));
            cont.innerHTML = tableFromRows(headers, rows);
            // Gráfico de barras apiladas: OffsetMin (transparente) + Rango (max-min); midpoint como línea
            const el = document.getElementById('chart-personal-dia'); if(!el) return;
            const labels = rows.map(r=>r[0]);
            const dataMin = rows.map(r=> r[2] ?? 0);
            const dataMax = rows.map(r=> r[3] ?? 0);
            const dataMid = rows.map(r=> r[4] ?? 0);
            const dataRango = rows.map((r,i)=> (dataMax[i] - dataMin[i]));
            if(labels.length){
                const chart = mkChart(el,'bar',{
                    labels,
                    datasets:[
                        {label:'OffsetMin', data:dataMin, backgroundColor:'rgba(0,0,0,0)', stack:'pd', borderWidth:0},
                        {label:'Rango (min→max)', data:dataRango, backgroundColor:'#60a5fa', stack:'pd'}
                    ]
                },{
                    responsive:true,
                    plugins:{
                        legend:{position:'bottom', labels:{ filter:(item)=> item.text !== 'OffsetMin' }},
                        tooltip:{
                            callbacks:{
                                label:(ctx)=>{
                                    if(ctx.dataset.label!=='Rango (min→max)') return null;
                                    const s = ctx.chart.$personalStats?.[ctx.dataIndex];
                                    if(!s) return null;
                                    return [
                                        'Min: '+s.min,
                                        'Midpoint: '+s.mid,
                                        'Max: '+s.max
                                    ];
                                }
                            }
                        }
                    },
                    scales:{y:{beginAtZero:true}}
                });
                // Guardar stats para tooltip y dibujar midpoint
                chart.$personalStats = labels.map((_,i)=>({min:dataMin[i], mid:dataMid[i], max:dataMax[i]}));
                setTimeout(()=>{
                    const ctx = chart.ctx; const yScale = chart.scales.y; const xScale = chart.scales.x;
                    ctx.save(); ctx.fillStyle = '#dc2626';
                    dataMid.forEach((m,i)=>{
                        const x = xScale.getPixelForValue(i);
                        const y = yScale.getPixelForValue(m);
                        ctx.beginPath(); ctx.arc(x, y, 3.5, 0, Math.PI*2); ctx.fill();
                    });
                    ctx.restore();
                }, 60);
            }
        })();

        // TA/H por día (promedios por fecha)
        (function(){
            const cont = document.getElementById('tabla-ta-h-dia'); if(!cont) return;
            const headers=['Fecha','N máquinas','TA prom','H prom'];
            const acc={}; // fecha -> {n, ta:[], h:[]}
            datos.forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const b = acc[fecha] = acc[fecha] || { n:0, ta:[], h:[] };
                const maquinas = reg.maquinas||[]; b.n += maquinas.length;
                maquinas.forEach(m=>{
                    const ta = parseFloat(m.tempAmbiente); if(Number.isFinite(ta)) b.ta.push(ta);
                    const h  = parseFloat(m.humedad); if(Number.isFinite(h)) b.h.push(h);
                });
                // fallback: tomar valores de la primera máquina si listas vacías
                if(b.ta.length===0 && maquinas[0]){ const v=parseFloat(maquinas[0].tempAmbiente); if(Number.isFinite(v)) b.ta.push(v); }
                if(b.h.length===0 &&  maquinas[0]){ const v=parseFloat(maquinas[0].humedad); if(Number.isFinite(v)) b.h.push(v); }
            });
            const rows = Object.keys(acc).map(fecha=>{
                const b=acc[fecha];
                if(!(b.ta.length||b.h.length)) return null;
                const taProm = b.ta.length? (b.ta.reduce((x,y)=>x+y,0)/b.ta.length).toFixed(1): '';
                const hProm  = b.h.length?  (b.h.reduce((x,y)=>x+y,0)/b.h.length).toFixed(1): '';
                return [fecha, b.n, taProm, hProm];
            }).filter(Boolean).sort((a,b)=> String(a[0]).localeCompare(String(b[0])));
            cont.innerHTML = tableFromRows(headers, rows);
        })();

        // Charts
        function mkChart(ctx,type,data,options){ const c=new Chart(ctx,{type,data,options}); chartsCache.push(c); return c; }
        const palette=['#2563eb','#16a34a','#f59e0b','#dc2626','#7c3aed','#0d9488','#d946ef'];
        // Pan chart
        const panCtx=document.getElementById('chart-pan'); if(panCtx){ mkChart(panCtx,'bar',{labels:panRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:panRows.map(r=>r[2]),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }
        // Amasadora chart
        const amaCtx=document.getElementById('chart-amasadora'); if(amaCtx){ mkChart(amaCtx,'bar',{labels:amaRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:amaRows.map(r=>r[2]),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }
        // Proceso chart
        const procCtx=document.getElementById('chart-proceso'); if(procCtx){ mkChart(procCtx,'bar',{labels:procRows.map(r=>r[0]),datasets:[{label:'Prom (s)',data:procRows.map(r=>r[2]),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }
        // Temp chart
        const tempCtx=document.getElementById('chart-temp-pan'); if(tempCtx){ mkChart(tempCtx,'bar',{labels:tempRows.map(r=>r[0]),datasets:[{label:'Temp (°C)',data:tempRows.map(r=>parseFloat(r[2])),backgroundColor:palette}]},{responsive:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true}}}); }

        // ====== Nuevas gráficas analíticas ======
        // 1. Boxplot por tipo de masa (custom sin plugins externos)
        (function(){
            const canvas=document.getElementById('chart-boxplot-tipo'); if(!canvas) return;
            const statsDiv=document.getElementById('boxplot-stats');
            const explicacion=document.getElementById('boxplot-explicacion');
            const grupos={};
            datos.forEach(r=> (r.maquinas||[]).forEach(m=>{ const tipo=m.tipoMasa||m.tipoPan||'Sin tipo'; const s1=m.proceso1?.startTime; const e3=m.proceso3?.endTime; if(s1&&e3){ const total=Math.max(0,Math.floor((e3-s1)/1000)); (grupos[tipo]=grupos[tipo]||[]).push(total);} }));
            let stats=Object.keys(grupos).map(k=>{ const arr=[...grupos[k]].sort((a,b)=>a-b); if(!arr.length) return {tipo:k,n:0}; const q=p=>{const pos=(arr.length-1)*p; const b=Math.floor(pos); const r=pos-b; return r? arr[b]+(arr[b+1]-arr[b])*r:arr[b];}; return {tipo:k,n:arr.length,min:arr[0],q1:q(0.25),med:q(0.5),q3:q(0.75),max:arr[arr.length-1],iqr:q(0.75)-q(0.25)}; });
            stats.sort((a,b)=> (a.med||0)-(b.med||0));
            const labels=stats.map(s=>s.tipo);
            if(explicacion){ explicacion.classList.remove('hidden'); explicacion.textContent='Caja = Q1–Q3; línea roja = mediana; bigotes = min y max; n = registros por tipo; IQR% = (Q3-Q1)/(max-min). Pasa el mouse o toca una caja para ver detalle.'; }
            if(statsDiv){ const headers=['Tipo','n','min','Q1','Med','Q3','max','IQR','IQR%']; const rows=stats.map(s=>{ if(!s.n) return [s.tipo,0,'-','-','-','-','-','-','-']; const span=(s.max-s.min)||1; const pct=((s.iqr)*100/span).toFixed(1)+'%'; return [s.tipo,s.n,s.min,s.q1.toFixed(0),s.med.toFixed(0),s.q3.toFixed(0),s.max,s.iqr.toFixed(0),pct]; }); statsDiv.innerHTML=tableFromRows(headers,rows); }
            const datasetMed=stats.map((s,i)=>({x:i,y:s.med||0}));
            const chart=new Chart(canvas,{ type:'scatter', data:{labels,datasets:[{label:'med',data:datasetMed,pointRadius:0}]}, options:{animation:false,responsive:true,interaction:{mode:'nearest',intersect:false},plugins:{legend:{display:false},tooltip:{padding:8,backgroundColor:'rgba(15,23,42,0.9)',titleFont:{size:12,weight:'bold'},bodyFont:{size:11},callbacks:{title:(items)=>{ const i=items[0].dataIndex; return stats[i]?.tipo||''; },label:(ctx)=>{ const s=stats[ctx.dataIndex]; if(!s||!s.n) return s.tipo+': sin datos'; return `n=${s.n}  min:${s.min}s  Q1:${s.q1.toFixed(0)}s  Med:${s.med.toFixed(0)}s  Q3:${s.q3.toFixed(0)}s  max:${s.max}s  IQR:${s.iqr.toFixed(0)}s`; }}}},scales:{x:{type:'category',labels,offset:true,grid:{display:false}},y:{beginAtZero:true,title:{display:true,text:'Segundos'}}}}, plugins:[
                {id:'drawBoxes',afterDraw(c){ const {ctx,scales:{x,y}}=c; c.$boxRects=[]; stats.forEach((s,i)=>{ if(!s.n) return; const nextCenter=x.getPixelForValue(i+1); const prevCenter=x.getPixelForValue(i-1); const center=x.getPixelForValue(i); const gapRight = (nextCenter ? nextCenter-center : (prevCenter? center-prevCenter:60)); const catWidth = gapRight*2 || 120; const boxW=Math.min(90,Math.max(40,catWidth*0.55)); const yMin=y.getPixelForValue(s.min), yQ1=y.getPixelForValue(s.q1), yMed=y.getPixelForValue(s.med), yQ3=y.getPixelForValue(s.q3), yMax=y.getPixelForValue(s.max); c.$boxRects[i]={x1:center-boxW/2,x2:center+boxW/2,y1:Math.min(yQ1,yQ3),y2:Math.max(yQ1,yQ3),whiskerTop:Math.min(yMin,yMax),whiskerBottom:Math.max(yMin,yMax),center, yMed}; ctx.save(); const hovered=(c.$hoverIndex===i); ctx.strokeStyle=hovered?'#1e40af':'#64748b'; ctx.lineWidth=hovered?1.8:1.2; if(hovered){ ctx.shadowColor='rgba(30,64,175,0.35)'; ctx.shadowBlur=6; }
                    // Bigotes
                    ctx.beginPath(); ctx.moveTo(center,yMin); ctx.lineTo(center,yQ1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center,yQ3); ctx.lineTo(center,yMax); ctx.stroke();
                    // Topes
                    ctx.beginPath(); ctx.moveTo(center-12,yMin); ctx.lineTo(center+12,yMin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(center-12,yMax); ctx.lineTo(center+12,yMax); ctx.stroke();
                    // Caja
                    ctx.fillStyle=hovered?'rgba(59,130,246,0.18)':'rgba(148,163,184,0.22)'; ctx.strokeStyle=hovered?'#1d4ed8':'#94a3b8'; ctx.beginPath(); ctx.rect(center-boxW/2,yQ3,boxW,yQ1-yQ3); ctx.fill(); ctx.stroke();
                    // Mediana
                    ctx.strokeStyle=hovered?'#ef4444':'#dc2626'; ctx.lineWidth=hovered?2.4:2; ctx.beginPath(); ctx.moveTo(center-boxW/2,yMed); ctx.lineTo(center+boxW/2,yMed); ctx.stroke();
                    // Label n
                    ctx.fillStyle='#334155'; ctx.font=hovered?'12px Inter':'10px Inter'; ctx.textAlign='center'; ctx.fillText('n='+s.n, center, yQ3-6);
                    ctx.restore(); }); }
                },
                {id:'boxHover',afterEvent(c,args){ const e=args.event; if(!c.$boxRects||!e) return; if(e.type==='mouseout'){ if(c.$hoverIndex!=null){ c.$hoverIndex=null; c.tooltip.setActiveElements([],{}); c.update('none'); canvas.style.cursor='default'; } return; } if(e.type!=='mousemove'&&e.type!=='click'&&e.type!=='touchmove') return; const {x,y}=e; let foundIndex=null; for(let i=0;i<c.$boxRects.length;i++){ const r=c.$boxRects[i]; if(!r) continue; if(x>=r.x1-4 && x<=r.x2+4 && y>=r.whiskerTop-4 && y<=r.whiskerBottom+4){ foundIndex=i; break; } } if(foundIndex!==c.$hoverIndex){ c.$hoverIndex=foundIndex; if(foundIndex==null){ c.tooltip.setActiveElements([],{}); canvas.style.cursor='default'; } else { c.tooltip.setActiveElements([{datasetIndex:0,index:foundIndex}],{x:c.$boxRects[foundIndex].center,y:c.$boxRects[foundIndex].yMed}); canvas.style.cursor='pointer'; } c.update('none'); } }}
            ]});
            chartsCache.push(chart);
        })();

        // 2. Stacked productivo vs muertos por amasadora
        (function(){
            const el=document.getElementById('chart-stacked-muertos'); if(!el) return;
            const amaMap={};
            datos.forEach(reg=> (reg.maquinas||[]).forEach(maq=>{
                const amaNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.id||'').match(/\d+/)?.[0]);
                const ama = (amaNumRaw && ['1','2','3'].includes(String(amaNumRaw))) ? String(amaNumRaw) : (amaNumRaw ? String(amaNumRaw) : '?');
                let tm1=0,tm2=0; if(maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime) tm1=Math.max(0,Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000));
                if(maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime) tm2=Math.max(0,Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000));
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; let totalProd=0; if(primerStart&&ultimoEnd){ totalProd=Math.max(0,Math.floor((ultimoEnd-primerStart)/1000)) - (tm1+tm2); }
                const rec = amaMap[ama] = amaMap[ama] || {prod:0, muertos:0};
                rec.prod += totalProd; rec.muertos += (tm1+tm2);
            }));
            const labels=Object.keys(amaMap);
            const prod=labels.map(l=>amaMap[l].prod);
            const muertos=labels.map(l=>amaMap[l].muertos);
            const chart = mkChart(el,'bar',{labels,datasets:[
                {label:'Productivo (s)', data:prod, backgroundColor:'#16a34a', stack:'t'},
                {label:'Muertos (s)', data:muertos, backgroundColor:'#dc2626', stack:'t'}
            ]},{responsive:true,plugins:{legend:{position:'bottom'}},
                animation:{onComplete:function(){
                    const c=this; const ctx=c.ctx; ctx.save(); ctx.font='10px Inter'; ctx.textAlign='center'; ctx.fillStyle='#111827';
                    const metaMuertos=c.getDatasetMeta(1); // top segment
                    muertos.forEach((m,i)=>{
                        const total = (prod[i]||0)+(m||0); if(!total) return;
                        const pct = (m*100/total).toFixed(1)+'% TM';
                        const bar = metaMuertos.data[i]; if(!bar) return;
                        const y = bar.y - 4; const x = bar.x; ctx.fillText(pct,x,y);
                    });
                    ctx.restore();
                }},
                scales:{x:{stacked:true}, y:{stacked:true, beginAtZero:true}}});
            chart.$stackVals={prod,muertos};
        })();

        // 3. Scatter temperatura masa vs tiempo total
        (function(){
            const el=document.getElementById('chart-scatter-temp-tiempo'); if(!el) return;
            const puntos=[];
            datos.forEach(reg=> (reg.maquinas||[]).forEach(maq=>{
                const tm=parseFloat(maq.tempMasa); if(isNaN(tm)) return;
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; if(!(primerStart&&ultimoEnd)) return;
                const total=Math.max(0,Math.floor((ultimoEnd-primerStart)/1000));
                puntos.push({x:tm,y:total});
            }));
            // Regresión lineal simple
            if(puntos.length>1){
                const n=puntos.length; let sumX=0,sumY=0,sumXY=0,sumX2=0,sumY2=0; puntos.forEach(p=>{sumX+=p.x; sumY+=p.y; sumXY+=p.x*p.y; sumX2+=p.x*p.x; sumY2+=p.y*p.y;});
                const denom = (n*sumX2 - sumX*sumX);
                let m=0,b=0,r=0; if(denom!==0){ m=(n*sumXY - sumX*sumY)/denom; b=(sumY - m*sumX)/n; const rDen=Math.sqrt((n*sumX2 - sumX*sumX)*(n*sumY2 - sumY*sumY)); if(rDen) r=(n*sumXY - sumX*sumY)/rDen; }
                const xs=puntos.map(p=>p.x); const minX=Math.min(...xs); const maxX=Math.max(...xs);
                const regData=[{x:minX,y:m*minX+b},{x:maxX,y:m*maxX+b}];
                const chart = mkChart(el,'scatter',{datasets:[
                    {label:'Temp vs Tiempo (s)', data:puntos, backgroundColor:'#2563eb'},
                    {type:'line', label:'Regresión', data:regData, borderColor:'#f59e0b', borderWidth:2, pointRadius:0, fill:false}
                ]},{responsive:true, scales:{x:{title:{display:true,text:'Temp masa (°C)'}}, y:{title:{display:true,text:'Tiempo total (s)'}, beginAtZero:true}}, plugins:{legend:{position:'bottom'}}});
                // Mostrar r en esquina superior
                setTimeout(()=>{
                    const ctx = chart.ctx; ctx.save(); ctx.font='12px Inter'; ctx.fillStyle='#1f2937';
                    ctx.fillText('r = '+r.toFixed(3), 50, 20); ctx.restore();
                },60);
            } else {
                mkChart(el,'scatter',{datasets:[{label:'Temp vs Tiempo (s)', data:puntos, backgroundColor:'#2563eb'}]},{responsive:true, scales:{x:{title:{display:true,text:'Temp masa (°C)'}}, y:{title:{display:true,text:'Tiempo total (s)'}, beginAtZero:true}}, plugins:{legend:{position:'bottom'}}});
            }
        })();
    }

    // ====== Export Tablas (CSV / PDF) ======
    function computeTablasStatsFromData(datos){
        const procesosNombres=['Esponja','Masa','Mantequilla'];
        let totalGenerales=[]; let procesoStats=[[],[],[]];
        let masaStats={}, amasadoraStats={}, tempMasaStats={}, tempCrossRaw=[];
        datos.forEach(reg=>{
            (reg.maquinas||[]).forEach(maq=>{
                const p1=maq.proceso1, p3=maq.proceso3;
                if(p1&&p1.startTime && p3 && p3.endTime){
                    const total=Math.max(0,Math.floor((p3.endTime-p1.startTime)/1000));
                    totalGenerales.push(total);
                }
                for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ const t=(parseInt(p.minutos)||0)*60+(parseInt(p.segundos)||0); procesoStats[i-1].push(t);} }
                const tipo=maq.tipoMasa||maq.tipoPan||'Sin tipo';
                const amaNumRaw = maq.numeroAmasadora || ((maq.nombre||maq.id||'').match(/\d+/)?.[0]);
                const ama = (amaNumRaw && ['1','2','3'].includes(String(amaNumRaw))) ? String(amaNumRaw) : (amaNumRaw ? String(amaNumRaw) : '?');
                let totalSimple=0; for(let i=1;i<=3;i++){ const p=maq['proceso'+i]; if(p){ totalSimple += (parseInt(p.minutos)||0)*60 + (parseInt(p.segundos)||0);} }
                (masaStats[tipo]=masaStats[tipo]||[]).push(totalSimple);
                (amasadoraStats[ama]=amasadoraStats[ama]||[]).push(totalSimple);
                const tm=parseFloat(maq.tempMasa); if(!isNaN(tm)){ (tempMasaStats[tipo]=tempMasaStats[tipo]||[]).push(tm); tempCrossRaw.push({tipo,ama,tm}); }
            });
        });
        // Resumen
        const resumenRows=[];
        if(totalGenerales.length){ const prom=Math.round(totalGenerales.reduce((a,b)=>a+b,0)/totalGenerales.length); const desv=Math.round(std(totalGenerales)); resumenRows.push(['N registros', totalGenerales.length],['Promedio total (s)',prom],['Desv (s)',desv],['%Desv',percent(desv,prom)]);}        
        procesoStats.forEach((arr,i)=>{ if(arr.length){ const prom=Math.round(arr.reduce((a,b)=>a+b,0)/arr.length); const desv=Math.round(std(arr)); resumenRows.push([`Prom ${procesosNombres[i]} (s)`,prom],[`Desv ${procesosNombres[i]} (s)`,desv],[`%Desv ${procesosNombres[i]}`,percent(desv,prom)]);} });
        // Pan rows
        const panRows=Object.keys(masaStats).map(k=>{const a=masaStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        // Amasadora rows
    const amaRows=Object.keys(amasadoraStats).map(k=>{const a=amasadoraStats[k]; const m=Math.round(a.reduce((x,y)=>x+y,0)/a.length); const d=Math.round(std(a)); return [k,a.length,m,d,percent(d,m)];});
        // Proceso rows
        const procesosN=['Esponja','Masa','Mantequilla'];
        const procRows=procesoStats.map((a,i)=> a.length? [procesosN[i], a.length, Math.round(a.reduce((x,y)=>x+y,0)/a.length), Math.round(std(a)), percent(Math.round(std(a)), Math.round(a.reduce((x,y)=>x+y,0)/a.length))]: null).filter(Boolean);
        // Temp por tipo
        const tempRows=Object.keys(tempMasaStats).map(k=>{const a=tempMasaStats[k]; const m=a.reduce((x,y)=>x+y,0)/a.length; const d=std(a); return [k,a.length,m.toFixed(1),d.toFixed(1),percent(d,m)];});
        // Cruzada temp
        const tiposOrden = Array.from(new Set(tempCrossRaw.map(r=>r.tipo)));
        const amasOrden = Array.from(new Set(tempCrossRaw.map(r=>r.ama)));
        const cruzHeaders=['Amasadora', ...tiposOrden];
        const cruzRows = amasOrden.map(a=>{
            const c=[a];
            tiposOrden.forEach(t=>{
                const subset = tempCrossRaw.filter(r=>r.ama===a && r.tipo===t).map(r=>r.tm);
                if(subset.length){ const avg=subset.reduce((x,y)=>x+y,0)/subset.length; c.push(avg.toFixed(1)); } else { c.push(''); }
            });
            return c;
        });
        return { resumenRows, panRows, amaRows, procRows, tempRows, cruzHeaders, cruzRows };
    }

    function exportTablasCSV(){
        const datos = getTablasData();
        if(!datos || !datos.length){ alert('No hay datos para exportar.'); return; }
    const { resumenRows, panRows, amaRows, procRows, tempRows, cruzHeaders, cruzRows } = computeTablasStatsFromData(datos);
        const rows=[];
        // Metadatos
    const fuenteCSV = (document.getElementById('tablas-source')?.value)||localStorage.getItem('TABLAS_SOURCE')||'local';
        const modo = localStorage.getItem('TABLAS_FECHA_MODO')||'rango';
        const diaSel = localStorage.getItem('TABLAS_BD_DIA')||'';
        const stamp = new Date().toISOString();
        const totalMaquinas = datos.reduce((a,r)=> a + (r.maquinas? r.maquinas.length:0),0);
    rows.push(['# Fuente', fuenteCSV]);
        rows.push(['# ModoFecha', modo]);
        if(diaSel) rows.push(['# DiaSeleccionado', diaSel]);
        rows.push(['# Registros(fecha)', datos.length]);
        rows.push(['# TotalMaquinas', totalMaquinas]);
        rows.push(['# Generado', stamp]);
        rows.push([]);
        rows.push(['Resumen de tiempos (s)']); rows.push(['Métrica','Valor']); resumenRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Promedios por tipo de masa']); rows.push(['Tipo masa','N','Prom (s)','Desv (s)','%Desv']); panRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Promedios por amasadora']); rows.push(['Amasadora','N','Prom (s)','Desv (s)','%Desv']); amaRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Promedios por proceso']); rows.push(['Proceso','N','Prom (s)','Desv (s)','%Desv']); procRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Temperatura por tipo de masa']); rows.push(['Tipo masa','N','Prom (°C)','Desv (°C)','%Desv']); tempRows.forEach(r=> rows.push(r)); rows.push([]);
        rows.push(['Temp. masa (Amasadora vs Tipo de masa)']); rows.push(cruzHeaders); cruzRows.forEach(r=> rows.push(r)); rows.push([]);
        // Personal por día (mín–máx)
        rows.push(['Personal por día (mín–máx)']); rows.push(['Fecha','N máquinas','Personal mín','Personal máx','Midpoint','Rango']);
        (function(){
            const perDay = {};
            datos.forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const bucket = perDay[fecha] = perDay[fecha] || { n:0, mins:[], maxs:[] };
                bucket.n += (reg.maquinas||[]).length;
                (reg.maquinas||[]).forEach(m=>{
                    const vmin = parseInt(m.personalMin); if(!isNaN(vmin)) bucket.mins.push(vmin);
                    const vmax = parseInt(m.personalMax); if(!isNaN(vmax)) bucket.maxs.push(vmax);
                });
                if(bucket.mins.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) bucket.mins.push(v); }
                if(bucket.maxs.length===0 && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) bucket.maxs.push(v); }
            });
            Object.keys(perDay).sort().forEach(fecha=>{
                const b=perDay[fecha];
                if(!(b.mins.length||b.maxs.length)) return;
                const min = b.mins.length? Math.min(...b.mins): '';
                const max = b.maxs.length? Math.max(...b.maxs): '';
                const midpoint = (typeof min==='number' && typeof max==='number')? Math.round((min + max)/2) : '';
                const rango = (typeof min==='number' && typeof max==='number')? (max - min) : '';
                rows.push([fecha, b.n, min, max, midpoint, rango]);
            });
        })();
        // TA/H por día
        rows.push([]);
        rows.push(['TA y Humedad por día']);
        rows.push(['Fecha','N máquinas','TA prom','H prom']);
        (function(){
            const acc={};
            const datos = getTablasData();
            (datos||[]).forEach(reg=>{
                const fecha = reg.fecha || '';
                if(!fecha) return;
                const b = acc[fecha] = acc[fecha] || { n:0, ta:[], h:[] };
                const maquinas = reg.maquinas||[]; b.n += maquinas.length;
                maquinas.forEach(m=>{
                    const ta = parseFloat(m.tempAmbiente); if(Number.isFinite(ta)) b.ta.push(ta);
                    const h = parseFloat(m.humedad); if(Number.isFinite(h)) b.h.push(h);
                });
                if(b.ta.length===0 && maquinas[0]){ const v=parseFloat(maquinas[0].tempAmbiente); if(Number.isFinite(v)) b.ta.push(v); }
                if(b.h.length===0 && maquinas[0]){ const v=parseFloat(maquinas[0].humedad); if(Number.isFinite(v)) b.h.push(v); }
            });
            Object.keys(acc).sort().forEach(fecha=>{
                const b=acc[fecha];
                if(!(b.ta.length||b.h.length)) return;
                const taProm = b.ta.length? (b.ta.reduce((x,y)=>x+y,0)/b.ta.length).toFixed(1): '';
                const hProm = b.h.length? (b.h.reduce((x,y)=>x+y,0)/b.h.length).toFixed(1): '';
                rows.push([fecha, b.n, taProm, hProm]);
            });
        })();
        // CSV manual
        const csv = rows.map(r=> r.map(v=> '"'+String(v==null?'':v).replace(/"/g,'""')+'"').join(',')).join('\r\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const fuente = (document.getElementById('tablas-source')?.value)||localStorage.getItem('TABLAS_SOURCE')||'local';
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download= fuente==='bd' ? 'tablas_bd.csv' : 'tablas_local.csv'; a.click(); URL.revokeObjectURL(a.href);
    }

    async function exportTablasPDF(){
        const { jsPDF } = window.jspdf || {};
        if(!jsPDF){ alert('jsPDF no cargó'); return; }
        const wrap = document.getElementById('tablas-wrapper') || document.getElementById('view-tablas');
        if(!wrap){ alert('No se encontró el contenedor de Tablas'); return; }
        try{
            const canvas = await html2canvas(wrap, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF('p','pt','a4');
            const pageW=pdf.internal.pageSize.getWidth();
            const pageH=pdf.internal.pageSize.getHeight();
            const imgW = pageW - 40; // margins
            const imgH = canvas.height * imgW / canvas.width;
            let y=20; let x=20;
            if(imgH <= pageH - 40){
                pdf.addImage(imgData, 'PNG', x, y, imgW, imgH);
            }else{
                // Paginar manualmente cortando el canvas en tramos
                const pageCanvas = document.createElement('canvas');
                const pageCtx = pageCanvas.getContext('2d');
                const ratio = imgW / canvas.width; // scale
                const pagePixelH = Math.floor((pageH - 40) / ratio);
                let offsetY = 0; let page=1;
                while(offsetY < canvas.height){
                    pageCanvas.width = canvas.width; pageCanvas.height = Math.min(pagePixelH, canvas.height - offsetY);
                    pageCtx.fillStyle = '#ffffff'; pageCtx.fillRect(0,0,pageCanvas.width,pageCanvas.height);
                    pageCtx.drawImage(canvas, 0, offsetY, pageCanvas.width, pageCanvas.height, 0, 0, pageCanvas.width, pageCanvas.height);
                    const segData = pageCanvas.toDataURL('image/png');
                    if(page>1) pdf.addPage();
                    pdf.addImage(segData, 'PNG', x, y, imgW, pageCanvas.height * ratio);
                    offsetY += pagePixelH; page++;
                }
            }
            const fuente = (document.getElementById('tablas-source')?.value)||localStorage.getItem('TABLAS_SOURCE')||'local';
            pdf.save(fuente==='bd' ? 'tablas_bd.pdf' : 'tablas_local.pdf');
        }catch(e){ alert('Error exportando PDF: '+(e.message||e)); }
    }

    document.getElementById('tablas-export-csv')?.addEventListener('click', exportTablasCSV);
    document.getElementById('tablas-export-pdf')?.addEventListener('click', exportTablasPDF);

    // ================= EXPORT SOLO RESULTADOS =================
    function getResultadosSource(){
        const bdW = document.getElementById('bd-wrapper');
        const isBD = bdW && !bdW.classList.contains('hidden');
        return isBD ? 'bd' : 'local';
    }
    function normalizeMaqForExport(m){
        if(m && !m.proceso1 && Array.isArray(m.procesos)){
            const map = {};
            m.procesos.forEach(p=>{ if(p && p.id!=null){ map['proceso'+p.id] = { minutos: p.minutos||0, segundos: p.segundos||0, startTime: p.startTime||null, endTime: p.endTime||null }; } });
            return { ...m, ...map };
        }
        return m;
    }
    function mapBDToResultados(arr){
        return (arr||[]).map(it=>({
            fecha: it?.data?.fecha || it?.fecha || '',
            maquinas: (it?.data?.amasadoras||[]).map(normalizeMaqForExport)
        }));
    }
    async function exportResultadosTabPDF(){
        const { jsPDF } = window.jspdf || {};
        if(!jsPDF){ alert('jsPDF no cargó'); return; }
        const source = getResultadosSource();
        let resultados = [];
        if(source==='bd'){
            // Usar caché BD si está disponible; de lo contrario, traerlo
            let data = Array.isArray(window.BD_CACHE)? window.BD_CACHE : [];
            if(!data || !data.length){ try{ data = await fetchRegistrosBD(); }catch(_){} }
            resultados = mapBDToResultados(data);
        }else{
            resultados = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        }
        if(!resultados.length){ alert('No hay resultados'); return; }
        const pdf = new jsPDF('p','pt','a4');
        const marginX=32, marginY=40; const pageW=pdf.internal.pageSize.getWidth(); const pageH=pdf.internal.pageSize.getHeight();
        let y=marginY; let page=1;
        function header(){
            pdf.setFontSize(14); pdf.setTextColor(30); pdf.text('Reporte de Resultados (Tabla)', marginX, 28);
            pdf.setFontSize(9); pdf.setTextColor(90); pdf.text(new Date().toLocaleString(), marginX, 40);
        }
        function footer(){
            const total=pdf.internal.getNumberOfPages();
            pdf.setFontSize(9); pdf.setTextColor(110);
            const foot='Página '+page+' / '+total; const w=pdf.getTextWidth(foot);
            pdf.text(foot, pageW - marginX - w, pageH - 12);
        }
        header();
        // Construir filas normalizadas como en CSV
    const diasN=['Dom','Lun','Mar','Mie','Jue','Vie','Sab'];
        // Encabezados (incluye Pers(rango) y Pers(mid))
    const cols=['Fecha','Lote','Dia','TA','H','Pers(rango)','Pers(mid)','Am','Tipo','Hi','TM','Pr','Min','Seg','Ini','Fin','T1','T2','TMT','Tot(s)','Obs'];
        // Nota: estos anchos pueden exceder el ancho de la página, manteniendo el estilo existente
        const colWidths=[55,40,40,25,25,40,28,40,55,35,40,36,24,24,40,40,28,28,36,42,90];
        function drawHeaderRow(){
            pdf.setFontSize(8); pdf.setFont('helvetica','bold'); pdf.setTextColor(20);
            let x=marginX; const h=14; pdf.setDrawColor(200); pdf.setLineWidth(0.25);
            cols.forEach((c,i)=>{ pdf.rect(x,y-10,colWidths[i],h,'S'); pdf.text(c, x+2, y); x+=colWidths[i]; });
            y+=2; pdf.setFont('helvetica','normal');
        }
        y+=20; drawHeaderRow(); y+=6;
        let prevFecha=null;
        resultados.sort((a,b)=>(a.fecha||'').localeCompare(b.fecha||''));
        resultados.forEach(reg=>{
            const fecha=reg.fecha||''; let dia='';
            if(fecha && fecha.length===10){ const [Y,M,D]=fecha.split('-').map(Number); dia=diasN[new Date(Y,M-1,D).getDay()]||''; }
            let dailyTA='', dailyH='';
            if(reg.maquinas && reg.maquinas.length){ const m0=reg.maquinas[0]; dailyTA=m0.tempAmbiente||''; dailyH=m0.humedad||''; }
            // Agregar personas por día (rango y midpoint)
            let pmins=[], pmaxs=[];
            (reg.maquinas||[]).forEach(m=>{ const vmin=parseInt(m.personalMin); if(!isNaN(vmin)) pmins.push(vmin); const vmax=parseInt(m.personalMax); if(!isNaN(vmax)) pmaxs.push(vmax); });
            if(!pmins.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) pmins.push(v); }
            if(!pmaxs.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) pmaxs.push(v); }
            const dailyPersMin = pmins.length? Math.min(...pmins): '';
            const dailyPersMax = pmaxs.length? Math.max(...pmaxs): '';
            const dailyPersMid = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? Math.round((dailyPersMin+dailyPersMax)/2): '';
            const dailyPersRange = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? `${dailyPersMin}-${dailyPersMax}`: '';
            (reg.maquinas||[]).forEach(maq=>{
                let tm1='', tm2='';
                if(maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime){ tm1=Math.max(0,Math.floor((maq.proceso2.startTime-maq.proceso1.endTime)/1000)); }
                if(maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime){ tm2=Math.max(0,Math.floor((maq.proceso3.startTime-maq.proceso2.endTime)/1000)); }
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; let totalSeg=null; if(primerStart&&ultimoEnd) totalSeg=Math.max(0,Math.floor((ultimoEnd-primerStart)/1000));
                const tmTot=(tm1||0)+(tm2||0);
                for(let i=1;i<=3;i++){
                    const proc=maq['proceso'+i]||{}; const min=proc.minutos||0; const seg=proc.segundos||0; const ini=proc.startTime? new Date(proc.startTime).toLocaleTimeString():''; const fin=proc.endTime? new Date(proc.endTime).toLocaleTimeString():'';
                    const row=[
                        i===1? (prevFecha===fecha?'':fecha):'',
                        i===1? (maq.lote||''):'',
                        i===1? (prevFecha===fecha?'':dia):'',
                        i===1? (prevFecha===fecha?'':dailyTA):'',
                        i===1? (prevFecha===fecha?'':dailyH):'',
                        i===1? (prevFecha===fecha?'':dailyPersRange):'',
                        i===1? (prevFecha===fecha?'':dailyPersMid):'',
                        i===1? ( (maq.numeroAmasadora||((maq.nombre||maq.id||'').match(/\d+/)?.[0])||'?') ):'',
                        i===1? (maq.tipoMasa||maq.tipoPan||''):'',
                        i===1? (maq.hielo||''):'',
                        i===1? (maq.tempMasa||''):'',
                        ['Esp','Mas','Mant'][i-1],
                        min, seg, ini, fin,
                        i===1? tm1:'', i===1? tm2:'', i===1? tmTot:'', i===1? (totalSeg??''):'', i===1? (maq.observaciones||''):''
                    ];
                    // Salto de página si necesario
                    if(y+14>pageH-30){ footer(); pdf.addPage(); page++; header(); y=marginY+10; drawHeaderRow(); y+=6; }
                    let x=marginX; const h=12; pdf.setFontSize(7.5); pdf.setDrawColor(225); pdf.setFillColor(255,255,255); pdf.setTextColor(40);
                    row.forEach((cell,ci)=>{
                        let txt=(''+(cell==null?'':cell));
                        if(txt.length>18) txt=txt.slice(0,17)+'…';
                        pdf.rect(x,y-9,colWidths[ci],h,'S');
                        pdf.text(txt, x+2, y);
                        x+=colWidths[ci];
                    });
                    y+=h-2;
                }
                prevFecha=fecha;
            });
        });
        footer();
        const stamp=new Date().toISOString().replace(/[:T]/g,'-').split('.')[0];
        pdf.save(`resultados_${source}_tabla_${stamp}.pdf`);
    }
    // CSV ordenado y compactando factores solo una vez (Locales o BD según subpestaña)
    async function exportResultadosTabCSV(){
        const source = getResultadosSource();
        let resultados = [];
        if(source==='bd'){
            let data = Array.isArray(window.BD_CACHE)? window.BD_CACHE : [];
            if(!data || !data.length){ try{ data = await fetchRegistrosBD(); }catch(_){} }
            resultados = mapBDToResultados(data);
        }else{
            resultados = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        }
        if(!resultados.length){ alert('No hay resultados'); return; }
        // Ordenar por fecha
        resultados.sort((a,b)=> (a.fecha||'').localeCompare(b.fecha||''));
        const rows=[];
        // Encabezados principales
        const headers=[
            'Fecha','Lote','Dia','TA','H','Pers(rango)','Pers(mid)',
            'Am','Tipo','Hi','TM',
            'Pr','Min','Seg','Ini','Fin','T1','T2','TMT','Tot(s)','Obs'
        ];
        rows.push(headers);
    const diasN=['Dom','Lun','Mar','Mie','Jue','Vie','Sab'];
        let fechaPrev=null;
        resultados.forEach(reg=>{
            const fecha=reg.fecha||'';
            let dia='';
            if(fecha && fecha.length===10){ const [y,m,d]=fecha.split('-').map(Number); dia=diasN[new Date(y,m-1,d).getDay()]||''; }
            // Factores diarios (TA,H) y Personas (rango y midpoint)
            let dailyTA=''; let dailyH='';
            if(reg.maquinas && reg.maquinas.length){ const m0=reg.maquinas[0]; dailyTA=m0.tempAmbiente||''; dailyH=m0.humedad||''; }
            // Personal por día (rango y midpoint) agregado en este registro
            let pmins=[], pmaxs=[];
            (reg.maquinas||[]).forEach(m=>{ const vmin=parseInt(m.personalMin); if(!isNaN(vmin)) pmins.push(vmin); const vmax=parseInt(m.personalMax); if(!isNaN(vmax)) pmaxs.push(vmax); });
            if(!pmins.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMin); if(!isNaN(v)) pmins.push(v); }
            if(!pmaxs.length && reg.maquinas && reg.maquinas[0]){ const v=parseInt(reg.maquinas[0].personalMax); if(!isNaN(v)) pmaxs.push(v); }
            const dailyPersMin = pmins.length? Math.min(...pmins): '';
            const dailyPersMax = pmaxs.length? Math.max(...pmaxs): '';
            const dailyPersMid = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? Math.round((dailyPersMin+dailyPersMax)/2): '';
            const dailyPersRange = (typeof dailyPersMin==='number' && typeof dailyPersMax==='number')? `${dailyPersMin}-${dailyPersMax}`: '';
            (reg.maquinas||[]).forEach(maq=>{
                const baseFecha = (fechaPrev===fecha)? '' : fecha; // solo primera vez del día
                const baseDia = (baseFecha? dia : '');
                const baseTA = (baseFecha? dailyTA : '');
                const baseH = (baseFecha? dailyH : '');
                const basePersRange = (baseFecha? dailyPersRange : '');
                const basePersMid = (baseFecha? dailyPersMid : '');
                fechaPrev=fecha; // marcar
                // Calcular tiempos muertos máquina
                let tm1='', tm2='';
                if(maq.proceso1 && maq.proceso2 && maq.proceso1.endTime && maq.proceso2.startTime){ tm1 = Math.max(0, Math.floor((maq.proceso2.startTime - maq.proceso1.endTime)/1000)); }
                if(maq.proceso2 && maq.proceso3 && maq.proceso2.endTime && maq.proceso3.startTime){ tm2 = Math.max(0, Math.floor((maq.proceso3.startTime - maq.proceso2.endTime)/1000)); }
                let primerStart=maq.proceso1?.startTime; let ultimoEnd=maq.proceso3?.endTime; let totalSeg=null; if(primerStart && ultimoEnd){ totalSeg=Math.max(0, Math.floor((ultimoEnd - primerStart)/1000)); }
                const tmTotal = (tm1||0)+(tm2||0);
                for(let i=1;i<=3;i++){
                    const proc=maq['proceso'+i]||{};
                    const minutos=proc.minutos||0; const segundos=proc.segundos||0;
                    const inicio=proc.startTime? new Date(proc.startTime).toLocaleTimeString():'';
                    const fin=proc.endTime? new Date(proc.endTime).toLocaleTimeString():'';
                    rows.push([
                        i===1? baseFecha:'',
                        i===1? (maq.lote||''):'',
                        i===1? baseDia:'',
                        i===1? baseTA:'',
                        i===1? baseH:'',
                        i===1? basePersRange:'',
                        i===1? basePersMid:'',
                        i===1? ( (maq.numeroAmasadora||((maq.nombre||maq.id||'').match(/\d+/)?.[0])||'?') ):'',
                        i===1? (maq.tipoMasa||maq.tipoPan||''):'',
                        i===1? (maq.hielo||''):'',
                        i===1? (maq.tempMasa||''):'',
                        ['Esp','Mas','Mant'][i-1],
                        minutos, segundos, inicio, fin,
                        i===1? tm1:'', i===1? tm2:'', i===1? tmTotal:'', i===1? (totalSeg??''):'', i===1? (maq.observaciones||''):'']);
                }
            });
        });
        // Convertir a CSV manualmente para evitar dependencias
        const csv = rows.map(r=> r.map(v=>{
            const s = (v===null||v===undefined)? '' : (''+v).replace(/"/g,'""');
            return '"'+s+'"';
        }).join(',')).join('\r\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const stamp = new Date().toISOString().replace(/[:T]/g,'-').split('.')[0];
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`resultados_${source}_ordenado_${stamp}.csv`; a.click(); URL.revokeObjectURL(a.href);
    }
    document.addEventListener('DOMContentLoaded', ()=>{
        initAuthUI();
        guardRoute();
        // Actualizar visibilidad de Ajustes según estado de sesión
        try{ updateAjustesVisibility(); }catch(_){ }
        document.getElementById('btn-export-resultados-pdf')?.addEventListener('click', exportResultadosTabPDF);
        document.getElementById('btn-export-resultados-csv')?.addEventListener('click', exportResultadosTabCSV);
            // Toggle descripciones de gráficas
            document.querySelectorAll('#view-tablas .chart-title').forEach(h=>{
                h.addEventListener('click', ()=>{
                    const desc = h.nextElementSibling;
                    if(desc && desc.classList.contains('chart-desc')){
                        desc.style.display = (desc.style.display==='none'|| !desc.style.display)?'block':'none';
                    }
                });
                // iniciar oculto siempre
                const d=h.nextElementSibling; if(d && d.classList.contains('chart-desc')) d.style.display='none';
            });
        // Inyección de controles BD si aún no existen (sin override de API)
        if(!document.getElementById('sync-status')){
            const filtros = document.querySelector('#view-resultados .flex.flex-wrap.gap-4');
            if(filtros){
                const extra = document.createElement('div');
                extra.className='flex flex-wrap gap-2 items-center';
                extra.innerHTML = `
                    <div class="flex flex-wrap gap-2 items-center">
                        <button id="btn-sync-bd" class="bg-indigo-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-indigo-700">Ver resultados previos</button>
                        <button id="btn-pasar-fecha-bd" class="bg-amber-600 text-white px-3 py-1 rounded text-sm font-semibold hover:bg-amber-700" title="Guardar todos los registros de la fecha seleccionada en la base de datos">Guardar resultados en la BD</button>
                    </div>
                    <div id="sync-status" class="text-xs text-stone-600 mt-1 w-full"></div>
                `;
                filtros.parentNode.insertBefore(extra, filtros.nextSibling);
            }
        }
        initApiLogic();
    });

    // ================= BACKEND SYNC / API DINÁMICA =================
    function getDefaultApiBase(){
        try{
            // Siempre usar la URL pública del backend
            return 'https://pdt-backend-1.onrender.com';
        }catch(_){ return ''; }
    }
    function resolveApiBase(){
        const override = localStorage.getItem('API_URL_OVERRIDE');
        return (override && override.trim()) || getDefaultApiBase();
    }
    // API auth helpers: read key from session/local and build headers
    function getApiKey(){
        return sessionStorage.getItem('API_KEY') || localStorage.getItem('API_KEY_PERSIST') || '';
    }
    function apiHeaders(withJson){
        const h = {};
        if(withJson) h['Content-Type'] = 'application/json';
        const k = getApiKey();
        if(k) h['x-api-key'] = k;
        return h;
    }
    function setStatus(msg,type='info'){
        const el=document.getElementById('sync-status');
        if(el){ el.textContent = msg; el.className = 'text-xs mt-1 '+(type==='err'?'text-red-600': type==='ok'?'text-green-600':'text-stone-600'); }
    }
    // Toast amigable
    function mostrarToast(msg, tipo='success'){
        let toast = document.getElementById('toast-msg');
        if(!toast){
            toast = document.createElement('div');
            toast.id = 'toast-msg';
            toast.style.position = 'fixed';
            toast.style.bottom = '30px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.zIndex = '9999';
            toast.style.padding = '16px 32px';
            toast.style.borderRadius = '12px';
            toast.style.fontSize = '1.1rem';
            toast.style.fontWeight = 'bold';
            toast.style.boxShadow = '0 2px 12px rgba(0,0,0,0.12)';
            document.body.appendChild(toast);
        }
        toast.textContent = msg;
        toast.style.background = tipo==='success' ? '#22c55e' : '#ef4444';
        toast.style.color = '#fff';
        toast.style.opacity = '1';
        setTimeout(()=>{ toast.style.opacity = '0'; }, 3000);
    }
    function signature(fecha, maq){
        const p1Start = maq?.proceso1?.startTime || ''; // puede ser null
        const tipo = (maq?.tipoMasa||maq?.tipoPan||'').trim().toLowerCase();
        return `${fecha}__${(maq?.nombre||maq?.id||'').trim()}__${tipo}__${p1Start}`;
    }
    // ========= Seguridad simple: clave local =========
    const DEFAULT_PASS = 'pasantias'; // Clave fija para acceso y API
    async function sha256Hex(str){
        const enc = new TextEncoder(); const data = enc.encode(str);
        const hash = await crypto.subtle.digest('SHA-256', data);
        const bytes = Array.from(new Uint8Array(hash));
        return bytes.map(b=> b.toString(16).padStart(2,'0')).join('');
    }
    function showAuthOverlay(){ const ov=document.getElementById('auth-overlay'); if(ov) ov.classList.remove('hidden'); }
    function hideAuthOverlay(){ const ov=document.getElementById('auth-overlay'); if(ov) ov.classList.add('hidden'); }
    function isLocked(){ return localStorage.getItem('APP_LOCKED')==='1'; }
    function lockApp(){ localStorage.setItem('APP_LOCKED','1'); sessionStorage.removeItem('APP_UNLOCKED'); try{ updateAjustesVisibility(); }catch(_){ } showAuthOverlay(); }
    async function tryLogin(pass){
        const saved = localStorage.getItem('APP_PASS_HASH');
        if(!saved) return false;
        const h = await sha256Hex(pass);
        return h===saved;
    }
    async function setNewPass(pass){ /* Deshabilitado: clave fija */ return; }
    function isRemembered(){ return localStorage.getItem('APP_REMEMBER')==='1'; }
    function markRemembered(on){ if(on) localStorage.setItem('APP_REMEMBER','1'); else localStorage.removeItem('APP_REMEMBER'); }
    function isUnlocked(){ return !isLocked() && (sessionStorage.getItem('APP_UNLOCKED')==='1' || isRemembered()); }
    function updateAjustesVisibility(){
        const card = document.getElementById('ajustes-card');
        if(!card) return;
        card.classList.toggle('hidden', !isUnlocked());
    }

    function initAuthUI(){
        const btnLock = document.getElementById('btn-lock-app');
        btnLock?.addEventListener('click', ()=> lockApp());
        const ov = document.getElementById('auth-overlay'); if(!ov) return;
        // Forzar hash de clave fija
    try{ sha256Hex(DEFAULT_PASS).then(h=> localStorage.setItem('APP_PASS_HASH', h)); }catch(_){ }
        // Rate limiting simple
        function authMeta(){
            try{ return JSON.parse(localStorage.getItem('AUTH_META')||'{}'); }catch(_){ return {}; }
        }
        function saveAuthMeta(m){ localStorage.setItem('AUTH_META', JSON.stringify(m)); }
        function canTry(){
            const m=authMeta();
            const now=Date.now();
            if(m.lockUntil && now < m.lockUntil) return false;
            return true;
        }
        function registerFail(){
            const m=authMeta();
            m.failCount = (m.failCount||0)+1;
            if(m.failCount>=5){
                // Bloqueo exponencial suave: 30s * 2^(failCount-5) (máx 10 min)
                const extra = Math.min(600000, 30000 * Math.pow(2, m.failCount-5));
                m.lockUntil = Date.now() + extra;
            }
            saveAuthMeta(m);
        }
        function registerSuccess(){ saveAuthMeta({ failCount:0, lockUntil:0 }); }
        // Cancel estricto: si está bloqueado, no permite cerrar el overlay
        document.getElementById('auth-cancel')?.addEventListener('click', ()=>{
            if(isLocked()){
                // Mantener overlay visible y dar feedback sutil
                const msg = document.getElementById('auth-msg');
                if(msg){ msg.textContent = 'App bloqueada: ingresa la clave o restablécela.'; msg.className='mt-3 text-sm text-red-600'; }
                return;
            }
            hideAuthOverlay();
        });
        document.getElementById('auth-submit')?.addEventListener('click', async ()=>{
            const msgEl = document.getElementById('auth-msg'); msgEl.textContent=''; msgEl.className='mt-3 text-sm';
            if(!canTry()){
                const m=authMeta();
                const wait = Math.max(0, Math.floor(((m.lockUntil||0)-Date.now())/1000));
                msgEl.textContent='Demasiados intentos. Espera '+wait+'s.'; msgEl.classList.add('text-red-600');
                return;
            }
            const pass = document.getElementById('auth-pass').value;
            if(pass!==DEFAULT_PASS){ msgEl.textContent='Clave incorrecta.'; msgEl.classList.add('text-red-600'); try{ registerFail(); }catch(_){ } return; }
            sessionStorage.setItem('APP_UNLOCKED','1');
            const remember = document.getElementById('auth-recordar').checked; markRemembered(remember);
            if(remember) localStorage.removeItem('APP_LOCKED');
            try{ updateAjustesVisibility(); }catch(_){ }
            hideAuthOverlay();
            registerSuccess();
        });
        showAuthOverlay();
    }
    function guardRoute(){
        const hasPass = !!localStorage.getItem('APP_PASS_HASH');
        const unlockedSession = sessionStorage.getItem('APP_UNLOCKED')==='1';
        const remembered = isRemembered();
        if(!hasPass){ return; } // sin clave, no bloquear
    if(isLocked()) { showAuthOverlay(); return; }
        if(remembered){ hideAuthOverlay(); return; }
        if(!unlockedSession){ showAuthOverlay(); }
    }
    function mergeLocalRemote(localRegs, remoteRegs){
        const sigSet = new Set();
        localRegs.forEach(r=> (r.maquinas||[]).forEach(m=> sigSet.add(signature(r.fecha,m))));
        let nuevos=0;
        remoteRegs.forEach(r=>{
            (r.maquinas||[]).forEach(m=>{
                const sig = signature(r.fecha,m);
                if(!sigSet.has(sig)){
                    // Normalizar objeto remoto a formato local (quitar campos adicionales)
                    const mLoc = {
                        id: m.id || m.nombre || '',
                        nombre: m.nombre || m.id || '',
                        tipoMasa: m.tipoMasa || m.tipoPan || '',
                        hielo: m.hielo || '',
                        personal: m.personal || '',
                        tempAmbiente: m.tempAmbiente || r.tempAmbiente || '',
                        humedad: m.humedad || r.humedad || '',
                        tempMasa: m.tempMasa || '',
                        observaciones: m.observaciones || '',
                        proceso1: m.proceso1 ? { minutos: m.proceso1.minutos||0, segundos: m.proceso1.segundos||0, startTime: m.proceso1.startTime||null, endTime: m.proceso1.endTime||null } : undefined,
                        proceso2: m.proceso2 ? { minutos: m.proceso2.minutos||0, segundos: m.proceso2.segundos||0, startTime: m.proceso2.startTime||null, endTime: m.proceso2.endTime||null } : undefined,
                        proceso3: m.proceso3 ? { minutos: m.proceso3.minutos||0, segundos: m.proceso3.segundos||0, startTime: m.proceso3.startTime||null, endTime: m.proceso3.endTime||null } : undefined
                    };
                    // Insertar en local
                    let target = localRegs.find(x=>x.fecha===r.fecha);
                    if(!target){ target = { fecha: r.fecha, maquinas: [] }; localRegs.push(target); }
                    target.maquinas.push(mLoc); nuevos++;
                    sigSet.add(sig);
                }
            });
        });
        return { merged: localRegs, nuevos };
    }
    async function fetchRegistrosBD(){
    const base = resolveApiBase();
    // Siempre usar /registros directo, sin /api
    const url = base + '/registros';
    const r = await fetch(url, { headers: apiHeaders(false) });
        if(!r.ok) throw new Error('Error HTTP '+r.status);
        return await r.json();
    }
    async function syncDesdeBD(){
        try{
            setStatus('Sincronizando...');
            const rem = await fetchRegistrosBD();
            let local = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
            const { merged, nuevos } = mergeLocalRemote(local, rem);
            if(nuevos){
                localStorage.setItem('resultadosMezclado', JSON.stringify(merged));
                setStatus(`Sync completado. Nuevos registros: ${nuevos}`, 'ok');
            } else {
                setStatus('Sync completado. No había nuevos registros.', 'info');
            }
            // Refrescar vistas si están visibles
            if(!document.getElementById('view-resultados')?.classList.contains('hidden')){ if(typeof cargarResultados==='function') cargarResultados(); }
            if(!document.getElementById('view-tablas')?.classList.contains('hidden')){ if(typeof buildTablasVista==='function') buildTablasVista(); }
        }catch(e){ setStatus('Error sync: '+(e.message||e),'err'); }
    }
    function construirPayloadFecha(fecha){
        const todos = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
        const registrosFecha = todos.filter(r=>r.fecha===fecha);
        if(!registrosFecha.length) return null;
        const amasadoras=[];
        // Acumuladores para resumen del día
        let cantidadAmasadoras = 0;
        let tm1SegDia = 0, tm2SegDia = 0, muertosSegDia = 0, totalRealSegDia = 0, totalProcesosSegDia = 0;
        let sumTempMasa = 0, countTempMasa = 0;
        const tiposMasaConteo = {}; const hieloConteo = {};
        registrosFecha.forEach(r=> (r.maquinas||[]).forEach(m=>{
            const procesos=[];
            for(let i=1;i<=3;i++){
                const p=m['proceso'+i];
                if(p){ procesos.push({ id:i, minutos: parseInt(p.minutos)||0, segundos: parseInt(p.segundos)||0, startTime: p.startTime||null, endTime: p.endTime||null }); }
            }
            // Derivados por máquina
            const p1 = m.proceso1||{}; const p2 = m.proceso2||{}; const p3 = m.proceso3||{};
            const toSecs = (pp)=> (parseInt(pp?.minutos)||0)*60 + (parseInt(pp?.segundos)||0);
            const sumProcesosSeg = toSecs(p1)+toSecs(p2)+toSecs(p3);
            const tm1Seg = (p1?.endTime && p2?.startTime) ? Math.max(0, Math.floor((p2.startTime - p1.endTime)/1000)) : null;
            const tm2Seg = (p2?.endTime && p3?.startTime) ? Math.max(0, Math.floor((p3.startTime - p2.endTime)/1000)) : null;
            const muertosSeg = (tm1Seg||0) + (tm2Seg||0);
            const totalRealSeg = (p1?.startTime && p3?.endTime) ? Math.max(0, Math.floor((p3.endTime - p1.startTime)/1000)) : null;
            const nombreMaq = m.nombre||m.id||'';
            const numeroAmasadora = (nombreMaq.match(/\d+/)?.[0]) || '';
            // Acumular para resumen de día
            cantidadAmasadoras += 1;
            if (tm1Seg!=null) tm1SegDia += tm1Seg;
            if (tm2Seg!=null) tm2SegDia += tm2Seg;
            muertosSegDia += muertosSeg;
            if (totalRealSeg!=null) totalRealSegDia += totalRealSeg;
            totalProcesosSegDia += sumProcesosSeg;
            const tMasa = parseFloat(m.tempMasa);
            if (Number.isFinite(tMasa)) { sumTempMasa += tMasa; countTempMasa += 1; }
            const tipo = (m.tipoMasa||m.tipoPan||'').trim(); if(tipo){ tiposMasaConteo[tipo] = (tiposMasaConteo[tipo]||0)+1; }
            const hielo = (m.hielo||'').trim(); if(hielo){ hieloConteo[hielo] = (hieloConteo[hielo]||0)+1; }
            amasadoras.push({
                id: m.id||numeroAmasadora||'',
                nombre: nombreMaq,
                numeroAmasadora,
                tipoMasa: m.tipoMasa||m.tipoPan||'',
                hielo: m.hielo||'',
                lote: m.lote||'',
                tempMasa: m.tempMasa||'',
                observaciones: m.observaciones||'',
                // factores por máquina (duplicados aquí para conservar contexto por equipo)
                personalMin: m.personalMin||r.maquinas?.[0]?.personalMin||'',
                personalMax: m.personalMax||r.maquinas?.[0]?.personalMax||'',
                tempAmbiente: m.tempAmbiente||r.tempAmbiente||'',
                humedad: m.humedad||r.humedad||'',
                // métricas derivadas
                tm1Seg, tm2Seg, muertosSeg, totalRealSeg, totalProcesosSeg: sumProcesosSeg,
                procesos,
                firma: (fecha+'|'+(numeroAmasadora||'')+'|'+(m.lote||'')+'|'+((p1 && p1.startTime) || '')+'|'+((p3 && p3.endTime) || '')),
            });
        }));
        if(!amasadoras.length) return null;
    // Tomar factores generales de la primera máquina
    const ref = registrosFecha[0].maquinas[0];
        const payloadBase = {
            fecha,
            tempAmbiente: ref.tempAmbiente||'',
            humedad: ref.humedad||'',
            personalMin: ref.personalMin||'',
            personalMax: ref.personalMax||'',
            resumenDia: {
                fecha,
                cantidadAmasadoras,
                tm1SegDia,
                tm2SegDia,
                muertosSegDia,
                totalRealSegDia,
                totalProcesosSegDia,
                promedioTempMasaDia: countTempMasa ? (sumTempMasa / countTempMasa) : null,
                tiposMasaConteo,
                hieloConteo
            },
            amasadoras
        };
        // Hash idempotente simple (no criptográfico fuerte, suficiente para dedupe)
        try{
            const raw = JSON.stringify(payloadBase.amasadoras.map(a=>a.firma).sort());
            let h=0; for(let i=0;i<raw.length;i++){ h = Math.imul(31,h) + raw.charCodeAt(i) | 0; }
            payloadBase.idempotencyKey = 'FECHA_'+fecha+'_'+(h>>>0).toString(16);
        }catch(_){ }
        return payloadBase;
    }
    async function pasarFechaABD(){
        const fecha = document.getElementById('fecha')?.value;
        if(!fecha){ setStatus('Selecciona una fecha en el campo superior para enviar.', 'err'); return; }
        const payload = construirPayloadFecha(fecha);
        if(!payload){
            setStatus('No hay datos guardados para la fecha seleccionada. Primero guarda al menos una máquina antes de enviar.', 'info');
            return;
        }
        try{
            setStatus('Enviando a BD...');
            const base=resolveApiBase();
            // Siempre usar /registros directo, sin /api
            const url = base + '/registros';
            const r = await fetch(url,{ method:'POST', headers: apiHeaders(true), body: JSON.stringify(payload) });
            if(!r.ok){ const txt=await r.text(); throw new Error('HTTP '+r.status+' '+txt); }
            setStatus('¡Resultados guardados exitosamente en la base de datos!', 'ok');
            mostrarToast('¡Resultados guardados exitosamente en la base de datos!', 'success');
        }catch(e){ setStatus('Error enviando: '+(e.message||e),'err'); mostrarToast('Error enviando: '+(e.message||e),'error'); }
    }
    function initApiLogic(){
        document.getElementById('btn-sync-bd')?.addEventListener('click', syncDesdeBD);
        const btnPasarFecha = document.getElementById('btn-pasar-fecha-bd');
        if(btnPasarFecha){
            // Mantener siempre clickeable y dar feedback dentro de pasarFechaABD()
            btnPasarFecha.addEventListener('click', pasarFechaABD);
            // Mostrar una pista informativa si no hay datos guardados para la fecha
            const fechaInput = document.getElementById('fecha');
            function hintDatosParaFecha(){
                const fecha = fechaInput?.value;
                const todos = JSON.parse(localStorage.getItem('resultadosMezclado')||'[]');
                const hayDatos = fecha && todos.some(r=>r.fecha===fecha);
                if(!fecha){ setStatus('Selecciona una fecha para enviar.', 'info'); return; }
                if(!hayDatos){ setStatus('No hay datos guardados para esa fecha. Guarda al menos una máquina en Medición.', 'info'); }
                else { setStatus('Listo para enviar a la BD.', 'info'); }
            }
            fechaInput?.addEventListener('input', hintDatosParaFecha);
            window.addEventListener('storage', hintDatosParaFecha);
            hintDatosParaFecha();
        }
        // Auto sync inicial (suave)
        setTimeout(()=>{ if(!localStorage.getItem('SYNC_INICIAL_REALIZADA')){ syncDesdeBD().finally(()=> localStorage.setItem('SYNC_INICIAL_REALIZADA','1')); } }, 1200);
    }
</script>
</html>